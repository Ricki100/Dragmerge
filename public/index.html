<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
            padding: 20px;
        }

        .main-container {
            display: flex;
            height: calc(100vh - 40px);
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }

        .sidebar.collapsed {
            width: 50px;
        }

        .sidebar-header {
            background: #007bff;
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h1 {
            font-size: 16px;
            white-space: nowrap;
            overflow: hidden;
        }

        .toggle-sidebar {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            padding: 5px;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .sidebar.collapsed .sidebar-content {
            display: none;
        }

        .section {
            margin-bottom: 20px;
        }

        .section-header {
            font-size: 11px;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Enhanced Box Management Styles */
        .box-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .box-type-buttons {
            display: flex;
            gap: 4px;
        }

        .box-type-buttons .btn {
            flex: 1;
            margin-bottom: 0;
            font-size: 10px;
            padding: 6px 4px;
        }

        .box-editor {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 12px;
            margin-top: 8px;
            display: none;
        }

        .box-editor.active {
            display: block;
        }

        .box-editor h4 {
            font-size: 12px;
            margin-bottom: 8px;
            color: #333;
        }

        .form-group {
            margin-bottom: 8px;
        }

        .form-group label {
            display: block;
            font-size: 10px;
            font-weight: 500;
            color: #666;
            margin-bottom: 2px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 10px;
        }

        .form-group input[type="color"] {
            height: 24px;
            padding: 2px;
        }

        .form-row {
            display: flex;
            gap: 6px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .checkbox-group {
            display: flex;
            gap: 8px;
            margin-top: 4px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .checkbox-item label {
            font-size: 9px;
            margin: 0;
            color: #666;
        }

        /* Font Upload Styles */
        .font-upload-area {
            border: 2px dashed #ccc;
            border-radius: 4px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .font-upload-area:hover {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .font-upload-area.dragover {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .font-upload-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .font-upload-content span {
            font-size: 20px;
        }

        .font-upload-content p {
            font-size: 10px;
            margin: 0;
            color: #666;
        }

        .google-font-input {
            display: flex;
            gap: 4px;
        }

        .google-font-input input {
            flex: 1;
            font-size: 10px;
        }

        .google-font-input button {
            font-size: 10px;
            padding: 4px 8px;
            white-space: nowrap;
        }

        .font-status {
            font-size: 9px;
            margin-top: 4px;
            min-height: 12px;
        }

        .font-status.success {
            color: #28a745;
        }

        .font-status.error {
            color: #dc3545;
        }

        .font-status.warning {
            color: #ffc107;
        }

        .style-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .style-checkboxes .checkbox-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
        }

        .style-checkboxes .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .style-checkboxes .checkbox-item span {
            color: #666;
        }

        /* Record Navigation Styles */
        .record-navigation {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
        }

        .nav-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .nav-controls button {
            padding: 4px 8px;
            font-size: 10px;
            min-width: 30px;
        }

        .nav-controls span {
            font-size: 10px;
            color: #666;
            flex: 1;
            text-align: center;
        }

        .box-actions {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }

        .box-actions .btn {
            flex: 1;
            margin-bottom: 0;
            font-size: 9px;
            padding: 4px 6px;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        /* CSV Preview Enhancement */
        .csv-preview {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            max-height: 120px;
            overflow-y: auto;
        }

        .csv-table {
            width: 100%;
            font-size: 9px;
            border-collapse: collapse;
        }

        .csv-table th,
        .csv-table td {
            padding: 2px 4px;
            border: 1px solid #e9ecef;
            text-align: left;
        }

        .csv-table th {
            background: #f8f9fa;
            font-weight: 600;
        }

        .csv-table td {
            max-width: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-input {
            display: block;
            width: 100%;
            padding: 8px;
            border: 2px dashed #ccc;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            text-align: center;
            transition: border-color 0.3s;
            font-size: 11px;
            margin-bottom: 8px;
        }

        .file-input:hover {
            border-color: #007bff;
        }

        .file-input input[type="file"] {
            display: none;
        }

        .btn {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-bottom: 6px;
            transition: background-color 0.3s;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .status-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #666;
        }

        .status-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #dc3545;
        }

        .status-indicator.loaded {
            background: #28a745;
        }

        .reset-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            margin-top: 10px;
        }

        .reset-btn:hover {
            background: #c82333;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #f8f9fa;
            position: relative;
        }

        .content-header {
            background: white;
            border-bottom: 1px solid #e9ecef;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .content-header h3 {
            font-size: 14px;
            color: #333;
        }

        .editor-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .editor-btn {
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: background-color 0.3s;
        }

        .editor-btn-primary {
            background: #007bff;
            color: white;
        }

        .editor-btn-primary:hover {
            background: #0056b3;
        }

        .editor-btn-secondary {
            background: #6c757d;
            color: white;
        }

        .editor-btn-secondary:hover {
            background: #545b62;
        }

        .editor-btn-success {
            background: #28a745;
            color: white;
        }

        .editor-btn-success:hover {
            background: #1e7e34;
        }

        .editor-btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .editor-btn-warning:hover {
            background: #e0a800;
        }

        .editor-btn-danger {
            background: #dc3545;
            color: white;
        }

        .editor-btn-danger:hover {
            background: #c82333;
        }

        .editor-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .viewer-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #f0f0f0;
        }

        .pdf-viewer {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
        }

        .pdf-viewer.dragging {
            cursor: grabbing;
        }

        .pdf-content {
            position: absolute;
            transform-origin: 0 0;
            transition: transform 0.1s ease;
        }



        .pdf-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }

        .pdf-control-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s;
        }

        .pdf-control-btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        .pdf-control-btn:disabled {
            background: rgba(0, 0, 0, 0.3);
            cursor: not-allowed;
        }

        .zoom-display {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            min-width: 60px;
            text-align: center;
        }

        .no-pdf {
            text-align: center;
            color: #666;
            padding: 40px;
        }

        .no-pdf h3 {
            margin-bottom: 10px;
            color: #333;
        }

        #viewer {
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            background: white;
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1;
        }

        .loading {
            text-align: center;
            color: #666;
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Layout Editor Styles */
        .editor-sidebar {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 250px;
            background: white;
            border-left: 1px solid #ddd;
            padding: 15px;
            overflow-y: auto;
            display: none;
            box-shadow: -2px 0 8px rgba(0,0,0,0.1);
        }

        .editor-sidebar.active {
            display: block;
        }

        .editor-sidebar h4 {
            font-size: 12px;
            margin-bottom: 10px;
            color: #333;
        }

        .editor-form-group {
            margin-bottom: 10px;
        }

        .editor-form-group label {
            display: block;
            margin-bottom: 3px;
            font-size: 10px;
            color: #666;
        }

        .editor-form-group input, .editor-form-group select, .editor-form-group textarea {
            width: 100%;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 10px;
        }

        .editor-form-group textarea {
            height: 40px;
            resize: vertical;
        }

        .grid-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .grid-toggle label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            cursor: pointer;
        }

        .grid-toggle input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .editor-status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
        }

        /* Fabric.js canvas styling */
        .canvas-container {
            position: relative;
            display: inline-block;
        }

        #editorCanvas {
            border: 1px solid #ddd;
            background: transparent;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: auto;
            z-index: 10;
        }

        /* Visual feedback for placement mode */
        .placement-mode {
            background: rgba(0, 123, 255, 0.1) !important;
            border: 2px dashed #007bff !important;
        }

        /* Enhanced text box styles */
        .draggable-text-box {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #007bff;
            padding: 5px;
            cursor: move;
            min-width: 80px;
            min-height: 25px;
            font-family: Arial, sans-serif;
            font-size: 16px;
            color: #000;
            text-align: center;
            user-select: none;
            z-index: 20;
            transition: all 0.1s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            word-wrap: break-word;
            white-space: normal;
        }

        .draggable-text-box:hover {
            border-color: #0056b3;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .draggable-text-box:focus {
            outline: none;
            border-color: #28a745;
            box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.25);
        }

        .draggable-text-box.resizing {
            border-color: #ff6b35;
            box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.25);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h1>PDF Viewer</h1>
                <button class="toggle-sidebar" onclick="toggleSidebar()">‚â°</button>
            </div>
            <div class="sidebar-content">
                <div class="section">
                    <h2 class="section-header">File Uploads</h2>
                    <label class="file-input" for="pdfFile">
                        <input type="file" id="pdfFile" accept="application/pdf">
                        <div id="fileLabel">Click to select PDF file</div>
                    </label>
                    
                    <label class="file-input" for="csvFile">
                        <input type="file" id="csvFile" accept=".csv,text/csv">
                        <div id="csvLabel">Click to select CSV file</div>
                    </label>
                    

                    
                    <button id="generateFromTemplateBtn" class="btn btn-primary" onclick="generateFromTemplate()" disabled>
                        Generate From Template
                    </button>
                    
                    <div id="downloadLink" style="display: none;">
                        <a id="downloadAnchor" href="#" target="_blank" class="btn btn-primary" style="text-decoration: none; display: inline-block;">Download Original PDF</a>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-header">Layout Editor</h2>
                    <div class="box-controls">
                        <div class="box-type-buttons">
                            <button class="btn btn-primary" onclick="addText()">Add Text</button>
                            <button class="btn btn-secondary" onclick="addImagePlaceholder()">Add Image</button>
                        </div>
                        
                        <div id="boxEditor" class="box-editor">
                            <h4 id="boxEditorTitle">Text Box Properties</h4>
                            
                            <div class="form-group">
                                <label>CSV Column:</label>
                                <select id="boxColumnSelect">
                                    <option value="">Select CSV column...</option>
                                </select>
                            </div>
                            
                            <div id="textProperties" style="display: none;">
                                <div class="form-group">
                                    <label>CSV Column:</label>
                                    <select id="boxColumnSelect">
                                        <option value="">Select CSV column...</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label>Static Text (if no CSV column selected):</label>
                                    <input type="text" id="boxTextInput" placeholder="Enter static text or leave empty for CSV data">
                                </div>
                                
                                <!-- Font Upload Section -->
                                <div class="form-group">
                                    <label>Upload Custom Font:</label>
                                    <div class="font-upload-area" id="fontUploadArea">
                                        <input type="file" id="fontUploadInput" accept=".ttf,.otf" style="display: none;">
                                        <div class="font-upload-content">
                                            <span>üìÅ</span>
                                            <p>Drop TTF/OTF file here or click to browse</p>
                                        </div>
                                    </div>
                                    <div id="fontUploadStatus" class="font-status"></div>
                                </div>
                                
                                <!-- Google Fonts Section -->
                                <div class="form-group">
                                    <label>Add Google Font:</label>
                                    <div class="google-font-input">
                                        <input type="text" id="fontUrlInput" placeholder="Paste Google Fonts URL">
                                        <button type="button" id="addFontUrlBtn" class="btn btn-secondary">Add</button>
                                    </div>
                                    <div id="fontUrlStatus" class="font-status"></div>
                                </div>
                                
                                <!-- Font Selection -->
                                <div class="form-group">
                                    <label>Font Family:</label>
                                    <select id="boxFontFamily">
                                        <option value="Arial">Arial</option>
                                        <option value="Times New Roman">Times New Roman</option>
                                        <option value="Helvetica">Helvetica</option>
                                        <option value="Georgia">Georgia</option>
                                        <option value="Verdana">Verdana</option>
                                        <option value="Courier New">Courier New</option>
                                    </select>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label>Font Size:</label>
                                        <input type="number" id="boxFontSize" value="16" min="8" max="72">
                                    </div>
                                    <div class="form-group">
                                        <label>Text Color:</label>
                                        <input type="color" id="boxTextColor" value="#000000">
                                    </div>
                                </div>
                                
                                <div class="form-group">
                                    <label>Text Alignment:</label>
                                    <select id="boxTextAlign">
                                        <option value="left">Left</option>
                                        <option value="center" selected>Center</option>
                                        <option value="right">Right</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label>Text Styling:</label>
                                    <div class="style-checkboxes">
                                        <label class="checkbox-item">
                                            <input type="checkbox" id="boxBold">
                                            <span>Bold</span>
                                        </label>
                                        <label class="checkbox-item">
                                            <input type="checkbox" id="boxItalic">
                                            <span>Italic</span>
                                        </label>
                                        <label class="checkbox-item">
                                            <input type="checkbox" id="boxUnderline">
                                            <span>Underline</span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            
                            <div id="imageProperties" style="display: none;">
                                <div class="form-group">
                                    <label>Image Source:</label>
                                    <select id="boxImageSource">
                                        <option value="csv">From CSV column</option>
                                        <option value="static">Static image</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label>Image URL/Path:</label>
                                    <input type="text" id="boxImageUrl" placeholder="Enter image URL or path">
                                </div>
                            </div>
                            
                            <div class="form-row">
                                <div class="form-group">
                                    <label>X Position:</label>
                                    <input type="number" id="boxXPos" step="1">
                                </div>
                                <div class="form-group">
                                    <label>Y Position:</label>
                                    <input type="number" id="boxYPos" step="1">
                                </div>
                            </div>
                            
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Width:</label>
                                    <input type="number" id="boxWidth" step="1" min="20">
                                </div>
                                <div class="form-group">
                                    <label>Height:</label>
                                    <input type="number" id="boxHeight" step="1" min="20">
                                </div>
                            </div>
                            
                            <div class="box-actions">
                                <button class="btn btn-warning" onclick="duplicateSelectedBox()">Duplicate</button>
                                <button class="btn btn-danger" onclick="deleteSelectedBox()">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-header">CSV Data</h2>
                    
                    <!-- Record Navigation -->
                    <div id="recordNavigation" class="record-navigation" style="display: none;">
                        <div class="nav-controls">
                            <button id="prevRecord" class="btn btn-secondary">‚Äπ</button>
                            <span id="recordInfo">Record 1 of 1</span>
                            <button id="nextRecord" class="btn btn-secondary">‚Ä∫</button>
                        </div>
                    </div>
                    
                    <div id="csvPreview" class="csv-preview">
                        <h4>CSV Preview (First 5 rows)</h4>
                        <div id="csvTableContainer"></div>
                        <div id="csvInfo" class="csv-info"></div>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-header">Status</h2>
                    <div class="status-items">
                        <div class="status-item">
                            <span class="status-indicator" id="templateIndicator"></span>
                            <span id="templateStatus">Template: None</span>
                        </div>
                        <div class="status-item">
                            <span class="status-indicator" id="csvIndicator"></span>
                            <span id="csvStatus">CSV: None</span>
                        </div>
                        <div class="status-item">
                            <span class="status-indicator" id="layoutIndicator"></span>
                            <span id="layoutStatus">Layout: None</span>
                        </div>
                    </div>
                    <button class="reset-btn" onclick="resetSession()">Reset Session</button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="content-header">
                <h3>PDF Viewer</h3>
            </div>

            <div class="viewer-container">
                <div id="noPdf" class="no-pdf">
                    <h3>No PDF selected</h3>
                    <p>Choose a PDF file to start viewing</p>
                </div>

                <div id="loadingPdf" class="loading" style="display: none;">
                    <div class="spinner"></div>
                    <p>Loading PDF...</p>
                </div>

                <div id="pdfViewer" class="pdf-viewer" style="display: none;">
                    <div class="pdf-controls">
                        <button class="pdf-control-btn" onclick="resetView()" title="Reset View">‚åÇ</button>
                        <button class="pdf-control-btn" onclick="zoomIn()" title="Zoom In">+</button>
                        <button class="pdf-control-btn" onclick="zoomOut()" title="Zoom Out">‚àí</button>
                        <button class="pdf-control-btn" onclick="togglePDFLock()" title="Toggle PDF Lock" id="pdfLockBtn">üîí</button>
                        <div class="zoom-display" id="zoomDisplay">100%</div>
                    </div>
                    
                                    <div class="pdf-content" id="pdfContent">
                    <canvas id="viewer"></canvas>
                </div>
                </div>
            </div>



            <!-- Editor Properties Sidebar -->
            <div id="editorSidebar" class="editor-sidebar">
                <h4>Object Properties</h4>
                
                <div class="editor-form-group">
                    <label>Bind to CSV Field:</label>
                    <select id="bindField">
                        <option value="">None (Static)</option>
                        <option value="title">Title</option>
                        <option value="subtitle">Subtitle</option>
                        <option value="price">Price</option>
                        <option value="features">Features</option>
                        <option value="image">Image</option>
                    </select>
                </div>

                <div class="editor-form-group">
                    <label>Static Content:</label>
                    <textarea id="staticContent" placeholder="Enter static text content..."></textarea>
                </div>

                <div class="editor-form-group">
                    <label>Position X:</label>
                    <input type="number" id="posX" step="1">
                </div>

                <div class="editor-form-group">
                    <label>Position Y:</label>
                    <input type="number" id="posY" step="1">
                </div>

                <div class="editor-form-group">
                    <label>Width:</label>
                    <input type="number" id="width" step="1">
                </div>

                <div class="editor-form-group">
                    <label>Height:</label>
                    <input type="number" id="height" step="1">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let currentPdf = null;
        let currentFile = null;
        let serverPdfUrl = null;

        // Session state management
        let sessionState = {
            templatePdf: null,
            templatePdfBytes: null,
            csv: null,
            csvRows: [],
            layout: null,
            boxes: [],
            selectedBox: null
        };

        // Enhanced box management system
        let boxCounter = 0;
        let currentBoxId = null;
        
        // Font management system
        let availableFonts = ['Arial', 'Times New Roman', 'Helvetica', 'Georgia', 'Verdana', 'Courier New'];
        let loadedFonts = {};
        let defaultFontFamily = 'Arial';
        
        // CSV data management
        let currentRecord = 0;
        let csvData = null;

        // Initialize status indicators
        function updateStatusIndicators() {
            const templateLoaded = sessionState.templatePdf !== null;
            const csvLoaded = sessionState.csvRows.length > 0;
            const layoutLoaded = sessionState.layout !== null;

            // Update status bar text and indicators
            document.getElementById('templateStatus').textContent = `Template: ${templateLoaded ? 'Loaded' : 'None'}`;
            document.getElementById('csvStatus').textContent = `CSV: ${csvLoaded ? sessionState.csvRows.length + ' rows' : 'None'}`;
            document.getElementById('layoutStatus').textContent = `Layout: ${layoutLoaded ? 'Loaded' : 'None'}`;

            document.getElementById('templateIndicator').classList.toggle('loaded', templateLoaded);
            document.getElementById('csvIndicator').classList.toggle('loaded', csvLoaded);
            document.getElementById('layoutIndicator').classList.toggle('loaded', layoutLoaded);
        }

        // File input handler
        document.getElementById('pdfFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                currentFile = file;
                document.getElementById('fileLabel').textContent = file.name;
                
                // Hide download link
                document.getElementById('downloadLink').style.display = 'none';
                serverPdfUrl = null;

                // Automatically load and preview the PDF
                loadPdf(file);
            }
        });

        async function loadPdf(file) {
            try {
                console.log('Loading PDF file:', file.name);
                
                // Show loading state
                document.getElementById('noPdf').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'none';
                document.getElementById('loadingPdf').style.display = 'block';

                // Read file as ArrayBuffer
                const arrayBuffer = await file.arrayBuffer();

                // Create a separate copy for PDF-lib BEFORE loading with PDF.js
                const templateBytes = new Uint8Array(arrayBuffer).slice();

                // Load PDF document
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                
                // Store PDF info
                currentPdf = pdf;

                // Update session state with the separate copy
                sessionState.templatePdf = pdf;
                sessionState.templatePdfBytes = templateBytes;
                updateStatusIndicators();

                // Enable Generate From Template button
                document.getElementById('generateFromTemplateBtn').disabled = false;

                // Render the page (always page 1 for single-page PDFs)
                await renderPage(1);

                // Initialize simple editor after PDF is loaded
                initEditor();

                // Hide loading and noPdf message, show PDF viewer
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'block';
                
                // Initialize PDF dragging functionality
                initPDFDragging();
                
                // Initialize PDF lock status
                updatePDFLockStatus();

            } catch (error) {
                console.error('Error loading PDF:', error);
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'block';
                document.getElementById('noPdf').innerHTML = `
                    <h3>Error loading PDF</h3>
                    <p>${error.message}</p>
                `;
            }
        }

        async function loadPdfFromUrl(url) {
            try {
                // Fetch PDF from server
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Failed to fetch PDF from server');
                }
                
                const arrayBuffer = await response.arrayBuffer();

                // Load PDF document
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                
                // Store PDF info
                currentPdf = pdf;

                // Update session state
                sessionState.templatePdf = pdf;
                sessionState.templatePdfBytes = arrayBuffer.slice(0); // Create a copy to avoid detachment
                updateStatusIndicators();

                // Render the page (always page 1 for single-page PDFs)
                await renderPage(1);

                // Hide loading and noPdf message, show PDF viewer
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'block';
                
                // Initialize PDF dragging functionality
                initPDFDragging();

            } catch (error) {
                console.error('Error loading PDF from URL:', error);
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'block';
                document.getElementById('noPdf').innerHTML = `
                    <h3>Error loading PDF</h3>
                    <p>${error.message}</p>
                `;
            }
        }

        async function renderPage(pageNumber) {
            if (!currentPdf) return;

            try {
                // Get page
                const page = await currentPdf.getPage(pageNumber);

                // Set up canvas
                const canvas = document.getElementById('viewer');
                const context = canvas.getContext('2d');

                // Calculate scale to fit in viewer
                const viewerWidth = document.querySelector('.viewer-container').clientWidth;
                const viewerHeight = document.querySelector('.viewer-container').clientHeight;

                const viewport = page.getViewport({scale: 1});
                const scaleX = viewerWidth / viewport.width;
                const scaleY = viewerHeight / viewport.height;
                const scale = Math.min(scaleX, scaleY, 1.5); // Max 1.5x zoom

                const scaledViewport = page.getViewport({scale: scale});

                // Set canvas dimensions
                canvas.width = scaledViewport.width;
                canvas.height = scaledViewport.height;

                // Make sure canvas is visible
                canvas.style.display = 'block';

                // Render page
                const renderContext = {
                    canvasContext: context,
                    viewport: scaledViewport
                };

                await page.render(renderContext).promise;

                // Update editor canvas size to match the rendered PDF
                if (editorCanvas) {
                    updateEditorPageSize();
                }

                console.log('PDF rendered successfully:', scaledViewport.width, 'x', scaledViewport.height);

            } catch (error) {
                console.error('Error rendering page:', error);
            }
        }

        // Drag and drop support
        const uploadArea = document.querySelector('.sidebar');
        const fileInput = document.getElementById('pdfFile');

        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.style.backgroundColor = '#e3f2fd';
        });

        uploadArea.addEventListener('dragleave', function(e) {
            e.preventDefault();
            uploadArea.style.backgroundColor = '';
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.style.backgroundColor = '';
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                fileInput.files = files;
                currentFile = files[0];
                document.getElementById('fileLabel').textContent = files[0].name;
                
                // Hide download link
                document.getElementById('downloadLink').style.display = 'none';
                serverPdfUrl = null;

                // Automatically load and preview the PDF
                loadPdf(files[0]);
            }
        });

        // Initialize status indicators on page load
        updateStatusIndicators();
        
        // Initialize font handling
        initializeFontHandling();

        // Layout Editor Variables
        let selectedBox = null;
        let isEditorMode = false;

        // Page size definitions (in points)
        const PAGE_SIZES = {
            'A4': { width: 595, height: 842 },
            'A5': { width: 420, height: 595 },
            'A6': { width: 298, height: 420 }
        };

        // Initialize simple HTML-based editor
        function initEditor() {
            // Create the overlay container for text boxes
            const overlayContainer = document.createElement('div');
            overlayContainer.id = 'overlayContainer';
            overlayContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 10;
            `;
            
            const pdfViewer = document.getElementById('pdfViewer');
            if (pdfViewer) {
                pdfViewer.appendChild(overlayContainer);
                pdfViewer.style.position = 'relative';
            }
        }

        function toggleEditorMode() {
            isEditorMode = !isEditorMode;
            const viewer = document.getElementById('viewer');
            const editorCanvasElement = document.getElementById('editorCanvas');
            
            if (isEditorMode) {
                // Show both PDF and editor canvas
                viewer.style.display = 'block';
                editorCanvasElement.style.display = 'block';
                
                // Disable PDF dragging when in editor mode
                if (pdfViewer) {
                    pdfViewer.style.cursor = 'default';
                }
                
                if (editorCanvas) {
                    editorCanvas.renderAll();
                }
            } else {
                // Hide editor canvas, keep PDF visible
                editorCanvasElement.style.display = 'none';
                viewer.style.display = 'block';
                
                // Re-enable PDF dragging when not in editor mode
                if (pdfViewer) {
                    pdfViewer.style.cursor = 'grab';
                }
            }
        }



        function addText() {
            // Ensure editor is initialized
            if (!document.getElementById('overlayContainer')) {
                initEditor();
            }
            
            // Get PDF viewer dimensions for centering
            const pdfViewer = document.getElementById('pdfViewer');
            if (!pdfViewer || !sessionState.templatePdf) {
                alert('Please upload a PDF template first');
                return;
            }
            
            const rect = pdfViewer.getBoundingClientRect();
            const centerX = (rect.width / 2) - 60;
            const centerY = (rect.height / 2) - 20;
            
            // Create text box element
            const textBox = document.createElement('div');
            textBox.className = 'draggable-text-box';
            textBox.id = 'textBox_' + ++boxCounter;
            textBox.style.cssText = `
                position: absolute;
                left: ${centerX}px;
                top: ${centerY}px;
                width: 120px;
                height: 40px;
                min-width: 80px;
                min-height: 25px;
                background: rgba(255, 255, 255, 0.1);
                border: 2px solid #007bff;
                padding: 5px;
                cursor: move;
                pointer-events: auto;
                z-index: 20;
                font-family: Arial, sans-serif;
                font-size: 16px;
                color: #000;
                text-align: center;
                user-select: none;
                box-sizing: border-box;
                overflow: hidden;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                transition: all 0.1s ease;
            `;
            textBox.textContent = 'Sample Text';
            textBox.contentEditable = false; // Disable direct editing since we use the panel
            
            // Add to overlay container
            const overlayContainer = document.getElementById('overlayContainer');
            overlayContainer.appendChild(textBox);
            
            // Make it draggable
            makeDraggable(textBox);
            
            // Add click handler for selection
            textBox.addEventListener('click', function(e) {
                e.stopPropagation();
                
                // Remove selection from all boxes
                document.querySelectorAll('.draggable-text-box').forEach(box => {
                    box.style.border = '2px solid #007bff';
                });
                
                // Select this box
                textBox.style.border = '2px solid #28a745';
                sessionState.selectedBox = boxData;
                updateBoxEditor();
                updateBoxEditorValues(boxData);
            });
            
            // Add to session state
            const boxData = {
                id: boxCounter,
                element: textBox,
                type: 'text',
                boxType: 'text',
                csvColumn: '',
                staticText: 'Sample Text',
                bold: false,
                italic: false,
                underline: false,
                fontSize: 16,
                fontFamily: defaultFontFamily,
                color: '#000000',
                textAlign: 'center',
                x: centerX,
                y: centerY,
                width: 120,
                height: 40
            };
            
            sessionState.boxes.push(boxData);
            sessionState.selectedBox = boxData;
            currentBoxId = boxCounter;
            
            // Update box editor
            updateBoxEditor();
            updateBoxEditorValues(boxData);
            
            // Select the text box immediately for editing
            textBox.focus();
            textBox.select();
            
            // Update text size to fit the initial box dimensions
            updateTextSize(textBox);
        }

        function addImagePlaceholder() {
            if (!editorCanvas) {
                // Initialize editor canvas if not already done
                initEditorCanvas();
                setTimeout(() => addImagePlaceholder(), 100);
                return;
            }

            // Switch to editor mode
            if (!isEditorMode) {
                toggleEditorMode();
            }

            // Calculate center position for the new image placeholder
            const canvasWidth = editorCanvas.getWidth();
            const canvasHeight = editorCanvas.getHeight();
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            
            const rect = new fabric.Rect({
                left: centerX - 50,
                top: centerY - 50,
                width: 100,
                height: 100,
                fill: '#f0f0f0',
                stroke: '#999',
                strokeWidth: 1,
                originX: 'center',
                originY: 'center'
            });

            const text = new fabric.Text('IMAGE', {
                left: centerX,
                top: centerY,
                fontSize: 12,
                fill: '#666',
                fontFamily: 'Arial',
                textAlign: 'center',
                originX: 'center',
                originY: 'center'
            });

            const group = new fabric.Group([rect, text], {
                left: centerX,
                top: centerY,
                originX: 'center',
                originY: 'center',
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true,
                lockRotation: false,
                lockScalingX: false,
                lockScalingY: false,
                lockMovementX: false,
                lockMovementY: false
            });

            // Add custom properties for our box management system
            group.boxId = ++boxCounter;
            group.boxType = 'image';
            group.csvColumn = '';
            group.imageSource = 'csv';
            group.imageUrl = '';
            
            editorCanvas.add(group);
            editorCanvas.setActiveObject(group);
            
            // Add to session state and select
            sessionState.boxes.push(group);
            sessionState.selectedBox = group;
            currentBoxId = group.boxId;
            
            // Update box editor
            updateBoxEditor();
            updateBoxEditorValues(group);
            
            updateEditorStatus('Image placeholder created - drag it to position and edit properties');
        }

        function duplicateObject() {
            if (!selectedEditorObject || !editorCanvas) return;

            const clone = fabric.util.object.clone(selectedEditorObject);
            clone.set({
                left: selectedEditorObject.left + 20,
                top: selectedEditorObject.top + 20
            });

            editorCanvas.add(clone);
            editorCanvas.setActiveObject(clone);
            updateEditorStatus('Object duplicated');
        }

        function toggleLock() {
            if (!selectedEditorObject) return;

            selectedEditorObject.selectable = !selectedEditorObject.selectable;
            selectedEditorObject.evented = !selectedEditorObject.evented;
            
            const lockBtn = document.getElementById('lockBtn');
            if (selectedEditorObject.selectable) {
                lockBtn.textContent = 'Lock';
                lockBtn.className = 'editor-btn editor-btn-warning';
            } else {
                lockBtn.textContent = 'Unlock';
                lockBtn.className = 'editor-btn editor-btn-success';
            }

            updateEditorStatus(selectedEditorObject.selectable ? 'Object unlocked' : 'Object locked');
        }

        function deleteObject() {
            if (!selectedEditorObject || !editorCanvas) return;

            editorCanvas.remove(selectedEditorObject);
            editorCanvas.discardActiveObject();
            updateEditorStatus('Object deleted');
        }

        function clearCanvas() {
            if (!editorCanvas) return;

            if (confirm('Are you sure you want to clear all objects?')) {
                editorCanvas.clear();
                updateEditorStatus('Canvas cleared');
            }
        }

        function onEditorObjectSelected(e) {
            selectedEditorObject = e.target;
            updateEditorSidebar();
            updateEditorButtonStates(true);
            updateEditorStatus('Object selected');
        }

        function onEditorObjectDeselected() {
            selectedEditorObject = null;
            document.getElementById('editorSidebar').classList.remove('active');
            updateEditorButtonStates(false);
            updateEditorStatus('No object selected');
        }

        function onEditorObjectModified(e) {
            updateEditorSidebar();
            updateEditorStatus('Object modified');
        }

        function onEditorObjectMoving(e) {
            if (gridSize > 0) {
                const obj = e.target;
                obj.set({
                    left: Math.round(obj.left / gridSize) * gridSize,
                    top: Math.round(obj.top / gridSize) * gridSize
                });
            }
        }

        function onEditorObjectScaling(e) {
            if (gridSize > 0) {
                const obj = e.target;
                obj.set({
                    width: Math.round(obj.width / gridSize) * gridSize,
                    height: Math.round(obj.height / gridSize) * gridSize
                });
            }
        }

        function updateEditorSidebar() {
            if (!selectedEditorObject) return;

            document.getElementById('editorSidebar').classList.add('active');

            // Get object metadata
            const meta = selectedEditorObject.meta || {};

            // Update form fields
            document.getElementById('bindField').value = meta.bind || '';
            document.getElementById('staticContent').value = meta.static || '';
            document.getElementById('posX').value = Math.round(selectedEditorObject.left);
            document.getElementById('posY').value = Math.round(selectedEditorObject.top);
            document.getElementById('width').value = Math.round(selectedEditorObject.width || selectedEditorObject.scaleX * 100);
            document.getElementById('height').value = Math.round(selectedEditorObject.height || selectedEditorObject.scaleY * 100);

            // Add event listeners for form changes
            document.getElementById('bindField').onchange = updateEditorObjectMeta;
            document.getElementById('staticContent').oninput = updateEditorObjectMeta;
            document.getElementById('posX').onchange = updateEditorObjectPosition;
            document.getElementById('posY').onchange = updateEditorObjectPosition;
            document.getElementById('width').onchange = updateEditorObjectSize;
            document.getElementById('height').onchange = updateEditorObjectSize;
        }

        function updateEditorObjectMeta() {
            if (!selectedEditorObject) return;

            selectedEditorObject.meta = {
                bind: document.getElementById('bindField').value,
                static: document.getElementById('staticContent').value
            };

            // Update text content if it's a text object
            if (selectedEditorObject.type === 'text' && document.getElementById('staticContent').value) {
                selectedEditorObject.set('text', document.getElementById('staticContent').value);
            }

            editorCanvas.renderAll();
        }

        function updateEditorObjectPosition() {
            if (!selectedEditorObject) return;

            selectedEditorObject.set({
                left: parseInt(document.getElementById('posX').value),
                top: parseInt(document.getElementById('posY').value)
            });

            editorCanvas.renderAll();
        }

        function updateEditorObjectSize() {
            if (!selectedEditorObject) return;

            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);

            if (selectedEditorObject.type === 'text') {
                selectedEditorObject.set('fontSize', Math.min(width, height) / 2);
            } else {
                selectedEditorObject.set({
                    width: width,
                    height: height
                });
            }

            editorCanvas.renderAll();
        }

        function updateEditorButtonStates(enabled) {
            document.getElementById('duplicateBtn').disabled = !enabled;
            document.getElementById('lockBtn').disabled = !enabled;
            document.getElementById('deleteBtn').disabled = !enabled;
        }

        // Enhanced Box Management Functions
        function updateBoxEditor() {
            const boxEditor = document.getElementById('boxEditor');
            if (sessionState.selectedBox) {
                boxEditor.classList.add('active');
            } else {
                boxEditor.classList.remove('active');
            }
        }

        function updateBoxEditorValues(box) {
            if (!box) return;

            // Update CSV column dropdown
            const columnSelect = document.getElementById('boxColumnSelect');
            columnSelect.innerHTML = '<option value="">Select CSV column...</option>';
            
            if (csvData && csvData.length > 0) {
                const columns = Object.keys(csvData[0]);
                columns.forEach(column => {
                    const option = document.createElement('option');
                    option.value = column;
                    option.textContent = column;
                    option.selected = column === box.csvColumn;
                    columnSelect.appendChild(option);
                });
            }

            // Show/hide appropriate property sections
            const textProps = document.getElementById('textProperties');
            const imageProps = document.getElementById('imageProperties');
            
            if (box.boxType === 'text') {
                textProps.style.display = 'block';
                imageProps.style.display = 'none';
                
                // Update text properties
                document.getElementById('boxTextInput').value = box.staticText || '';
                document.getElementById('boxFontSize').value = box.fontSize || 16;
                document.getElementById('boxFontFamily').value = box.fontFamily || 'Arial';
                document.getElementById('boxTextColor').value = box.fill || '#000000';
                document.getElementById('boxBold').checked = box.bold || false;
                document.getElementById('boxItalic').checked = box.italic || false;
                document.getElementById('boxUnderline').checked = box.underline || false;
                document.getElementById('boxTextAlign').value = box.textAlign || 'center';
                
                // Update title
                document.getElementById('boxEditorTitle').textContent = 'Text Box Properties';
            } else if (box.boxType === 'image') {
                textProps.style.display = 'none';
                imageProps.style.display = 'block';
                
                // Update image properties
                document.getElementById('boxImageSource').value = box.imageSource || 'csv';
                document.getElementById('boxImageUrl').value = box.imageUrl || '';
                
                // Update title
                document.getElementById('boxEditorTitle').textContent = 'Image Box Properties';
            }

            // Update position and size
            document.getElementById('boxXPos').value = Math.round(box.left || 0);
            document.getElementById('boxYPos').value = Math.round(box.top || 0);
            document.getElementById('boxWidth').value = Math.round(box.width || 100);
            document.getElementById('boxHeight').value = Math.round(box.height || 100);

            // Add event listeners
            addBoxEditorEventListeners(box);
        }

        function addBoxEditorEventListeners(box) {
            // CSV Column change
            document.getElementById('boxColumnSelect').onchange = function() {
                box.csvColumn = this.value;
                updateTextBoxContent(box);
                updateEditorStatus(`Box bound to CSV column: ${this.value || 'None'}`);
            };

            // Text properties
            if (box.boxType === 'text') {
                document.getElementById('boxTextInput').oninput = function() {
                    box.staticText = this.value;
                    updateTextBoxContent(box);
                };

                document.getElementById('boxFontSize').oninput = function() {
                    const size = parseInt(this.value);
                    box.fontSize = size;
                    updateTextBoxFont(box);
                };

                document.getElementById('boxFontFamily').onchange = function() {
                    const family = this.value;
                    box.fontFamily = family;
                    updateTextBoxFont(box);
                };

                document.getElementById('boxTextColor').oninput = function() {
                    const color = this.value;
                    box.color = color;
                    updateTextBoxFont(box);
                };

                document.getElementById('boxBold').onchange = function() {
                    box.bold = this.checked;
                    updateTextBoxFont(box);
                };

                document.getElementById('boxItalic').onchange = function() {
                    box.italic = this.checked;
                    updateTextBoxFont(box);
                };

                document.getElementById('boxUnderline').onchange = function() {
                    box.underline = this.checked;
                    updateTextBoxFont(box);
                };

                document.getElementById('boxTextAlign').onchange = function() {
                    const align = this.value;
                    box.textAlign = align;
                    updateTextBoxFont(box);
                };
            }

            // Image properties
            if (box.boxType === 'image') {
                document.getElementById('boxImageSource').onchange = function() {
                    box.imageSource = this.value;
                };

                document.getElementById('boxImageUrl').oninput = function() {
                    box.imageUrl = this.value;
                };
            }

            // Position and size
            document.getElementById('boxXPos').onchange = function() {
                const x = parseInt(this.value);
                box.set('left', x);
                editorCanvas.renderAll();
            };

            document.getElementById('boxYPos').onchange = function() {
                const y = parseInt(this.value);
                box.set('top', y);
                editorCanvas.renderAll();
            };

            document.getElementById('boxWidth').onchange = function() {
                const width = parseInt(this.value);
                box.set('width', width);
                editorCanvas.renderAll();
            };

            document.getElementById('boxHeight').onchange = function() {
                const height = parseInt(this.value);
                box.set('height', height);
                editorCanvas.renderAll();
            };
        }

        function duplicateSelectedBox() {
            if (!sessionState.selectedBox || !editorCanvas) return;

            const original = sessionState.selectedBox;
            const clone = fabric.util.object.clone(original);
            
            // Offset the clone
            clone.set({
                left: original.left + 20,
                top: original.top + 20,
                boxId: ++boxCounter
            });

            // Copy custom properties
            clone.boxType = original.boxType;
            clone.csvColumn = original.csvColumn;
            clone.staticText = original.staticText;
            clone.bold = original.bold;
            clone.italic = original.italic;
            clone.underline = original.underline;
            clone.imageSource = original.imageSource;
            clone.imageUrl = original.imageUrl;

            editorCanvas.add(clone);
            sessionState.boxes.push(clone);
            
            // Select the new clone
            sessionState.selectedBox = clone;
            currentBoxId = clone.boxId;
            updateBoxEditorValues(clone);
            
            updateEditorStatus('Box duplicated');
        }

        function deleteSelectedBox() {
            if (!sessionState.selectedBox || !editorCanvas) return;

            const boxId = sessionState.selectedBox.boxId;
            
            // Remove from canvas
            editorCanvas.remove(sessionState.selectedBox);
            
            // Remove from session state
            sessionState.boxes = sessionState.boxes.filter(box => box.boxId !== boxId);
            
            // Clear selection
            sessionState.selectedBox = null;
            currentBoxId = null;
            
            // Hide box editor
            updateBoxEditor();
            
            // Reset PDF view
            if (pdfViewer) {
                pdfViewer.style.display = 'none';
            }
            resetView();
            
            updateEditorStatus('Box deleted');
        }

        // Simple drag functionality for text boxes
        function makeDraggable(element) {
            let isDragging = false;
            let isResizing = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;
            let initialWidth;
            let initialHeight;
            let resizeHandle = '';

            // Add resize handles
            addResizeHandles(element);

            // Use mousedown on the element itself
            element.addEventListener('mousedown', dragStart);
            
            // Use document-level events for better drag handling
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            function dragStart(e) {
                // Prevent event from bubbling to PDF viewer
                e.stopPropagation();
                
                // Check if clicking on resize handle
                if (e.target.classList.contains('resize-handle')) {
                    isResizing = true;
                    isDragging = false;
                    resizeHandle = e.target.dataset.handle;
                    initialWidth = element.offsetWidth;
                    initialHeight = element.offsetHeight;
                    initialX = e.clientX;
                    initialY = e.clientY;
                    element.style.cursor = 'nwse-resize';
                    element.classList.add('resizing');
                    return;
                }

                // Normal dragging
                if (e.target === element) {
                    isDragging = true;
                    isResizing = false;
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    element.style.cursor = 'grabbing';
                    element.style.zIndex = '30';
                }
            }

            function drag(e) {
                if (isResizing) {
                    e.preventDefault();
                    e.stopPropagation();
                    const deltaX = e.clientX - initialX;
                    const deltaY = e.clientY - initialY;
                    
                    // Only resize, don't move the box position
                    if (resizeHandle.includes('e')) { // right
                        element.style.width = Math.max(80, initialWidth + deltaX) + 'px';
                    }
                    if (resizeHandle.includes('w')) { // right edge stays fixed, left edge moves
                        const newWidth = Math.max(80, initialWidth - deltaX);
                        element.style.width = newWidth + 'px';
                        element.style.left = (parseInt(element.style.left) + (initialWidth - newWidth)) + 'px';
                    }
                    if (resizeHandle.includes('s')) { // bottom
                        element.style.height = Math.max(25, initialHeight + deltaY) + 'px';
                    }
                    if (resizeHandle.includes('n')) { // bottom edge stays fixed, top edge moves
                        const newHeight = Math.max(25, initialHeight - deltaY);
                        element.style.height = newHeight + 'px';
                        element.style.top = (parseInt(element.style.top) + (initialHeight - newHeight)) + 'px';
                    }
                    
                    // Update font size based on box size
                    updateTextSize(element);
                } else if (isDragging) {
                    e.preventDefault();
                    e.stopPropagation();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;

                    element.style.transform = `translate(${currentX}px, ${currentY}px)`;
                }
            }

            function dragEnd(e) {
                // Prevent event from bubbling to PDF viewer
                e.stopPropagation();
                
                if (isResizing) {
                    isResizing = false;
                    element.style.cursor = 'move';
                    element.style.zIndex = '20';
                    resizeHandle = '';
                    element.classList.remove('resizing');
                } else if (isDragging) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                    element.style.cursor = 'move';
                    element.style.zIndex = '20';
                }
            }
        }

        function addResizeHandles(element) {
            const handles = [
                { position: 'nw', cursor: 'nw-resize' },
                { position: 'n', cursor: 'n-resize' },
                { position: 'ne', cursor: 'ne-resize' },
                { position: 'e', cursor: 'e-resize' },
                { position: 'se', cursor: 'se-resize' },
                { position: 's', cursor: 's-resize' },
                { position: 'sw', cursor: 'sw-resize' },
                { position: 'w', cursor: 'w-resize' }
            ];

            handles.forEach(handle => {
                const handleElement = document.createElement('div');
                handleElement.className = 'resize-handle';
                handleElement.dataset.handle = handle.position;
                handleElement.style.cssText = `
                    position: absolute;
                    width: 12px;
                    height: 12px;
                    background: #ff6b35;
                    border: 2px solid white;
                    border-radius: 2px;
                    cursor: ${handle.cursor};
                    pointer-events: auto;
                    z-index: 25;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                `;

                // Position the handle
                switch (handle.position) {
                    case 'nw': handleElement.style.top = '-6px'; handleElement.style.left = '-6px'; break;
                    case 'n': handleElement.style.top = '-6px'; handleElement.style.left = '50%'; handleElement.style.transform = 'translateX(-50%)'; break;
                    case 'ne': handleElement.style.top = '-6px'; handleElement.style.right = '-6px'; break;
                    case 'e': handleElement.style.top = '50%'; handleElement.style.right = '-6px'; handleElement.style.transform = 'translateY(-50%)'; break;
                    case 'se': handleElement.style.bottom = '-6px'; handleElement.style.right = '-6px'; break;
                    case 's': handleElement.style.bottom = '-6px'; handleElement.style.left = '50%'; handleElement.style.transform = 'translateX(-50%)'; break;
                    case 'sw': handleElement.style.bottom = '-6px'; handleElement.style.left = '-6px'; break;
                    case 'w': handleElement.style.top = '50%'; handleElement.style.left = '-6px'; handleElement.style.transform = 'translateY(-50%)'; break;
                }

                element.appendChild(handleElement);
            });
        }

        function updateTextSize(element) {
            if (element.classList.contains('draggable-text-box')) {
                const width = element.offsetWidth;
                const height = element.offsetHeight;
                
                // Only adjust padding to maintain text centering, don't resize font
                const padding = Math.max(5, Math.min(width, height) / 10);
                element.style.padding = padding + 'px';
            }
        }

        // PDF Dragging and Zooming Functionality
        let isDragging = false;
        let lastMousePos = { x: 0, y: 0 };
        let currentTransform = { x: 0, y: 0, scale: 1 };
        let pdfViewer = null;
        let pdfContent = null;
        let pdfLocked = true; // PDF is locked by default when uploaded

        function initPDFDragging() {
            pdfViewer = document.getElementById('pdfViewer');
            pdfContent = document.getElementById('pdfContent');
            
            if (!pdfViewer || !pdfContent) return;

            // Mouse events for dragging
            pdfViewer.addEventListener('mousedown', startDragging);
            pdfViewer.addEventListener('mousemove', drag);
            pdfViewer.addEventListener('mouseup', stopDragging);
            pdfViewer.addEventListener('mouseleave', stopDragging);
            
            // Touch events for mobile
            pdfViewer.addEventListener('touchstart', startDraggingTouch);
            pdfViewer.addEventListener('touchmove', dragTouch);
            pdfViewer.addEventListener('touchend', stopDragging);
            
            // Wheel event for zooming
            pdfViewer.addEventListener('wheel', handleWheel);
            
            // Prevent context menu
            pdfViewer.addEventListener('contextmenu', e => e.preventDefault());
        }

        function startDragging(e) {
            // Don't start dragging if clicking on controls, if we're in editor mode, or if PDF is locked
            if (e.target.closest('.pdf-controls') || isEditorMode || pdfLocked) return;
            
            isDragging = true;
            lastMousePos = { x: e.clientX, y: e.clientY };
            pdfViewer.classList.add('dragging');
            e.preventDefault();
        }

        function startDraggingTouch(e) {
            if (e.target.closest('.pdf-controls') || isEditorMode || pdfLocked) return;
            
            isDragging = true;
            lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            pdfViewer.classList.add('dragging');
            e.preventDefault();
        }

        function drag(e) {
            if (!isDragging) return;
            
            const currentPos = { x: e.clientX, y: e.clientY };
            const deltaX = currentPos.x - lastMousePos.x;
            const deltaY = currentPos.y - lastMousePos.y;
            
            currentTransform.x += deltaX;
            currentTransform.y += deltaY;
            
            updatePDFTransform();
            lastMousePos = currentPos;
            e.preventDefault();
        }

        function dragTouch(e) {
            if (!isDragging) return;
            
            const currentPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            const deltaX = currentPos.x - lastMousePos.x;
            const deltaY = currentPos.y - lastMousePos.y;
            
            currentTransform.x += deltaX;
            currentTransform.y += deltaY;
            
            updatePDFTransform();
            lastMousePos = currentPos;
            e.preventDefault();
        }

        function stopDragging() {
            isDragging = false;
            pdfViewer.classList.remove('dragging');
        }

        function handleWheel(e) {
            if (isEditorMode || pdfLocked) return; // Don't zoom when editing or if PDF is locked
            
            e.preventDefault();
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(5, currentTransform.scale * zoomFactor));
            
            // Zoom towards mouse position
            const rect = pdfContent.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const scaleChange = newScale / currentTransform.scale;
            currentTransform.x = mouseX - (mouseX - currentTransform.x) * scaleChange;
            currentTransform.y = mouseY - (mouseY - currentTransform.y) * scaleChange;
            currentTransform.scale = newScale;
            
            updatePDFTransform();
        }

        function updatePDFTransform() {
            if (!pdfContent) return;
            
            pdfContent.style.transform = `translate(${currentTransform.x}px, ${currentTransform.y}px) scale(${currentTransform.scale})`;
            
            // Update zoom display
            const zoomDisplay = document.getElementById('zoomDisplay');
            if (zoomDisplay) {
                zoomDisplay.textContent = Math.round(currentTransform.scale * 100) + '%';
            }
            
            // Update editor canvas if it exists
            if (editorCanvas) {
                editorCanvas.setZoom(currentTransform.scale);
                editorCanvas.renderAll();
            }
        }

        function togglePDFLock() {
            pdfLocked = !pdfLocked;
            
            // Update cursor style
            if (pdfViewer) {
                pdfViewer.style.cursor = pdfLocked ? 'default' : 'grab';
            }
            
            // Update lock status display
            updatePDFLockStatus();
        }

        function updatePDFLockStatus() {
            // Create or update lock status indicator
            let lockIndicator = document.getElementById('pdfLockIndicator');
            if (!lockIndicator) {
                lockIndicator = document.createElement('div');
                lockIndicator.id = 'pdfLockIndicator';
                lockIndicator.style.cssText = `
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    background: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 4px 8px;
                    border-radius: 3px;
                    font-size: 10px;
                    z-index: 100;
                `;
                document.querySelector('.pdf-viewer').appendChild(lockIndicator);
            }
            
            lockIndicator.textContent = pdfLocked ? 'PDF Locked' : 'PDF Unlocked';
            lockIndicator.style.background = pdfLocked ? 'rgba(220, 53, 69, 0.8)' : 'rgba(40, 167, 69, 0.8)';
            
            // Update lock button
            const lockBtn = document.getElementById('pdfLockBtn');
            if (lockBtn) {
                lockBtn.textContent = pdfLocked ? 'üîí' : 'üîì';
                lockBtn.title = pdfLocked ? 'Unlock PDF' : 'Lock PDF';
            }
        }

        function resetView() {
            currentTransform = { x: 0, y: 0, scale: 1 };
            updatePDFTransform();
        }

        function zoomIn() {
            const newScale = Math.min(5, currentTransform.scale * 1.2);
            currentTransform.scale = newScale;
            updatePDFTransform();
        }

        function zoomOut() {
            const newScale = Math.max(0.1, currentTransform.scale / 1.2);
            currentTransform.scale = newScale;
            updatePDFTransform();
        }

        function updateEditorStatus(message) {
            // Create status element if it doesn't exist
            let statusElement = document.getElementById('editorStatus');
            if (!statusElement) {
                statusElement = document.createElement('div');
                statusElement.id = 'editorStatus';
                statusElement.className = 'editor-status';
                document.querySelector('.viewer-container').appendChild(statusElement);
            }
            statusElement.textContent = message;
        }

        function saveLayout() {
            if (!editorCanvas) return;

            const layout = {
                page: {
                    size: 'A4',
                    orient: 'portrait'
                },
                objects: []
            };

            // Collect all objects
            editorCanvas.getObjects().forEach(obj => {
                const objectData = {
                    type: obj.type,
                    left: Math.round(obj.left),
                    top: Math.round(obj.top),
                    width: Math.round(obj.width || obj.scaleX * 100),
                    height: Math.round(obj.height || obj.scaleY * 100),
                    meta: obj.meta || {}
                };

                // Add type-specific properties
                if (obj.type === 'text') {
                    objectData.text = obj.text;
                    objectData.fontSize = obj.fontSize;
                    objectData.fontFamily = obj.fontFamily;
                    objectData.fill = obj.fill;
                } else if (obj.type === 'group') {
                    objectData.groupType = 'imagePlaceholder';
                }

                layout.objects.push(objectData);
            });

            // Create and download JSON file
            const jsonString = JSON.stringify(layout, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `layout-A4-portrait-${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            
            updateEditorStatus('Layout saved as JSON');
        }

        // Generate Sample PDF function
        async function generateSamplePDF() {
            try {
                // Create a new PDF document
                const pdfDoc = await PDFLib.PDFDocument.create();
                
                // Add a page
                const page = pdfDoc.addPage([595, 842]); // A4 size
                
                // Get the current ISO timestamp
                const timestamp = new Date().toISOString();
                
                // Add text to the page
                page.drawText(`Generated at ${timestamp}`, {
                    x: 50,
                    y: 750,
                    size: 20,
                    color: PDFLib.rgb(0, 0, 0)
                });
                
                // Add some sample content
                page.drawText('This is a sample PDF generated by PDF-lib', {
                    x: 50,
                    y: 700,
                    size: 14,
                    color: PDFLib.rgb(0.2, 0.2, 0.2)
                });
                
                page.drawText('You can use this as a template for testing', {
                    x: 50,
                    y: 670,
                    size: 12,
                    color: PDFLib.rgb(0.4, 0.4, 0.4)
                });
                
                // Save the PDF as bytes
                const pdfBytes = await pdfDoc.save();
                
                // Create a blob and download link
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                
                // Create and trigger download
                const link = document.createElement('a');
                link.href = url;
                link.download = `sample-${Date.now()}.pdf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the URL
                URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error generating sample PDF:', error);
                alert('Error generating sample PDF: ' + error.message);
            }
        }

        // Generate From Template function
        async function generateFromTemplate() {
            try {
                if (!sessionState.templatePdfBytes) {
                    alert('Please select a PDF template first');
                    return;
                }

                // Load the template PDF using the Uint8Array copy
                const pdfDoc = await PDFLib.PDFDocument.load(sessionState.templatePdfBytes);
                
                // Embed the Helvetica Bold font
                const helveticaBoldFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);
                
                // Get the first page
                const pages = pdfDoc.getPages();
                if (pages.length === 0) {
                    throw new Error('Template PDF has no pages');
                }
                
                const page = pages[0];
                
                // Get current timestamp for demo data
                const timestamp = new Date().toISOString();
                const dateStr = new Date().toLocaleDateString();
                
                // Add text overlay at fixed positions
                page.drawText('TICKET #12345', {
                    x: 100,
                    y: 700,
                    size: 16,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0, 0, 0)
                });
                
                page.drawText(`Date: ${dateStr}`, {
                    x: 100,
                    y: 650,
                    size: 12,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0.2, 0.2, 0.2)
                });
                
                page.drawText(`Generated: ${timestamp}`, {
                    x: 100,
                    y: 620,
                    size: 10,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0.4, 0.4, 0.4)
                });
                
                // Add some sample fields
                page.drawText('Customer: John Doe', {
                    x: 100,
                    y: 580,
                    size: 12,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0, 0, 0)
                });
                
                page.drawText('Amount: $99.99', {
                    x: 100,
                    y: 550,
                    size: 14,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0.8, 0, 0)
                });
                
                page.drawText('Status: PAID', {
                    x: 100,
                    y: 520,
                    size: 12,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0, 0.6, 0)
                });
                
                // Save the modified PDF
                const pdfBytes = await pdfDoc.save();
                
                // Create a blob and download link
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                
                // Create and trigger download
                const link = document.createElement('a');
                link.href = url;
                link.download = `template-generated-${Date.now()}.pdf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the URL
                URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error generating from template:', error);
                alert('Error generating from template: ' + error.message);
            }
        }

        // CSV file input handler
        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                parseCSVFile(file);
            }
        });

        function parseCSVFile(file) {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        console.error('CSV parsing errors:', results.errors);
                        alert('Error parsing CSV file. Please check the file format.');
                        return;
                    }

                    // Store CSV data in session state and global variable
                    sessionState.csv = file;
                    sessionState.csvRows = results.data;
                    csvData = results.data;
                    currentRecord = 0;
                    
                    // Update status indicators
                    updateStatusIndicators();
                    
                    // Display preview
                    displayCSVPreview(results.data);
                    
                    // Show record navigation
                    showRecordNavigation();
                    
                    // Update file label
                    document.getElementById('csvLabel').textContent = file.name;
                    
                    // Update box editor if a box is selected
                    if (sessionState.selectedBox) {
                        updateBoxEditorValues(sessionState.selectedBox);
                    }
                    
                    // Update all text boxes with CSV data
                    updateAllTextBoxesWithCSVData();
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    alert('Error reading CSV file: ' + error.message);
                }
            });
        }

        function displayCSVPreview(data) {
            if (!data || data.length === 0) {
                document.getElementById('csvPreview').style.display = 'none';
                return;
            }

            const container = document.getElementById('csvTableContainer');
            const headers = Object.keys(data[0]);
            const previewRows = data.slice(0, 5); // First 5 rows

            // Create table HTML
            let tableHTML = '<table class="csv-table"><thead><tr>';
            
            // Add headers
            headers.forEach(header => {
                tableHTML += `<th>${header}</th>`;
            });
            tableHTML += '</tr></thead><tbody>';
            
            // Add data rows
            previewRows.forEach(row => {
                tableHTML += '<tr>';
                headers.forEach(header => {
                    const value = row[header] || '';
                    tableHTML += `<td>${value}</td>`;
                });
                tableHTML += '</tr>';
            });
            
            tableHTML += '</tbody></table>';
            
            container.innerHTML = tableHTML;
            
            // Update info text
            const totalRows = data.length;
            const shownRows = Math.min(5, totalRows);
            document.getElementById('csvInfo').textContent = 
                `Showing ${shownRows} of ${totalRows} rows. Headers: ${headers.join(', ')}`;
            
            // Show preview
            document.getElementById('csvPreview').style.display = 'block';
        }

        function toggleCSVPreview() {
            const csvPreview = document.getElementById('csvPreview');
            const csvToggle = document.querySelector('.csv-toggle');
            csvPreview.classList.toggle('expanded');
            csvToggle.textContent = csvPreview.classList.contains('expanded') ? 'Hide CSV' : 'CSV Preview';
        }

        function resetSession() {
            // Clear session state
            sessionState = {
                templatePdf: null,
                templatePdfBytes: null,
                csv: null,
                csvRows: [],
                layout: null,
                boxes: [],
                selectedBox: null
            };
            
            // Reset box counter
            boxCounter = 0;
            currentBoxId = null;
            
            // Clear editor canvas
            if (editorCanvas) {
                editorCanvas.clear();
            }
            
            // Hide box editor
            updateBoxEditor();

            // Clear current variables
            currentPdf = null;
            currentFile = null;
            serverPdfUrl = null;

            // Reset UI
            document.getElementById('fileLabel').textContent = 'Click to select PDF file';
            document.getElementById('downloadLink').style.display = 'none';
            document.getElementById('noPdf').style.display = 'block';
            document.getElementById('noPdf').innerHTML = `
                <h3>No PDF selected</h3>
                <p>Choose a PDF file to start viewing</p>
            `;
            document.getElementById('loadingPdf').style.display = 'none';
            document.getElementById('viewer').style.display = 'none';

            // Clear file inputs
            document.getElementById('pdfFile').value = '';
            document.getElementById('csvFile').value = '';
            document.getElementById('csvLabel').textContent = 'Click to select CSV file';
            document.getElementById('csvPreview').style.display = 'none';

            // Disable Generate From Template button
            document.getElementById('generateFromTemplateBtn').disabled = true;

            // Update status indicators
            updateStatusIndicators();

            // Revoke any ObjectURLs if they exist
            if (serverPdfUrl && serverPdfUrl.startsWith('blob:')) {
                URL.revokeObjectURL(serverPdfUrl);
            }
        }

        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('collapsed');
        }

        // Font Management Functions
        function initializeFontHandling() {
            const fontUploadArea = document.getElementById('fontUploadArea');
            const fontUploadInput = document.getElementById('fontUploadInput');
            const addFontUrlBtn = document.getElementById('addFontUrlBtn');
            const fontUrlInput = document.getElementById('fontUrlInput');

            if (fontUploadArea && fontUploadInput) {
                fontUploadArea.addEventListener('click', () => fontUploadInput.click());
                fontUploadArea.addEventListener('dragover', e => {
                    e.preventDefault();
                    fontUploadArea.classList.add('dragover');
                });
                fontUploadArea.addEventListener('dragleave', e => {
                    e.preventDefault();
                    fontUploadArea.classList.remove('dragover');
                });
                fontUploadArea.addEventListener('drop', e => {
                    e.preventDefault();
                    fontUploadArea.classList.remove('dragover');
                    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                        handleFontUpload(e.dataTransfer.files[0]);
                    }
                });
                fontUploadInput.addEventListener('change', e => {
                    if (fontUploadInput.files && fontUploadInput.files[0]) {
                        handleFontUpload(fontUploadInput.files[0]);
                    }
                });
            }

            if (addFontUrlBtn && fontUrlInput) {
                addFontUrlBtn.addEventListener('click', handleGoogleFontUrl);
            }
        }

        function handleFontUpload(file) {
            const status = document.getElementById('fontUploadStatus');
            
            if (!file.name.match(/\.(ttf|otf)$/i)) {
                status.textContent = 'Only .ttf and .otf files are allowed.';
                status.className = 'font-status error';
                return;
            }
            
            status.textContent = 'Processing font...';
            status.className = 'font-status';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const base64 = e.target.result.split(',')[1];
                    const fontName = file.name.replace(/\.(ttf|otf)$/i, '');
                    const fileExtension = file.name.match(/\.(ttf|otf)$/i)[1].toLowerCase();
                    const format = fileExtension === 'ttf' ? 'truetype' : 'opentype';
                    
                    // Remove existing font-face if it exists
                    const existingStyle = document.getElementById(`font-face-${fontName}`);
                    if (existingStyle) {
                        existingStyle.remove();
                    }
                    
                    // Create @font-face rule with data URL
                    const style = document.createElement('style');
                    style.id = `font-face-${fontName}`;
                    style.textContent = `
                        @font-face {
                            font-family: '${fontName}';
                            src: url(data:font/${fileExtension};base64,${base64}) format('${format}');
                            font-display: swap;
                        }
                    `;
                    document.head.appendChild(style);
                    
                    // Add to available fonts if not already present
                    if (!availableFonts.includes(fontName)) {
                        availableFonts.push(fontName);
                        updateFontDropdown();
                    }
                    
                    // Set as default font for new text boxes
                    defaultFontFamily = fontName;
                    
                    // Update current text box if selected
                    if (sessionState.selectedBox && sessionState.selectedBox.type === 'text') {
                        sessionState.selectedBox.fontFamily = fontName;
                        updateTextBoxFont(sessionState.selectedBox);
                        // Update the dropdown to show the new font
                        document.getElementById('boxFontFamily').value = fontName;
                    }
                    
                    status.textContent = `Font "${fontName}" loaded successfully!`;
                    status.className = 'font-status success';
                    
                } catch (error) {
                    console.error('Error processing font:', error);
                    status.textContent = 'Error processing font file.';
                    status.className = 'font-status error';
                }
            };
            
            reader.onerror = function() {
                status.textContent = 'Error reading font file.';
                status.className = 'font-status error';
            };
            
            reader.readAsDataURL(file);
        }

        async function handleGoogleFontUrl() {
            const urlInput = document.getElementById('fontUrlInput');
            const status = document.getElementById('fontUrlStatus');
            const url = urlInput.value.trim();
            
            if (!url) {
                status.textContent = 'Please paste a Google Fonts URL.';
                status.className = 'font-status error';
                return;
            }
            
            if (url.includes('fonts.google.com/share')) {
                status.textContent = 'This is a share link. Please use the "Use on the web" link from Google Fonts.';
                status.className = 'font-status error';
                return;
            }
            
            status.textContent = 'Adding font...';
            status.className = 'font-status';
            
            if (url.startsWith('http') && url.includes('fonts.googleapis.com')) {
                let fontName = await getFontFamilyFromGoogleFontsUrl(url);
                if (!fontName) {
                    status.textContent = 'Could not determine font name. Please check the URL.';
                    status.className = 'font-status error';
                    return;
                }
                
                if (!document.querySelector(`link[href="${url}"]`)) {
                    const link = document.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = url;
                    document.head.appendChild(link);
                }
                
                if (!availableFonts.includes(fontName)) {
                    availableFonts.push(fontName);
                    updateFontDropdown();
                }
                
                // Update current text box if selected
                if (sessionState.selectedBox && sessionState.selectedBox.type === 'text') {
                    sessionState.selectedBox.fontFamily = fontName;
                    updateTextBoxFont(sessionState.selectedBox);
                    // Update the dropdown to show the new font
                    document.getElementById('boxFontFamily').value = fontName;
                }
                
                status.textContent = `Font "${fontName}" added successfully!`;
                status.className = 'font-status success';
                urlInput.value = '';
                
            } else {
                status.textContent = 'Please enter a valid Google Fonts URL.';
                status.className = 'font-status error';
            }
        }

        async function getFontFamilyFromGoogleFontsUrl(url) {
            try {
                const res = await fetch(url);
                const css = await res.text();
                const match = css.match(/font-family:\s*'([^']+)'/);
                if (match) {
                    return match[1];
                }
            } catch (e) {
                console.warn('Could not fetch Google Fonts CSS:', e);
            }
            
            // Fallback: try to parse from URL
            const urlMatch = url.match(/family=([^:&]+)/);
            if (urlMatch) {
                return decodeURIComponent(urlMatch[1]).replace(/\+/g, ' ').split(':')[0];
            }
            return '';
        }

        function updateFontDropdown() {
            const fontSelect = document.getElementById('boxFontFamily');
            if (!fontSelect) return;
            
            // Store current selection
            const currentValue = fontSelect.value;
            
            // Clear and rebuild options
            fontSelect.innerHTML = '';
            availableFonts.forEach(font => {
                const option = document.createElement('option');
                option.value = font;
                option.textContent = font;
                option.selected = font === currentValue;
                fontSelect.appendChild(option);
            });
        }

        function updateTextBoxFont(box) {
            if (!box || box.type !== 'text') return;
            
            const element = box.element;
            if (element) {
                element.style.fontFamily = `'${box.fontFamily}', Arial, sans-serif`;
                element.style.fontSize = (box.fontSize || 16) + 'px';
                element.style.color = box.color || '#000000';
                element.style.fontWeight = box.bold ? 'bold' : 'normal';
                element.style.fontStyle = box.italic ? 'italic' : 'normal';
                element.style.textDecoration = box.underline ? 'underline' : 'none';
                
                // Set text alignment and flex properties for consistent positioning
                element.style.textAlign = box.textAlign || 'center';
                element.style.justifyContent = box.textAlign === 'left' ? 'flex-start' : 
                                             box.textAlign === 'right' ? 'flex-end' : 'center';
                
                // Don't auto-resize - let user manually resize to reveal hidden text
                // This keeps text position consistent regardless of content length
            }
        }

        // CSV Data Binding Functions
        function showRecordNavigation() {
            const nav = document.getElementById('recordNavigation');
            if (csvData && csvData.length > 0) {
                nav.style.display = 'block';
                updateRecordInfo();
                
                // Add event listeners
                document.getElementById('prevRecord').onclick = () => {
                    if (currentRecord > 0) {
                        currentRecord--;
                        updateRecordInfo();
                        updateAllTextBoxesWithCSVData();
                    }
                };
                
                document.getElementById('nextRecord').onclick = () => {
                    if (currentRecord < csvData.length - 1) {
                        currentRecord++;
                        updateRecordInfo();
                        updateAllTextBoxesWithCSVData();
                    }
                };
            } else {
                nav.style.display = 'none';
            }
        }

        function updateRecordInfo() {
            const recordInfo = document.getElementById('recordInfo');
            if (csvData && csvData.length > 0) {
                recordInfo.textContent = `Record ${currentRecord + 1} of ${csvData.length}`;
            }
        }

        function updateAllTextBoxesWithCSVData() {
            sessionState.boxes.forEach(box => {
                if (box.type === 'text' && box.csvColumn) {
                    updateTextBoxWithCSVData(box);
                }
            });
        }

        function updateTextBoxWithCSVData(box) {
            if (!box || !box.element || !csvData || !csvData[currentRecord]) return;
            
            const row = csvData[currentRecord];
            const text = row[box.csvColumn] || '';
            
            // Update the text content
            box.element.textContent = text;
            
            // Apply formatting
            updateTextBoxFont(box);
        }

        function updateTextBoxContent(box) {
            if (!box || !box.element) return;
            
            let text = '';
            
            if (box.csvColumn && csvData && csvData[currentRecord]) {
                // Use CSV data
                text = csvData[currentRecord][box.csvColumn] || '';
            } else {
                // Use static text
                text = box.staticText || 'Sample Text';
            }
            
            box.element.textContent = text;
            updateTextBoxFont(box);
        }

        function autoResizeTextBox(box) {
            if (!box || !box.element) return;
            
            const element = box.element;
            const text = element.textContent;
            
            if (!text) return;
            
            // Create a temporary element to measure text dimensions
            const tempElement = document.createElement('div');
            tempElement.style.cssText = `
                position: absolute;
                visibility: hidden;
                white-space: nowrap;
                font-family: ${element.style.fontFamily || 'Arial, sans-serif'};
                font-size: ${element.style.fontSize || '16px'};
                font-weight: ${element.style.fontWeight || 'normal'};
                font-style: ${element.style.fontStyle || 'normal'};
                padding: ${element.style.padding || '5px'};
                box-sizing: border-box;
            `;
            tempElement.textContent = text;
            
            document.body.appendChild(tempElement);
            
            // Get the measured dimensions
            const textWidth = tempElement.offsetWidth;
            const textHeight = tempElement.offsetHeight;
            
            // Remove the temporary element
            document.body.removeChild(tempElement);
            
            // Calculate new box dimensions with some padding
            const padding = 10;
            const newWidth = Math.max(80, textWidth + padding * 2);
            const newHeight = Math.max(25, textHeight + padding * 2);
            
            // Update the box dimensions
            element.style.width = newWidth + 'px';
            element.style.height = newHeight + 'px';
            
            // Update the box data
            box.width = newWidth;
            box.height = newHeight;
            
            // Update the position inputs in the editor
            const widthInput = document.getElementById('boxWidth');
            const heightInput = document.getElementById('boxHeight');
            if (widthInput) widthInput.value = newWidth;
            if (heightInput) heightInput.value = newHeight;
        }
    </script>
</body>
</html>
