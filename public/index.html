<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" id="jszip-cdn"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
            padding: 20px;
        }

        .main-container {
            display: flex;
            height: calc(100vh - 40px);
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }

        .sidebar.collapsed {
            width: 50px;
        }

        .sidebar-header {
            background: #007bff;
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h1 {
            font-size: 16px;
            white-space: nowrap;
            overflow: hidden;
        }

        .toggle-sidebar {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            padding: 5px;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .sidebar.collapsed .sidebar-content {
            display: none;
        }

        .section {
            margin-bottom: 20px;
        }

        .section-header {
            font-size: 11px;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Enhanced Box Management Styles */
        .box-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .box-type-buttons {
            display: flex;
            gap: 4px;
        }

        .box-type-buttons .btn {
            flex: 1;
            margin-bottom: 0;
            font-size: 10px;
            padding: 6px 4px;
        }

        .box-editor {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 12px;
            margin-top: 8px;
            display: none;
        }

        .box-editor.active {
            display: block;
        }

        .box-editor h4 {
            font-size: 12px;
            margin-bottom: 8px;
            color: #333;
        }

        .form-group {
            margin-bottom: 8px;
        }

        .form-group label {
            display: block;
            font-size: 10px;
            font-weight: 500;
            color: #666;
            margin-bottom: 2px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 10px;
        }

        .form-group input[type="color"] {
            height: 24px;
            padding: 2px;
        }

        .form-row {
            display: flex;
            gap: 6px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .checkbox-group {
            display: flex;
            gap: 8px;
            margin-top: 4px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .checkbox-item label {
            font-size: 9px;
            margin: 0;
            color: #666;
        }

        /* Font Upload Styles */
        .font-upload-area {
            border: 2px dashed #ccc;
            border-radius: 4px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .font-upload-area:hover {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .font-upload-area.dragover {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .font-upload-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .font-upload-content span {
            font-size: 20px;
        }

        .font-upload-content p {
            font-size: 10px;
            margin: 0;
            color: #666;
        }

        .google-font-input {
            display: flex;
            gap: 4px;
        }

        .google-font-input input {
            flex: 1;
            font-size: 10px;
        }

        .google-font-input button {
            font-size: 10px;
            padding: 4px 8px;
            white-space: nowrap;
        }

        .font-status {
            font-size: 9px;
            margin-top: 4px;
            min-height: 12px;
        }

        .font-status.success {
            color: #28a745;
        }

        .font-status.error {
            color: #dc3545;
        }

        .font-status.warning {
            color: #ffc107;
        }
        


        .style-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .style-checkboxes .checkbox-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
        }

        .style-checkboxes .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .style-checkboxes .checkbox-item span {
            color: #666;
        }

        /* Record Navigation Styles */
        .record-navigation {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
        }

        .nav-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .nav-controls button {
            padding: 4px 8px;
            font-size: 10px;
            min-width: 30px;
        }

        .nav-controls span {
            font-size: 10px;
            color: #666;
            flex: 1;
            text-align: center;
        }

        .box-actions {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }

        .box-actions .btn {
            flex: 1;
            margin-bottom: 0;
            font-size: 9px;
            padding: 4px 6px;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        /* CSV Preview Enhancement */
        .csv-preview {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            max-height: 120px;
            overflow-y: auto;
        }

        .csv-table {
            width: 100%;
            font-size: 9px;
            border-collapse: collapse;
        }

        .csv-table th,
        .csv-table td {
            padding: 2px 4px;
            border: 1px solid #e9ecef;
            text-align: left;
        }

        .csv-table th {
            background: #f8f9fa;
            font-weight: 600;
        }

        .csv-table td {
            max-width: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-input {
            display: block;
            width: 100%;
            padding: 8px;
            border: 2px dashed #ccc;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            text-align: center;
            transition: border-color 0.3s;
            font-size: 11px;
            margin-bottom: 8px;
        }

        .file-input:hover {
            border-color: #007bff;
        }

        .file-input input[type="file"] {
            display: none;
        }

        .btn {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-bottom: 6px;
            transition: background-color 0.3s;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #1e7e34;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .status-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #666;
        }

        .status-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #dc3545;
        }

        .status-indicator.loaded {
            background: #28a745;
        }

        .reset-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            margin-top: 10px;
        }

        .reset-btn:hover {
            background: #c82333;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #f8f9fa;
            position: relative;
        }

        .content-header {
            background: white;
            border-bottom: 1px solid #e9ecef;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .content-header h3 {
            font-size: 14px;
            color: #333;
        }

        .editor-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .editor-btn {
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: background-color 0.3s;
        }

        .editor-btn-primary {
            background: #007bff;
            color: white;
        }

        .editor-btn-primary:hover {
            background: #0056b3;
        }

        .editor-btn-secondary {
            background: #6c757d;
            color: white;
        }

        .editor-btn-secondary:hover {
            background: #545b62;
        }

        .editor-btn-success {
            background: #28a745;
            color: white;
        }

        .editor-btn-success:hover {
            background: #1e7e34;
        }

        .editor-btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .editor-btn-warning:hover {
            background: #e0a800;
        }

        .editor-btn-danger {
            background: #dc3545;
            color: white;
        }

        .editor-btn-danger:hover {
            background: #c82333;
        }

        .editor-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .viewer-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #f0f0f0;
        }

        .pdf-viewer {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
        }

        .pdf-viewer.dragging {
            cursor: grabbing;
        }
        
        .pdf-area-outline {
            position: absolute;
            border: 2px dashed #ff6b6b;
            background: transparent;
            pointer-events: none;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .pdf-area-outline.active {
            border-color: #4ecdc4;
            background: transparent;
        }
        
        .simple-multiple-records {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .simple-multiple-records h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }
        
        .records-info {
            margin-top: 10px;
            padding: 8px 12px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 12px;
            color: #495057;
            font-weight: 500;
        }
        
        .multiple-textboxes-section {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .multiple-textboxes-section h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }
        
        .multiple-textboxes-section h4 {
            margin: 10px 0 10px 0;
            font-size: 14px;
            color: #555;
        }
        
        .textbox-mapping-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        .textbox-mapping-item label {
            font-size: 12px;
            color: #666;
            min-width: 80px;
        }
        
        .textbox-mapping-item select {
            flex: 1;
            font-size: 12px;
            padding: 4px;
        }

        .pdf-content {
            position: absolute;
            transform-origin: 0 0;
            transition: transform 0.1s ease;
        }



        .pdf-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }

        .pdf-control-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s;
        }

        .pdf-control-btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        .pdf-control-btn:disabled {
            background: rgba(0, 0, 0, 0.3);
            cursor: not-allowed;
        }

        .zoom-display {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            min-width: 60px;
            text-align: center;
        }

        .no-pdf {
            text-align: center;
            color: #666;
            padding: 40px;
        }

        .no-pdf h3 {
            margin-bottom: 10px;
            color: #333;
        }

        #viewer {
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            background: white;
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1;
        }

        .loading {
            text-align: center;
            color: #666;
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Layout Editor Styles */
        .editor-sidebar {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 250px;
            background: white;
            border-left: 1px solid #ddd;
            padding: 15px;
            overflow-y: auto;
            display: none;
            box-shadow: -2px 0 8px rgba(0,0,0,0.1);
        }

        .editor-sidebar.active {
            display: block;
        }

        .editor-sidebar h4 {
            font-size: 12px;
            margin-bottom: 10px;
            color: #333;
        }

        .editor-form-group {
            margin-bottom: 10px;
        }

        .editor-form-group label {
            display: block;
            margin-bottom: 3px;
            font-size: 10px;
            color: #666;
        }

        .editor-form-group input, .editor-form-group select, .editor-form-group textarea {
            width: 100%;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 10px;
        }

        .editor-form-group textarea {
            height: 40px;
            resize: vertical;
        }

        .grid-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .grid-toggle label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            cursor: pointer;
        }

        .grid-toggle input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .editor-status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
        }

        /* Fabric.js canvas styling */
        .canvas-container {
            position: relative;
            display: inline-block;
        }

        #editorCanvas {
            border: 1px solid #ddd;
            background: transparent;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: auto;
            z-index: 10;
        }

        /* Visual feedback for placement mode */
        .placement-mode {
            background: rgba(0, 123, 255, 0.1) !important;
            border: 2px dashed #007bff !important;
        }

        /* Enhanced text box styles */
        .draggable-text-box {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #007bff;
            padding: 5px;
            cursor: move;
            min-width: 80px;
            min-height: 25px;
            font-family: Arial, sans-serif;
            font-size: 16px;
            color: #000;
            text-align: center;
            user-select: none;
            z-index: 20;
            transition: all 0.1s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            word-wrap: break-word;
            white-space: normal;
        }

        .draggable-text-box:hover {
            border-color: #0056b3;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .draggable-text-box:focus {
            outline: none;
            border-color: #28a745;
            box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.25);
        }

        .draggable-text-box.resizing {
            border-color: #ff6b35;
            box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.25);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h1>PDF Viewer</h1>
                <button class="toggle-sidebar" onclick="toggleSidebar()">‚â°</button>
            </div>
            <div class="sidebar-content">
                <div class="section">
                    <h2 class="section-header">File Uploads</h2>
                    <label class="file-input" for="pdfFile">
                        <input type="file" id="pdfFile" accept="application/pdf">
                        <div id="fileLabel">Click to select PDF file</div>
                    </label>
                    
                    <label class="file-input" for="csvFile">
                        <input type="file" id="csvFile" accept=".csv,text/csv">
                        <div id="csvLabel">Click to select CSV file</div>
                    </label>
                    

                    
                    <button id="generateFromTemplateBtn" class="btn btn-primary" onclick="generateFromTemplate()" disabled>
                        Generate From Template
                    </button>
                    
                    <button id="downloadPdfsBtn" class="btn btn-success" onclick="downloadPdfs()" disabled>
                        Download PDFs
                    </button>
                    
                    <div id="downloadLink" style="display: none;">
                        <a id="downloadAnchor" href="#" target="_blank" class="btn btn-primary" style="text-decoration: none; display: inline-block;">Download Original PDF</a>
                    </div>
                    
                    <!-- Simple Multiple Records -->
                    <div class="simple-multiple-records">
                        <h3 class="section-header">Multiple Records</h3>
                        
                        <div class="form-group">
                            <label for="recordsCountSelect">Number of Records:</label>
                            <select id="recordsCountSelect" class="form-control" style="margin-bottom: 10px;">
                                <option value="2">2 Records</option>
                                <option value="3">3 Records</option>
                                <option value="4" selected>4 Records</option>
                                <option value="5">5 Records</option>
                                <option value="6">6 Records</option>
                                <option value="8">8 Records</option>
                                <option value="10">10 Records</option>
                            </select>
                            
                            <button id="createMultipleRecordsBtn" class="btn btn-success" onclick="createMultipleRecords()" style="width: 100%; padding: 15px; font-size: 16px; font-weight: bold; margin-bottom: 10px;" disabled>
                                üéØ CREATE RECORDS
                            </button>
                            <div style="font-size: 12px; color: #666; text-align: center;">
                                Select a text box with a field first, then click to create multiple copies
                            </div>
                        </div>
                        
                        <div id="recordsInfo" class="records-info">
                            Total records: 0 | Records created: 0
                        </div>
                        
                        <!-- Page Navigation -->
                        <div id="pageNavigation" class="page-navigation" style="display: none; margin-top: 15px;">
                            <h4 style="margin: 0 0 10px 0; font-size: 14px;">Page Navigation</h4>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <button id="prevPageBtn" class="btn btn-secondary" onclick="previousPage()" style="flex: 1;">
                                    ‚Üê Previous Page
                                </button>
                                <span id="pageInfo" style="font-size: 12px; color: #666;">
                                    Page 1 of 1
                                </span>
                                <button id="nextPageBtn" class="btn btn-secondary" onclick="nextPage()" style="flex: 1;">
                                    Next Page ‚Üí
                                </button>
                            </div>
                            <div id="pageRecordsInfo" style="font-size: 11px; color: #888; margin-top: 5px; text-align: center;">
                                Showing records 1-4
                            </div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-header">Layout Editor</h2>
                    <div class="box-controls">
                        <div class="box-type-buttons">
                            <button class="btn btn-primary" onclick="addText()">Add Text</button>
                            <button class="btn btn-secondary" onclick="addImagePlaceholder()">Add Image</button>
                        </div>
                        
                        <div id="boxEditor" class="box-editor">
                            <h4 id="boxEditorTitle">Text Box Properties</h4>
                            
                            <div id="textProperties" style="display: none;">
                                <div class="form-group">
                                    <label>CSV Column:</label>
                                    <select id="boxColumnSelect">
                                        <option value="">Select CSV column...</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label>Static Text (if no CSV column selected):</label>
                                    <input type="text" id="boxTextInput" placeholder="Enter static text or leave empty for CSV data">
                                </div>
                                
                                <!-- Font Upload Section -->
                                <div class="form-group">
                                    <label>Upload Custom Font:</label>
                                    <div class="font-upload-area" id="fontUploadArea">
                                        <input type="file" id="fontUploadInput" accept=".ttf,.otf" style="display: none;">
                                        <div class="font-upload-content">
                                            <span>üìÅ</span>
                                            <p>Drop TTF/OTF file here or click to browse</p>
                                        </div>
                                    </div>
                                    <div id="fontUploadStatus" class="font-status"></div>
                                </div>
                                

                                <!-- Font Selection -->
                                <div class="form-group">
                                    <label>Font Family:</label>
                                    <select id="boxFontFamily">
                                        <option value="Arial">Arial</option>
                                        <option value="Times New Roman">Times New Roman</option>
                                        <option value="Helvetica">Helvetica</option>
                                        <option value="Georgia">Georgia</option>
                                        <option value="Verdana">Verdana</option>
                                        <option value="Courier New">Courier New</option>
                                    </select>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label>Font Size:</label>
                                        <input type="number" id="boxFontSize" value="16" min="8" max="72">
                                    </div>
                                    <div class="form-group">
                                        <label>Text Color:</label>
                                        <input type="color" id="boxTextColor" value="#000000">
                                    </div>
                                </div>
                                
                                <div class="form-group">
                                    <label>Text Alignment:</label>
                                    <select id="boxTextAlign">
                                        <option value="left">Left</option>
                                        <option value="center" selected>Center</option>
                                        <option value="right">Right</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label>Text Styling:</label>
                                    <div class="style-checkboxes">
                                        <label class="checkbox-item">
                                            <input type="checkbox" id="boxBold">
                                            <span>Bold</span>
                                        </label>
                                        <label class="checkbox-item">
                                            <input type="checkbox" id="boxItalic">
                                            <span>Italic</span>
                                        </label>
                                        <label class="checkbox-item">
                                            <input type="checkbox" id="boxUnderline">
                                            <span>Underline</span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            
                            <div id="imageProperties" style="display: none;">
                                <div class="form-group">
                                    <label>Image Source:</label>
                                    <select id="boxImageSource">
                                        <option value="csv">From CSV column</option>
                                        <option value="static">Static image</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label>Image URL/Path:</label>
                                    <input type="text" id="boxImageUrl" placeholder="Enter image URL or path">
                                </div>
                            </div>
                            
                            <div class="form-row">
                                <div class="form-group">
                                    <label>X Position:</label>
                                    <input type="number" id="boxXPos" step="1">
                                </div>
                                <div class="form-group">
                                    <label>Y Position:</label>
                                    <input type="number" id="boxYPos" step="1">
                                </div>
                            </div>
                            
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Width:</label>
                                    <input type="number" id="boxWidth" step="1" min="20">
                                </div>
                                <div class="form-group">
                                    <label>Height:</label>
                                    <input type="number" id="boxHeight" step="1" min="20">
                                </div>
                            </div>
                            
                            <div class="box-actions">
                                <button class="btn btn-warning" onclick="duplicateSelectedBox()">Duplicate</button>
                                <button class="btn btn-danger" onclick="deleteSelectedBox()">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-header">CSV Data</h2>
                    
                    <!-- Record Navigation -->
                    <div id="recordNavigation" class="record-navigation" style="display: none;">
                        <div class="nav-controls">
                            <button id="prevRecord" class="btn btn-secondary">‚Äπ</button>
                            <span id="recordInfo">Record 1 of 1</span>
                            <button id="nextRecord" class="btn btn-secondary">‚Ä∫</button>
                        </div>
                    </div>
                    
                    <div id="csvPreview" class="csv-preview">
                        <h4>CSV Preview (First 5 rows)</h4>
                        <div id="csvTableContainer"></div>
                        <div id="csvInfo" class="csv-info"></div>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-header">Status</h2>
                    <div class="status-items">
                        <div class="status-item">
                            <span class="status-indicator" id="templateIndicator"></span>
                            <span id="templateStatus">Template: None</span>
                        </div>
                        <div class="status-item">
                            <span class="status-indicator" id="csvIndicator"></span>
                            <span id="csvStatus">CSV: None</span>
                        </div>
                        <div class="status-item">
                            <span class="status-indicator" id="layoutIndicator"></span>
                            <span id="layoutStatus">Layout: None</span>
                        </div>
                    </div>
                    <button class="reset-btn" onclick="resetSession()">Reset Session</button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="content-header">
                <h3>PDF Viewer</h3>
            </div>

            <div class="viewer-container">
                <div id="noPdf" class="no-pdf">
                    <h3>No PDF selected</h3>
                    <p>Choose a PDF file to start viewing</p>
                </div>

                <div id="loadingPdf" class="loading" style="display: none;">
                    <div class="spinner"></div>
                    <p>Loading PDF...</p>
                </div>

                <div id="pdfViewer" class="pdf-viewer" style="display: none;">
                    <div class="pdf-controls">
                        <button class="pdf-control-btn" onclick="resetView()" title="Reset View">‚åÇ</button>
                        <button class="pdf-control-btn" onclick="zoomIn()" title="Zoom In">+</button>
                        <button class="pdf-control-btn" onclick="zoomOut()" title="Zoom Out">‚àí</button>
                        <button class="pdf-control-btn" onclick="togglePDFLock()" title="Toggle PDF Lock" id="pdfLockBtn">üîí</button>
                        <div class="zoom-display" id="zoomDisplay">100%</div>
                    </div>
                    
                                    <div class="pdf-content" id="pdfContent">
                    <canvas id="viewer"></canvas>
                    <div id="pdfAreaOutline" class="pdf-area-outline" style="display: none;"></div>
                </div>
                </div>
            </div>



            <!-- Editor Properties Sidebar -->
            <div id="editorSidebar" class="editor-sidebar">
                <h4>Object Properties</h4>
                
                <div class="editor-form-group">
                    <label>Bind to CSV Field:</label>
                    <select id="bindField">
                        <option value="">None (Static)</option>
                        <option value="title">Title</option>
                        <option value="subtitle">Subtitle</option>
                        <option value="price">Price</option>
                        <option value="features">Features</option>
                        <option value="image">Image</option>
                    </select>
                </div>

                <div class="editor-form-group">
                    <label>Static Content:</label>
                    <textarea id="staticContent" placeholder="Enter static text content..."></textarea>
                </div>

                <div class="editor-form-group">
                    <label>Position X:</label>
                    <input type="number" id="posX" step="1">
                </div>

                <div class="editor-form-group">
                    <label>Position Y:</label>
                    <input type="number" id="posY" step="1">
                </div>

                <div class="editor-form-group">
                    <label>Width:</label>
                    <input type="number" id="width" step="1">
                </div>

                <div class="editor-form-group">
                    <label>Height:</label>
                    <input type="number" id="height" step="1">
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let currentPdf = null;
        let currentFile = null;
        let serverPdfUrl = null;

        // Session state management
        let sessionState = {
            templatePdf: null,
            templatePdfBytes: null,
            csv: null,
            csvRows: [],
            layout: null,
            boxes: [],
            selectedBox: null
        };

        // Enhanced box management system
        let boxCounter = 0;
        let currentBoxId = null;
        
        // Font management system
        let availableFonts = ['Arial', 'Times New Roman', 'Helvetica', 'Georgia', 'Verdana', 'Courier New'];
        let loadedFonts = {};
        let defaultFontFamily = 'Arial';
        
        // CSV data management
        let currentRecord = 0;
        let csvData = null;

        // Initialize status indicators
        function updateStatusIndicators() {
            const templateLoaded = sessionState.templatePdf !== null;
            const csvLoaded = sessionState.csvRows.length > 0;
            const layoutLoaded = sessionState.layout !== null;

            // Update status bar text and indicators
            document.getElementById('templateStatus').textContent = `Template: ${templateLoaded ? 'Loaded' : 'None'}`;
            document.getElementById('csvStatus').textContent = `CSV: ${csvLoaded ? sessionState.csvRows.length + ' rows' : 'None'}`;
            document.getElementById('layoutStatus').textContent = `Layout: ${layoutLoaded ? 'Loaded' : 'None'}`;

            document.getElementById('templateIndicator').classList.toggle('loaded', templateLoaded);
            document.getElementById('csvIndicator').classList.toggle('loaded', csvLoaded);
            document.getElementById('layoutIndicator').classList.toggle('loaded', layoutLoaded);
        }

        // File input handler
        document.getElementById('pdfFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                currentFile = file;
                document.getElementById('fileLabel').textContent = file.name;
                
                // Hide download link
                document.getElementById('downloadLink').style.display = 'none';
                serverPdfUrl = null;

                // Automatically load and preview the PDF
                loadPdf(file);
            }
        });



        async function loadPdf(file) {
            try {
                console.log('Loading PDF file:', file.name);
                
                // Show loading state
                document.getElementById('noPdf').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'none';
                document.getElementById('loadingPdf').style.display = 'block';

                // Read file as ArrayBuffer
                const arrayBuffer = await file.arrayBuffer();

                // Create a separate copy for PDF-lib BEFORE loading with PDF.js
                const templateBytes = new Uint8Array(arrayBuffer).slice();

                // Load PDF document
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                
                // Store PDF info
                currentPdf = pdf;

                // Update session state with the separate copy
                sessionState.templatePdf = pdf;
                sessionState.templatePdfBytes = templateBytes;
                updateStatusIndicators();

                // Enable Generate From Template button
                document.getElementById('generateFromTemplateBtn').disabled = false;
                
                // Enable Download PDFs button if CSV and boxes are also loaded
                updateDownloadButtonState();
                
                // Update records info
                updateRecordsInfo();

                // Render the page (always page 1 for single-page PDFs)
                await renderPage(1);

                // Initialize simple editor after PDF is loaded
                initEditor();

                // Hide loading and noPdf message, show PDF viewer
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'block';
                
                // Initialize PDF dragging functionality
                initPDFDragging();
                
                // Initialize PDF lock status
                updatePDFLockStatus();
                
                // Update PDF area outline
                updatePdfAreaOutline();

            } catch (error) {
                console.error('Error loading PDF:', error);
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'block';
                document.getElementById('noPdf').innerHTML = `
                    <h3>Error loading PDF</h3>
                    <p>${error.message}</p>
                `;
            }
        }

        async function loadPdfFromUrl(url) {
            try {
                // Fetch PDF from server
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Failed to fetch PDF from server');
                }
                
                const arrayBuffer = await response.arrayBuffer();

                // Load PDF document
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                
                // Store PDF info
                currentPdf = pdf;

                // Update session state
                sessionState.templatePdf = pdf;
                sessionState.templatePdfBytes = arrayBuffer.slice(0); // Create a copy to avoid detachment
                updateStatusIndicators();

                // Render the page (always page 1 for single-page PDFs)
                await renderPage(1);

                // Hide loading and noPdf message, show PDF viewer
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'block';
                
                // Initialize PDF dragging functionality
                initPDFDragging();

            } catch (error) {
                console.error('Error loading PDF from URL:', error);
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'block';
                document.getElementById('noPdf').innerHTML = `
                    <h3>Error loading PDF</h3>
                    <p>${error.message}</p>
                `;
            }
        }

        async function renderPage(pageNumber) {
            if (!currentPdf) return;

            try {
                // Get page
                const page = await currentPdf.getPage(pageNumber);

                // Set up canvas
                const canvas = document.getElementById('viewer');
                const context = canvas.getContext('2d');

                // Render PDF at original quality without scaling down
                const viewport = page.getViewport({scale: 1.0});
                
                // Enable high-quality rendering
                context.imageSmoothingEnabled = true;
                context.imageSmoothingQuality = 'high';

                // Set canvas dimensions to original PDF size
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                // Set canvas display size to fit viewer while maintaining aspect ratio
                const viewerContainer = document.querySelector('.viewer-container');
                const containerWidth = viewerContainer.clientWidth;
                const containerHeight = viewerContainer.clientHeight;
                
                const scaleX = containerWidth / viewport.width;
                const scaleY = containerHeight / viewport.height;
                const displayScale = Math.min(scaleX, scaleY, 1.0); // Don't scale up, only down
                
                canvas.style.width = (viewport.width * displayScale) + 'px';
                canvas.style.height = (viewport.height * displayScale) + 'px';

                // Make sure canvas is visible
                canvas.style.display = 'block';

                // Render page at original quality
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };

                await page.render(renderContext).promise;

                // Update editor canvas size to match the rendered PDF
                if (typeof editorCanvas !== 'undefined' && editorCanvas) {
                    updateEditorPageSize();
                }

                console.log('PDF rendered at original quality:', viewport.width, 'x', viewport.height);

            } catch (error) {
                console.error('Error rendering page:', error);
            }
        }

        // Drag and drop support
        const uploadArea = document.querySelector('.sidebar');
        const fileInput = document.getElementById('pdfFile');

        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.style.backgroundColor = '#e3f2fd';
        });

        uploadArea.addEventListener('dragleave', function(e) {
            e.preventDefault();
            uploadArea.style.backgroundColor = '';
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.style.backgroundColor = '';
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                fileInput.files = files;
                currentFile = files[0];
                document.getElementById('fileLabel').textContent = files[0].name;
                
                // Hide download link
                document.getElementById('downloadLink').style.display = 'none';
                serverPdfUrl = null;

                // Automatically load and preview the PDF
                loadPdf(files[0]);
            }
        });

        // Initialize status indicators on page load
        updateStatusIndicators();
        
        // Function to update download button state
        function updateDownloadButtonState() {
            const hasTemplate = sessionState.templatePdfBytes !== null;
            const hasCSV = sessionState.csvRows.length > 0;
            const hasBoxes = sessionState.boxes.length > 0;
            
            const downloadBtn = document.getElementById('downloadPdfsBtn');
            if (downloadBtn) {
                downloadBtn.disabled = !(hasTemplate && hasCSV && hasBoxes);
            }
        }
        
        // Function to update PDF area outline
        function updatePdfAreaOutline() {
            const canvas = document.getElementById('viewer');
            const outline = document.getElementById('pdfAreaOutline');
            
            if (!canvas || !outline) return;
            
            const rect = canvas.getBoundingClientRect();
            const viewerRect = document.getElementById('pdfViewer').getBoundingClientRect();
            
            // Calculate position relative to the viewer
            const left = rect.left - viewerRect.left;
            const top = rect.top - viewerRect.top;
            
            outline.style.left = left + 'px';
            outline.style.top = top + 'px';
            outline.style.width = rect.width + 'px';
            outline.style.height = rect.height + 'px';
            outline.style.display = 'block';
            
            console.log(`PDF area outline updated: ${rect.width}x${rect.height} at (${left}, ${top})`);
            console.log(`Canvas actual size: ${canvas.width}x${canvas.height}, Display size: ${rect.width}x${rect.height}`);
        }
        
        // Update outline when zoom changes
        function updateOutlineOnZoom() {
            setTimeout(updatePdfAreaOutline, 100); // Small delay to ensure zoom is applied
        }
        
        // Simple Multiple Records Management
        let recordsCreated = 0;
        
        function createMultipleRecords() {
            // Check if a text box is selected
            if (!sessionState.selectedBox) {
                alert('Please select a text box first!');
                return;
            }
            
            // Check if the selected text box has a CSV column assigned
            if (!sessionState.selectedBox.csvColumn || sessionState.selectedBox.csvColumn === '') {
                alert('Please select a text box that has a CSV field assigned!');
                return;
            }
            
            // Check if CSV data is loaded
            if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                alert('Please upload CSV data first!');
                return;
            }
            
            // Get the number of records to create from dropdown
            const recordsCount = parseInt(document.getElementById('recordsCountSelect').value);
            
            // Get the selected text box
            const selectedBox = sessionState.selectedBox;
            
            // Create copies of the selected text box with different records
            for (let i = 0; i < recordsCount; i++) {
                if (i >= sessionState.csvRows.length) break; // Don't create more than available records
                
                const record = sessionState.csvRows[i];
                const recordText = record[selectedBox.csvColumn] || `Record ${i + 1}`;
                
                // Create new text box
                const newBox = {
                    ...selectedBox,
                    id: ++boxCounter,
                    y: selectedBox.y + (i * 60), // Stack vertically with 60px spacing
                    element: null
                };
                
                // Create the text box element
                const textBox = document.createElement('div');
                textBox.className = 'draggable-text-box';
                textBox.id = 'textBox_' + newBox.id;
                textBox.style.cssText = `
                    position: absolute;
                    left: ${newBox.x}px;
                    top: ${newBox.y}px;
                    width: ${newBox.width}px;
                    height: ${newBox.height}px;
                    min-width: 80px;
                    min-height: 25px;
                    background: transparent;
                    border: none;
                    padding: 5px;
                    cursor: move;
                    pointer-events: auto;
                    z-index: 20;
                    font-family: ${newBox.fontFamily}, sans-serif;
                    font-size: ${newBox.fontSize}px;
                    color: ${newBox.color};
                    text-align: ${newBox.textAlign};
                    user-select: none;
                    box-sizing: border-box;
                    overflow: hidden;
                    box-shadow: none;
                    transition: all 0.1s ease;
                `;
                textBox.textContent = recordText;
                textBox.contentEditable = false;
                
                // Add to overlay container
                const overlayContainer = document.getElementById('overlayContainer');
                overlayContainer.appendChild(textBox);
                
                // Make it draggable
                makeDraggable(textBox);
                
                // Add click handler
                textBox.addEventListener('click', function(e) {
                    e.stopPropagation();
                    document.querySelectorAll('.draggable-text-box').forEach(box => {
                        box.style.border = 'none';
                    });
                    textBox.style.border = 'none';
                    sessionState.selectedBox = newBox;
                    updateBoxEditor();
                    updateBoxEditorValues(newBox);
                });
                
                newBox.element = textBox;
                sessionState.boxes.push(newBox);
            }
            
            recordsCreated += recordsCount;
            updateRecordsInfo();
            
            // Reset to first page and update navigation
            currentPage = 0;
            updatePageNavigation();
            updateAllTextBoxesWithCSVData();
            
            alert(`Created ${recordsCount} text boxes with records 1-${recordsCount} from "${selectedBox.csvColumn}" field!`);
        }
        
        function updateRecordsInfo() {
            const infoElement = document.getElementById('recordsInfo');
            const totalRecords = sessionState.csvRows ? sessionState.csvRows.length : 0;
            
            infoElement.textContent = `Total records: ${totalRecords} | Records created: ${recordsCreated}`;
        }
        
        function updateCreateRecordsButtonState() {
            const createBtn = document.getElementById('createMultipleRecordsBtn');
            const hasSelectedBox = sessionState.selectedBox !== null;
            const hasCsvColumn = sessionState.selectedBox && sessionState.selectedBox.csvColumn && sessionState.selectedBox.csvColumn !== '';
            const hasCsvData = sessionState.csvRows && sessionState.csvRows.length > 0;
            
            // Enable button only if we have a selected box with a CSV column and CSV data
            const shouldEnable = hasSelectedBox && hasCsvColumn && hasCsvData;
            createBtn.disabled = !shouldEnable;
            
            // Update button text to show the selected number of records
            const recordsCount = document.getElementById('recordsCountSelect').value;
            createBtn.textContent = `üéØ CREATE ${recordsCount} RECORDS`;
        }
        
        // Page navigation variables
        let currentPage = 0;
        let recordsPerPage = 4;
        let totalPages = 1;
        
        function updatePageNavigation() {
            const pageNav = document.getElementById('pageNavigation');
            const pageInfo = document.getElementById('pageInfo');
            const pageRecordsInfo = document.getElementById('pageRecordsInfo');
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            
            if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                pageNav.style.display = 'none';
                return;
            }
            
            // Calculate pages
            recordsPerPage = parseInt(document.getElementById('recordsCountSelect').value);
            totalPages = Math.ceil(sessionState.csvRows.length / recordsPerPage);
            
            // Update page info
            pageInfo.textContent = `Page ${currentPage + 1} of ${totalPages}`;
            
            // Calculate record range for current page
            const startRecord = currentPage * recordsPerPage;
            const endRecord = Math.min(startRecord + recordsPerPage - 1, sessionState.csvRows.length - 1);
            pageRecordsInfo.textContent = `Showing records ${startRecord + 1}-${endRecord + 1}`;
            
            // Update button states
            prevBtn.disabled = currentPage === 0;
            nextBtn.disabled = currentPage >= totalPages - 1;
            
            // Show navigation
            pageNav.style.display = 'block';
        }
        
        function previousPage() {
            if (currentPage > 0) {
                currentPage--;
                updatePageNavigation();
                updateAllTextBoxesWithCSVData();
            }
        }
        
        function nextPage() {
            if (currentPage < totalPages - 1) {
                currentPage++;
                updatePageNavigation();
                updateAllTextBoxesWithCSVData();
            }
        }
        
        function updateRecordDisplay() {
            updatePageNavigation();
        }
        
        function generateRecordsPreview() {
            const previewContainer = document.getElementById('previewContainer');
            if (!previewContainer || !sessionState.csvRows || sessionState.csvRows.length === 0) return;
            
            const totalRecords = sessionState.csvRows.length;
            const totalPages = Math.ceil(totalRecords / recordsPerPage);
            
            let previewHTML = '';
            
            for (let pageIndex = 0; pageIndex < totalPages; pageIndex++) {
                const startRecord = pageIndex * recordsPerPage;
                const endRecord = Math.min(startRecord + recordsPerPage, totalRecords);
                const recordsOnThisPage = endRecord - startRecord;
                
                previewHTML += `
                    <div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ccc; background: white;">
                        <div style="font-weight: bold; color: #007bff; margin-bottom: 8px;">
                            Page ${pageIndex + 1} (Records ${startRecord + 1}-${endRecord})
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 5px;">
                `;
                
                for (let i = 0; i < recordsOnThisPage; i++) {
                    const recordIndex = startRecord + i;
                    const record = sessionState.csvRows[recordIndex];
                    const recordText = Object.values(record).slice(0, 3).join(' | '); // Show first 3 fields
                    
                    previewHTML += `
                        <div style="padding: 5px; background: #f0f0f0; border-left: 3px solid #007bff; font-size: 11px;">
                            <strong>Record ${recordIndex + 1}:</strong> ${recordText}
                        </div>
                    `;
                }
                
                previewHTML += `
                        </div>
                    </div>
                `;
            }
            
            previewContainer.innerHTML = previewHTML;
        }
        
        // Initialize simple system when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing simple system...');
            updateRecordsInfo();
            
            // Add event listener for records count dropdown
            document.getElementById('recordsCountSelect').addEventListener('change', function() {
                updateCreateRecordsButtonState();
                updatePageNavigation();
            });
        });
        
        // InDesign-style layout management
        
        function updateTextBoxMappingDisplay() {
            // For InDesign-style data merge: each text box shows current record
            // The records per page feature will duplicate the layout multiple times
            sessionState.boxes.forEach((box) => {
                const select = document.getElementById(`mapping_${box.id}`);
                if (select) {
                    select.value = currentRecord;
                    textBoxMappings[box.id] = currentRecord;
                }
            });
            
            // Update all text boxes with current record data
            updateAllTextBoxesWithCSVData();
        }
        
        // Initialize font handling
        initializeFontHandling();

        // Layout Editor Variables
        let selectedBox = null;
        let isEditorMode = false;

        // Page size definitions (in points)
        const PAGE_SIZES = {
            'A4': { width: 595, height: 842 },
            'A5': { width: 420, height: 595 },
            'A6': { width: 298, height: 420 }
        };

        // Initialize simple HTML-based editor
        function initEditor() {
            // Create the overlay container for text boxes
            const overlayContainer = document.createElement('div');
            overlayContainer.id = 'overlayContainer';
            overlayContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 10;
            `;
            
            const pdfViewer = document.getElementById('pdfViewer');
            if (pdfViewer) {
                pdfViewer.appendChild(overlayContainer);
                pdfViewer.style.position = 'relative';
            }
        }

        function toggleEditorMode() {
            isEditorMode = !isEditorMode;
            const viewer = document.getElementById('viewer');
            const editorCanvasElement = document.getElementById('editorCanvas');
            
            if (isEditorMode) {
                // Show both PDF and editor canvas
                viewer.style.display = 'block';
                editorCanvasElement.style.display = 'block';
                
                // Disable PDF dragging when in editor mode
                if (pdfViewer) {
                    pdfViewer.style.cursor = 'default';
                }
                
                if (editorCanvas) {
                    editorCanvas.renderAll();
                }
            } else {
                // Hide editor canvas, keep PDF visible
                editorCanvasElement.style.display = 'none';
                viewer.style.display = 'block';
                
                // Re-enable PDF dragging when not in editor mode
                if (pdfViewer) {
                    pdfViewer.style.cursor = 'grab';
                }
            }
        }



        function addText() {
            // Ensure editor is initialized
            if (!document.getElementById('overlayContainer')) {
                initEditor();
            }
            
            // Get PDF viewer dimensions for centering
            const pdfViewer = document.getElementById('pdfViewer');
            if (!pdfViewer || !sessionState.templatePdf) {
                alert('Please upload a PDF template first');
                return;
            }
            
            const rect = pdfViewer.getBoundingClientRect();
            const centerX = (rect.width / 2) - 60;
            const centerY = (rect.height / 2) - 20;
            
            // Create text box element
            const textBox = document.createElement('div');
            textBox.className = 'draggable-text-box';
            textBox.id = 'textBox_' + ++boxCounter;
            textBox.style.cssText = `
                position: absolute;
                left: ${centerX}px;
                top: ${centerY}px;
                width: 120px;
                height: 40px;
                min-width: 80px;
                min-height: 25px;
                background: transparent;
                border: none;
                padding: 5px;
                cursor: move;
                pointer-events: auto;
                z-index: 20;
                font-family: Arial, sans-serif;
                font-size: 16px;
                color: #000;
                text-align: center;
                user-select: none;
                box-sizing: border-box;
                overflow: hidden;
                box-shadow: none;
                transition: all 0.1s ease;
            `;
            textBox.textContent = 'Sample Text';
            textBox.contentEditable = false; // Disable direct editing since we use the panel
            
            // Add to overlay container
            const overlayContainer = document.getElementById('overlayContainer');
            overlayContainer.appendChild(textBox);
            
            // Make it draggable
            makeDraggable(textBox);
            
            // Add to session state
            const boxData = {
                id: boxCounter,
                element: textBox,
                type: 'text',
                boxType: 'text',
                csvColumn: '',
                staticText: 'Sample Text',
                bold: false,
                italic: false,
                underline: false,
                fontSize: 16,
                fontFamily: defaultFontFamily,
                color: '#000000',
                textAlign: 'center',
                x: centerX,
                y: centerY,
                width: 120,
                height: 40
            };
            
            // Add click handler for selection
            textBox.addEventListener('click', function(e) {
                e.stopPropagation();
                
                // Remove selection from all boxes (no borders)
                document.querySelectorAll('.draggable-text-box').forEach(box => {
                    box.style.border = 'none';
                });
                
                // Select this box (no border)
                textBox.style.border = 'none';
                sessionState.selectedBox = boxData;
                updateBoxEditor();
                updateBoxEditorValues(boxData);
            });
            
            sessionState.boxes.push(boxData);
            sessionState.selectedBox = boxData;
            currentBoxId = boxCounter;
            
            // Update box editor
            updateBoxEditor();
            updateBoxEditorValues(boxData);
            
            // Update download button state
            updateDownloadButtonState();
            
            // Select the text box immediately for editing
            textBox.focus();
            // Remove the problematic select() call - text boxes don't have select() method
            
            // Update text size to fit the initial box dimensions
            updateTextSize(textBox);
        }

        function addImagePlaceholder() {
            if (!editorCanvas) {
                // Initialize editor canvas if not already done
                initEditorCanvas();
                setTimeout(() => addImagePlaceholder(), 100);
                return;
            }

            // Switch to editor mode
            if (!isEditorMode) {
                toggleEditorMode();
            }

            // Calculate center position for the new image placeholder
            const canvasWidth = editorCanvas.getWidth();
            const canvasHeight = editorCanvas.getHeight();
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            
            const rect = new fabric.Rect({
                left: centerX - 50,
                top: centerY - 50,
                width: 100,
                height: 100,
                fill: '#f0f0f0',
                stroke: '#999',
                strokeWidth: 1,
                originX: 'center',
                originY: 'center'
            });

            const text = new fabric.Text('IMAGE', {
                left: centerX,
                top: centerY,
                fontSize: 12,
                fill: '#666',
                fontFamily: 'Arial',
                textAlign: 'center',
                originX: 'center',
                originY: 'center'
            });

            const group = new fabric.Group([rect, text], {
                left: centerX,
                top: centerY,
                originX: 'center',
                originY: 'center',
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true,
                lockRotation: false,
                lockScalingX: false,
                lockScalingY: false,
                lockMovementX: false,
                lockMovementY: false
            });

            // Add custom properties for our box management system
            group.boxId = ++boxCounter;
            group.boxType = 'image';
            group.csvColumn = '';
            group.imageSource = 'csv';
            group.imageUrl = '';
            
            editorCanvas.add(group);
            editorCanvas.setActiveObject(group);
            
            // Add to session state and select
            sessionState.boxes.push(group);
            sessionState.selectedBox = group;
            currentBoxId = group.boxId;
            
            // Update box editor
            updateBoxEditor();
            updateBoxEditorValues(group);
            
            updateEditorStatus('Image placeholder created - drag it to position and edit properties');
        }

        function duplicateObject() {
            if (!selectedEditorObject || !editorCanvas) return;

            const clone = fabric.util.object.clone(selectedEditorObject);
            clone.set({
                left: selectedEditorObject.left + 20,
                top: selectedEditorObject.top + 20
            });

            editorCanvas.add(clone);
            editorCanvas.setActiveObject(clone);
            updateEditorStatus('Object duplicated');
        }

        function toggleLock() {
            if (!selectedEditorObject) return;

            selectedEditorObject.selectable = !selectedEditorObject.selectable;
            selectedEditorObject.evented = !selectedEditorObject.evented;
            
            const lockBtn = document.getElementById('lockBtn');
            if (selectedEditorObject.selectable) {
                lockBtn.textContent = 'Lock';
                lockBtn.className = 'editor-btn editor-btn-warning';
            } else {
                lockBtn.textContent = 'Unlock';
                lockBtn.className = 'editor-btn editor-btn-success';
            }

            updateEditorStatus(selectedEditorObject.selectable ? 'Object unlocked' : 'Object locked');
        }

        function deleteObject() {
            if (!selectedEditorObject || !editorCanvas) return;

            editorCanvas.remove(selectedEditorObject);
            editorCanvas.discardActiveObject();
            updateEditorStatus('Object deleted');
        }

        function clearCanvas() {
            if (!editorCanvas) return;

            if (confirm('Are you sure you want to clear all objects?')) {
                editorCanvas.clear();
                updateEditorStatus('Canvas cleared');
            }
        }

        function onEditorObjectSelected(e) {
            selectedEditorObject = e.target;
            updateEditorSidebar();
            updateEditorButtonStates(true);
            updateEditorStatus('Object selected');
        }

        function onEditorObjectDeselected() {
            selectedEditorObject = null;
            document.getElementById('editorSidebar').classList.remove('active');
            updateEditorButtonStates(false);
            updateEditorStatus('No object selected');
        }

        function onEditorObjectModified(e) {
            updateEditorSidebar();
            updateEditorStatus('Object modified');
        }

        function onEditorObjectMoving(e) {
            if (gridSize > 0) {
                const obj = e.target;
                obj.set({
                    left: Math.round(obj.left / gridSize) * gridSize,
                    top: Math.round(obj.top / gridSize) * gridSize
                });
            }
        }

        function onEditorObjectScaling(e) {
            if (gridSize > 0) {
                const obj = e.target;
                obj.set({
                    width: Math.round(obj.width / gridSize) * gridSize,
                    height: Math.round(obj.height / gridSize) * gridSize
                });
            }
        }

        function updateEditorSidebar() {
            if (!selectedEditorObject) return;

            document.getElementById('editorSidebar').classList.add('active');

            // Get object metadata
            const meta = selectedEditorObject.meta || {};

            // Update form fields
            document.getElementById('bindField').value = meta.bind || '';
            document.getElementById('staticContent').value = meta.static || '';
            document.getElementById('posX').value = Math.round(selectedEditorObject.left);
            document.getElementById('posY').value = Math.round(selectedEditorObject.top);
            document.getElementById('width').value = Math.round(selectedEditorObject.width || selectedEditorObject.scaleX * 100);
            document.getElementById('height').value = Math.round(selectedEditorObject.height || selectedEditorObject.scaleY * 100);

            // Add event listeners for form changes
            document.getElementById('bindField').onchange = updateEditorObjectMeta;
            document.getElementById('staticContent').oninput = updateEditorObjectMeta;
            document.getElementById('posX').onchange = updateEditorObjectPosition;
            document.getElementById('posY').onchange = updateEditorObjectPosition;
            document.getElementById('width').onchange = updateEditorObjectSize;
            document.getElementById('height').onchange = updateEditorObjectSize;
        }

        function updateEditorObjectMeta() {
            if (!selectedEditorObject) return;

            selectedEditorObject.meta = {
                bind: document.getElementById('bindField').value,
                static: document.getElementById('staticContent').value
            };

            // Update text content if it's a text object
            if (selectedEditorObject.type === 'text' && document.getElementById('staticContent').value) {
                selectedEditorObject.set('text', document.getElementById('staticContent').value);
            }

            editorCanvas.renderAll();
        }

        function updateEditorObjectPosition() {
            if (!selectedEditorObject) return;

            selectedEditorObject.set({
                left: parseInt(document.getElementById('posX').value),
                top: parseInt(document.getElementById('posY').value)
            });

            editorCanvas.renderAll();
        }

        function updateEditorObjectSize() {
            if (!selectedEditorObject) return;

            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);

            if (selectedEditorObject.type === 'text') {
                selectedEditorObject.set('fontSize', Math.min(width, height) / 2);
            } else {
                selectedEditorObject.set({
                    width: width,
                    height: height
                });
            }

            editorCanvas.renderAll();
        }

        function updateEditorButtonStates(enabled) {
            document.getElementById('duplicateBtn').disabled = !enabled;
            document.getElementById('lockBtn').disabled = !enabled;
            document.getElementById('deleteBtn').disabled = !enabled;
        }

        // Enhanced Box Management Functions
        function updateBoxEditor() {
            const boxEditor = document.getElementById('boxEditor');
            if (sessionState.selectedBox) {
                boxEditor.classList.add('active');
            } else {
                boxEditor.classList.remove('active');
            }
            
            // Update the create records button state
            updateCreateRecordsButtonState();
        }

        function updateBoxEditorValues(box) {
            if (!box) return;

            // Update CSV column dropdown
            const columnSelect = document.getElementById('boxColumnSelect');
            columnSelect.innerHTML = '<option value="">Select CSV column...</option>';
            
            if (csvData && csvData.length > 0) {
                const columns = Object.keys(csvData[0]);
                columns.forEach(column => {
                    const option = document.createElement('option');
                    option.value = column;
                    option.textContent = column;
                    option.selected = column === box.csvColumn;
                    columnSelect.appendChild(option);
                });
            }

            // Show/hide appropriate property sections
            const textProps = document.getElementById('textProperties');
            const imageProps = document.getElementById('imageProperties');
            
            if (box.boxType === 'text') {
                textProps.style.display = 'block';
                imageProps.style.display = 'none';
                
                // Update text properties
                document.getElementById('boxTextInput').value = box.staticText || '';
                document.getElementById('boxFontSize').value = box.fontSize || 16;
                document.getElementById('boxFontFamily').value = box.fontFamily || 'Arial';
                document.getElementById('boxTextColor').value = box.fill || '#000000';
                document.getElementById('boxBold').checked = box.bold || false;
                document.getElementById('boxItalic').checked = box.italic || false;
                document.getElementById('boxUnderline').checked = box.underline || false;
                document.getElementById('boxTextAlign').value = box.textAlign || 'center';
                
                // Update title
                document.getElementById('boxEditorTitle').textContent = 'Text Box Properties';
            } else if (box.boxType === 'image') {
                textProps.style.display = 'none';
                imageProps.style.display = 'block';
                
                // Update image properties
                document.getElementById('boxImageSource').value = box.imageSource || 'csv';
                document.getElementById('boxImageUrl').value = box.imageUrl || '';
                
                // Update title
                document.getElementById('boxEditorTitle').textContent = 'Image Box Properties';
            }

            // Update position and size
            document.getElementById('boxXPos').value = Math.round(box.left || 0);
            document.getElementById('boxYPos').value = Math.round(box.top || 0);
            document.getElementById('boxWidth').value = Math.round(box.width || 100);
            document.getElementById('boxHeight').value = Math.round(box.height || 100);

            // Add event listeners
            addBoxEditorEventListeners(box);
        }

        function addBoxEditorEventListeners(box) {
            // CSV Column change
            document.getElementById('boxColumnSelect').onchange = function() {
                box.csvColumn = this.value;
                updateTextBoxContent(box);
                updateEditorStatus(`Box bound to CSV column: ${this.value || 'None'}`);
                updateCreateRecordsButtonState();
            };

            // Text properties
            if (box.boxType === 'text') {
                document.getElementById('boxTextInput').oninput = function() {
                    box.staticText = this.value;
                    updateTextBoxContent(box);
                };

                document.getElementById('boxFontSize').oninput = function() {
                    const size = parseInt(this.value);
                    box.fontSize = size;
                    updateTextBoxFont(box);
                };

                document.getElementById('boxFontFamily').onchange = function() {
                    const family = this.value;
                    box.fontFamily = family;
                    updateTextBoxFont(box);
                };

                document.getElementById('boxTextColor').oninput = function() {
                    const color = this.value;
                    box.color = color;
                    updateTextBoxFont(box);
                };

                document.getElementById('boxBold').onchange = function() {
                    box.bold = this.checked;
                    updateTextBoxFont(box);
                };

                document.getElementById('boxItalic').onchange = function() {
                    box.italic = this.checked;
                    updateTextBoxFont(box);
                };

                document.getElementById('boxUnderline').onchange = function() {
                    box.underline = this.checked;
                    updateTextBoxFont(box);
                };

                document.getElementById('boxTextAlign').onchange = function() {
                    const align = this.value;
                    box.textAlign = align;
                    updateTextBoxFont(box);
                };
            }

            // Image properties
            if (box.boxType === 'image') {
                document.getElementById('boxImageSource').onchange = function() {
                    box.imageSource = this.value;
                };

                document.getElementById('boxImageUrl').oninput = function() {
                    box.imageUrl = this.value;
                };
            }

            // Position and size
            document.getElementById('boxXPos').onchange = function() {
                const x = parseInt(this.value);
                box.set('left', x);
                editorCanvas.renderAll();
            };

            document.getElementById('boxYPos').onchange = function() {
                const y = parseInt(this.value);
                box.set('top', y);
                editorCanvas.renderAll();
            };

            document.getElementById('boxWidth').onchange = function() {
                const width = parseInt(this.value);
                box.set('width', width);
                editorCanvas.renderAll();
            };

            document.getElementById('boxHeight').onchange = function() {
                const height = parseInt(this.value);
                box.set('height', height);
                editorCanvas.renderAll();
            };
        }

        function duplicateSelectedBox() {
            if (!sessionState.selectedBox || !editorCanvas) return;

            const original = sessionState.selectedBox;
            const clone = fabric.util.object.clone(original);
            
            // Offset the clone
            clone.set({
                left: original.left + 20,
                top: original.top + 20,
                boxId: ++boxCounter
            });

            // Copy custom properties
            clone.boxType = original.boxType;
            clone.csvColumn = original.csvColumn;
            clone.staticText = original.staticText;
            clone.bold = original.bold;
            clone.italic = original.italic;
            clone.underline = original.underline;
            clone.imageSource = original.imageSource;
            clone.imageUrl = original.imageUrl;

            editorCanvas.add(clone);
            sessionState.boxes.push(clone);
            
            // Select the new clone
            sessionState.selectedBox = clone;
            currentBoxId = clone.boxId;
            updateBoxEditorValues(clone);
            
            updateEditorStatus('Box duplicated');
        }

        function deleteSelectedBox() {
            if (!sessionState.selectedBox) return;

            const boxId = sessionState.selectedBox.id;
            
            // Remove element from DOM
            if (sessionState.selectedBox.element) {
                sessionState.selectedBox.element.remove();
            }
            
            // Remove from session state
            sessionState.boxes = sessionState.boxes.filter(box => box.id !== boxId);
            
            // Clear selection
            sessionState.selectedBox = null;
            
            // Hide box editor
            updateBoxEditor();
            
            updateEditorStatus('Box deleted');
        }

        // Simple drag functionality for text boxes
        function makeDraggable(element) {
            let isDragging = false;
            let isResizing = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;
            let initialWidth;
            let initialHeight;
            let resizeHandle = '';

            // Add resize handles
            addResizeHandles(element);

            // Use mousedown on the element itself
            element.addEventListener('mousedown', dragStart);
            
            // Use document-level events for better drag handling
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            function dragStart(e) {
                // Prevent event from bubbling to PDF viewer
                e.stopPropagation();
                
                // Check if clicking on resize handle
                if (e.target.classList.contains('resize-handle')) {
                    isResizing = true;
                    isDragging = false;
                    resizeHandle = e.target.dataset.handle;
                    initialWidth = element.offsetWidth;
                    initialHeight = element.offsetHeight;
                    initialX = e.clientX;
                    initialY = e.clientY;
                    element.style.cursor = 'nwse-resize';
                    element.classList.add('resizing');
                    return;
                }

                // Normal dragging
                if (e.target === element) {
                    isDragging = true;
                    isResizing = false;
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    element.style.cursor = 'grabbing';
                    element.style.zIndex = '30';
                }
            }

            function drag(e) {
                if (isResizing) {
                    e.preventDefault();
                    e.stopPropagation();
                    const deltaX = e.clientX - initialX;
                    const deltaY = e.clientY - initialY;
                    
                    // Only resize, don't move the box position
                    if (resizeHandle.includes('e')) { // right
                        element.style.width = Math.max(80, initialWidth + deltaX) + 'px';
                    }
                    if (resizeHandle.includes('w')) { // right edge stays fixed, left edge moves
                        const newWidth = Math.max(80, initialWidth - deltaX);
                        element.style.width = newWidth + 'px';
                        element.style.left = (parseInt(element.style.left) + (initialWidth - newWidth)) + 'px';
                    }
                    if (resizeHandle.includes('s')) { // bottom
                        element.style.height = Math.max(25, initialHeight + deltaY) + 'px';
                    }
                    if (resizeHandle.includes('n')) { // bottom edge stays fixed, top edge moves
                        const newHeight = Math.max(25, initialHeight - deltaY);
                        element.style.height = newHeight + 'px';
                        element.style.top = (parseInt(element.style.top) + (initialHeight - newHeight)) + 'px';
                    }
                    
                    // Update font size based on box size
                    updateTextSize(element);
                } else if (isDragging) {
                    e.preventDefault();
                    e.stopPropagation();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;

                    element.style.transform = `translate(${currentX}px, ${currentY}px)`;
                }
            }

            function dragEnd(e) {
                // Prevent event from bubbling to PDF viewer
                e.stopPropagation();
                
                if (isResizing) {
                    isResizing = false;
                    element.style.cursor = 'move';
                    element.style.zIndex = '20';
                    resizeHandle = '';
                    element.classList.remove('resizing');
                    
                } else if (isDragging) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                    element.style.cursor = 'move';
                    element.style.zIndex = '20';
                }
            }
        }

        function addResizeHandles(element) {
            const handles = [
                { position: 'nw', cursor: 'nw-resize' },
                { position: 'n', cursor: 'n-resize' },
                { position: 'ne', cursor: 'ne-resize' },
                { position: 'e', cursor: 'e-resize' },
                { position: 'se', cursor: 'se-resize' },
                { position: 's', cursor: 's-resize' },
                { position: 'sw', cursor: 'sw-resize' },
                { position: 'w', cursor: 'w-resize' }
            ];

            handles.forEach(handle => {
                const handleElement = document.createElement('div');
                handleElement.className = 'resize-handle';
                handleElement.dataset.handle = handle.position;
                handleElement.style.cssText = `
                    position: absolute;
                    width: 12px;
                    height: 12px;
                    background: #ff6b35;
                    border: 2px solid white;
                    border-radius: 2px;
                    cursor: ${handle.cursor};
                    pointer-events: auto;
                    z-index: 25;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                `;

                // Position the handle
                switch (handle.position) {
                    case 'nw': handleElement.style.top = '-6px'; handleElement.style.left = '-6px'; break;
                    case 'n': handleElement.style.top = '-6px'; handleElement.style.left = '50%'; handleElement.style.transform = 'translateX(-50%)'; break;
                    case 'ne': handleElement.style.top = '-6px'; handleElement.style.right = '-6px'; break;
                    case 'e': handleElement.style.top = '50%'; handleElement.style.right = '-6px'; handleElement.style.transform = 'translateY(-50%)'; break;
                    case 'se': handleElement.style.bottom = '-6px'; handleElement.style.right = '-6px'; break;
                    case 's': handleElement.style.bottom = '-6px'; handleElement.style.left = '50%'; handleElement.style.transform = 'translateX(-50%)'; break;
                    case 'sw': handleElement.style.bottom = '-6px'; handleElement.style.left = '-6px'; break;
                    case 'w': handleElement.style.top = '50%'; handleElement.style.left = '-6px'; handleElement.style.transform = 'translateY(-50%)'; break;
                }

                element.appendChild(handleElement);
            });
        }

        function updateTextSize(element) {
            if (element.classList.contains('draggable-text-box')) {
                const width = element.offsetWidth;
                const height = element.offsetHeight;
                
                // Only adjust padding to maintain text centering, don't resize font
                const padding = Math.max(5, Math.min(width, height) / 10);
                element.style.padding = padding + 'px';
            }
        }

        // PDF Dragging and Zooming Functionality
        let isDragging = false;
        let lastMousePos = { x: 0, y: 0 };
        let currentTransform = { x: 0, y: 0, scale: 1 };
        let pdfViewer = null;
        let pdfContent = null;
        let pdfLocked = true; // PDF is locked by default when uploaded

        function initPDFDragging() {
            pdfViewer = document.getElementById('pdfViewer');
            pdfContent = document.getElementById('pdfContent');
            
            if (!pdfViewer || !pdfContent) return;

            // Mouse events for dragging
            pdfViewer.addEventListener('mousedown', startDragging);
            pdfViewer.addEventListener('mousemove', drag);
            pdfViewer.addEventListener('mouseup', stopDragging);
            pdfViewer.addEventListener('mouseleave', stopDragging);
            
            // Touch events for mobile
            pdfViewer.addEventListener('touchstart', startDraggingTouch);
            pdfViewer.addEventListener('touchmove', dragTouch);
            pdfViewer.addEventListener('touchend', stopDragging);
            
            // Wheel event for zooming
            pdfViewer.addEventListener('wheel', handleWheel);
            
            // Prevent context menu
            pdfViewer.addEventListener('contextmenu', e => e.preventDefault());
        }

        function startDragging(e) {
            // Don't start dragging if clicking on controls, if we're in editor mode, or if PDF is locked
            if (e.target.closest('.pdf-controls') || isEditorMode || pdfLocked) return;
            
            isDragging = true;
            lastMousePos = { x: e.clientX, y: e.clientY };
            pdfViewer.classList.add('dragging');
            e.preventDefault();
        }

        function startDraggingTouch(e) {
            if (e.target.closest('.pdf-controls') || isEditorMode || pdfLocked) return;
            
            isDragging = true;
            lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            pdfViewer.classList.add('dragging');
            e.preventDefault();
        }

        function drag(e) {
            if (!isDragging) return;
            
            const currentPos = { x: e.clientX, y: e.clientY };
            const deltaX = currentPos.x - lastMousePos.x;
            const deltaY = currentPos.y - lastMousePos.y;
            
            currentTransform.x += deltaX;
            currentTransform.y += deltaY;
            
            updatePDFTransform();
            lastMousePos = currentPos;
            e.preventDefault();
        }

        function dragTouch(e) {
            if (!isDragging) return;
            
            const currentPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            const deltaX = currentPos.x - lastMousePos.x;
            const deltaY = currentPos.y - lastMousePos.y;
            
            currentTransform.x += deltaX;
            currentTransform.y += deltaY;
            
            updatePDFTransform();
            lastMousePos = currentPos;
            e.preventDefault();
        }

        function stopDragging() {
            isDragging = false;
            pdfViewer.classList.remove('dragging');
        }

        function handleWheel(e) {
            if (isEditorMode || pdfLocked) return; // Don't zoom when editing or if PDF is locked
            
            e.preventDefault();
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(5, currentTransform.scale * zoomFactor));
            
            // Zoom towards mouse position
            const rect = pdfContent.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const scaleChange = newScale / currentTransform.scale;
            currentTransform.x = mouseX - (mouseX - currentTransform.x) * scaleChange;
            currentTransform.y = mouseY - (mouseY - currentTransform.y) * scaleChange;
            currentTransform.scale = newScale;
            
            updatePDFTransform();
        }

        function updatePDFTransform() {
            if (!pdfContent) return;
            
            pdfContent.style.transform = `translate(${currentTransform.x}px, ${currentTransform.y}px) scale(${currentTransform.scale})`;
            
            // Update zoom display
            const zoomDisplay = document.getElementById('zoomDisplay');
            if (zoomDisplay) {
                zoomDisplay.textContent = Math.round(currentTransform.scale * 100) + '%';
            }
            
            // Update editor canvas if it exists
            if (editorCanvas) {
                editorCanvas.setZoom(currentTransform.scale);
                editorCanvas.renderAll();
            }
        }

        function togglePDFLock() {
            pdfLocked = !pdfLocked;
            
            // Update cursor style
            if (pdfViewer) {
                pdfViewer.style.cursor = pdfLocked ? 'default' : 'grab';
            }
            
            // Update lock status display
            updatePDFLockStatus();
        }

        function updatePDFLockStatus() {
            // Create or update lock status indicator
            let lockIndicator = document.getElementById('pdfLockIndicator');
            if (!lockIndicator) {
                lockIndicator = document.createElement('div');
                lockIndicator.id = 'pdfLockIndicator';
                lockIndicator.style.cssText = `
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    background: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 4px 8px;
                    border-radius: 3px;
                    font-size: 10px;
                    z-index: 100;
                `;
                document.querySelector('.pdf-viewer').appendChild(lockIndicator);
            }
            
            lockIndicator.textContent = pdfLocked ? 'PDF Locked' : 'PDF Unlocked';
            lockIndicator.style.background = pdfLocked ? 'rgba(220, 53, 69, 0.8)' : 'rgba(40, 167, 69, 0.8)';
            lockIndicator.style.display = 'none'; // Hide lock indicator by default
            
            // Update lock button
            const lockBtn = document.getElementById('pdfLockBtn');
            if (lockBtn) {
                lockBtn.textContent = pdfLocked ? 'üîí' : 'üîì';
                lockBtn.title = pdfLocked ? 'Unlock PDF' : 'Lock PDF';
            }
        }

        function resetView() {
            currentTransform = { x: 0, y: 0, scale: 1 };
            updatePDFTransform();
        }

        function zoomIn() {
            const newScale = Math.min(5, currentTransform.scale * 1.2);
            currentTransform.scale = newScale;
            updatePDFTransform();
            updateOutlineOnZoom();
        }

        function zoomOut() {
            const newScale = Math.max(0.1, currentTransform.scale / 1.2);
            currentTransform.scale = newScale;
            updatePDFTransform();
            updateOutlineOnZoom();
        }

        function updateEditorStatus(message) {
            // Create status element if it doesn't exist
            let statusElement = document.getElementById('editorStatus');
            if (!statusElement) {
                statusElement = document.createElement('div');
                statusElement.id = 'editorStatus';
                statusElement.className = 'editor-status';
                document.querySelector('.viewer-container').appendChild(statusElement);
            }
            statusElement.textContent = message;
        }

        function saveLayout() {
            if (!editorCanvas) return;

            const layout = {
                page: {
                    size: 'A4',
                    orient: 'portrait'
                },
                objects: []
            };

            // Collect all objects
            editorCanvas.getObjects().forEach(obj => {
                const objectData = {
                    type: obj.type,
                    left: Math.round(obj.left),
                    top: Math.round(obj.top),
                    width: Math.round(obj.width || obj.scaleX * 100),
                    height: Math.round(obj.height || obj.scaleY * 100),
                    meta: obj.meta || {}
                };

                // Add type-specific properties
                if (obj.type === 'text') {
                    objectData.text = obj.text;
                    objectData.fontSize = obj.fontSize;
                    objectData.fontFamily = obj.fontFamily;
                    objectData.fill = obj.fill;
                } else if (obj.type === 'group') {
                    objectData.groupType = 'imagePlaceholder';
                }

                layout.objects.push(objectData);
            });

            // Create and download JSON file
            const jsonString = JSON.stringify(layout, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `layout-A4-portrait-${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            
            updateEditorStatus('Layout saved as JSON');
        }

        // Generate Sample PDF function
        async function generateSamplePDF() {
            try {
                // Create a new PDF document
                const pdfDoc = await PDFLib.PDFDocument.create();
                
                // Add a page
                const page = pdfDoc.addPage([595, 842]); // A4 size
                
                // Get the current ISO timestamp
                const timestamp = new Date().toISOString();
                
                // Add text to the page
                page.drawText(`Generated at ${timestamp}`, {
                    x: 50,
                    y: 750,
                    size: 20,
                    color: PDFLib.rgb(0, 0, 0)
                });
                
                // Add some sample content
                page.drawText('This is a sample PDF generated by PDF-lib', {
                    x: 50,
                    y: 700,
                    size: 14,
                    color: PDFLib.rgb(0.2, 0.2, 0.2)
                });
                
                page.drawText('You can use this as a template for testing', {
                    x: 50,
                    y: 670,
                    size: 12,
                    color: PDFLib.rgb(0.4, 0.4, 0.4)
                });
                
                // Save the PDF as bytes
                const pdfBytes = await pdfDoc.save();
                
                // Create a blob and download link
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                
                // Create and trigger download
                const link = document.createElement('a');
                link.href = url;
                link.download = `sample-${Date.now()}.pdf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the URL
                URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error generating sample PDF:', error);
                alert('Error generating sample PDF: ' + error.message);
            }
        }

        // Download PDFs function - Simplified Multiple Records
        async function downloadPdfs() {
            try {
                console.log('=== SIMPLIFIED MULTIPLE RECORDS PDF GENERATION ===');
                
                // Step 1: Validate inputs
                console.log('Step 1: Validating inputs...');
                if (!sessionState.templatePdfBytes) {
                    throw new Error('No PDF template loaded');
                }
                if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                    throw new Error('No CSV data loaded');
                }
                if (!sessionState.boxes || sessionState.boxes.length === 0) {
                    throw new Error('No text boxes configured');
                }
                console.log(`‚úì Inputs valid: ${sessionState.csvRows.length} CSV rows, ${sessionState.boxes.length} text boxes`);
                console.log(`Records per page: ${recordsPerPage}`);

                const downloadBtn = document.getElementById('downloadPdfsBtn');
                downloadBtn.disabled = true;
                downloadBtn.textContent = 'Generating PDFs...';

                // Step 2: Load JSZip and jsPDF
                console.log('Step 2: Loading libraries...');
                const JSZipScript = document.getElementById('jszip-cdn');
                if (!window.JSZip && !JSZipScript) {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                    script.id = 'jszip-cdn';
                    document.body.appendChild(script);
                    await new Promise(res => { script.onload = res; });
                } else if (!window.JSZip && JSZipScript) {
                    await new Promise(res => { JSZipScript.onload = res; });
                }
                console.log('‚úì JSZip loaded');

                const zip = new JSZip();
                const totalRecords = sessionState.csvRows.length;
                const totalPages = Math.ceil(totalRecords / recordsPerPage);

                try {
                    // Step 3: Process each page
                    for (let pageIndex = 0; pageIndex < totalPages; pageIndex++) {
                        console.log(`\n--- Processing Page ${pageIndex + 1}/${totalPages} ---`);
                        
                        // Calculate which records belong to this page
                        const startRecord = pageIndex * recordsPerPage;
                        const endRecord = Math.min(startRecord + recordsPerPage, totalRecords);
                        const recordsOnThisPage = endRecord - startRecord;
                        
                        console.log(`Records on this page: ${startRecord + 1} to ${endRecord} (${recordsOnThisPage} records)`);

                        // Step 3a: Set current page and update text boxes
                        currentPage = pageIndex;
                        updateAllTextBoxesWithCSVData();

                        // Step 3b: Capture the PDF area with text boxes
                        console.log('Step 3b: Capturing PDF area...');
                        const pdfViewer = document.getElementById('pdfViewer');
                        const canvas = document.getElementById('viewer');
                        
                        if (!pdfViewer || !canvas) {
                            throw new Error('PDF viewer not found');
                        }
                        
                        // Get PDF area dimensions
                        const canvasRect = canvas.getBoundingClientRect();
                        const viewerRect = pdfViewer.getBoundingClientRect();
                        const pdfAreaX = canvasRect.left - viewerRect.left;
                        const pdfAreaY = canvasRect.top - viewerRect.top;
                        const pdfAreaWidth = canvasRect.width;
                        const pdfAreaHeight = canvasRect.height;
                        
                        // Calculate high-quality scale factor
                        let scale = 6;
                        const img = canvas.querySelector('img');
                        if (img && img.naturalWidth && img.width) {
                            const originalScale = img.naturalWidth / img.width;
                            scale = Math.max(6, originalScale * 1.5);
                        }
                        scale = Math.max(4, Math.min(12, scale));
                        
                        // Step 3c: Capture the PDF area with current page data
                        console.log('Step 3c: Capturing PDF area...');
                        
                        const options = {
                            scale: scale,
                            useCORS: true,
                            allowTaint: true,
                            backgroundColor: null,
                            logging: false,
                            x: pdfAreaX,
                            y: pdfAreaY,
                            width: pdfAreaWidth,
                            height: pdfAreaHeight,
                            onclone: (clonedDoc) => {
                                const clonedViewer = clonedDoc.getElementById('pdfViewer');
                                if (clonedViewer) {
                                    // Hide UI elements
                                    const outline = clonedDoc.getElementById('pdfAreaOutline');
                                    if (outline) outline.style.display = 'none';
                                    
                                    const lockIndicator = clonedViewer.querySelector('.pdf-lock-indicator');
                                    if (lockIndicator) lockIndicator.style.display = 'none';
                                    
                                    // Remove borders and backgrounds
                                    const allBoxes = clonedViewer.querySelectorAll('.draggable-text-box');
                                    allBoxes.forEach(box => {
                                        box.style.border = 'none';
                                        box.style.background = 'transparent';
                                        box.style.boxShadow = 'none';
                                        box.style.outline = 'none';
                                    });
                                    
                                    // Remove resize handles (orange controllers)
                                    const resizeHandles = clonedViewer.querySelectorAll('.resize-handle');
                                    resizeHandles.forEach(handle => {
                                        handle.style.display = 'none';
                                    });
                                }
                            }
                        };
                        
                        await document.fonts.ready;
                        await new Promise(requestAnimationFrame);
                        
                        const capturedCanvas = await html2canvas(pdfViewer, options);
                        
                        // Step 3d: Convert to PDF
                        console.log('Step 3d: Converting to PDF...');
                        
                        // Load jsPDF if not already loaded
                        if (!window.jsPDF) {
                            const script = document.createElement('script');
                            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                            document.body.appendChild(script);
                            await new Promise(res => { script.onload = res; });
                        }
                        
                        const { jsPDF } = window.jspdf;
                        const pdf = new jsPDF({
                            orientation: 'portrait',
                            unit: 'px',
                            format: [pdfAreaWidth, pdfAreaHeight]
                        });
                        
                        // Convert canvas to image
                        const imgData = capturedCanvas.toDataURL('image/png', 1.0);
                        
                        // Add image to PDF
                        pdf.addImage(imgData, 'PNG', 0, 0, pdfAreaWidth, pdfAreaHeight);
                        
                        // Step 3e: Add to zip
                        const pdfBytes = pdf.output('blob');
                        const fileName = `page_${pageIndex + 1}_records_${startRecord + 1}-${endRecord}.pdf`;
                        zip.file(fileName, pdfBytes);
                        
                        console.log(`‚úì Page ${pageIndex + 1} added to zip: ${fileName}`);
                    }
                    
                    // Step 4: Download zip file
                    console.log('Step 4: Generating zip file...');
                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    
                    // Create download link
                    const url = URL.createObjectURL(zipBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `merged_pdfs_${totalRecords}_records.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    console.log('‚úì Download complete!');
                    
                } catch (error) {
                    console.error('Error during PDF generation:', error);
                    throw error;
                } finally {
                    // Restore original state
                    currentPage = 0;
                    updateAllTextBoxesWithCSVData();
                }
                
            } catch (error) {
                console.error('Download failed:', error);
                alert('Error generating PDFs: ' + error.message);
            } finally {
                // Restore button state
                const downloadBtn = document.getElementById('downloadPdfsBtn');
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'Download PDFs';
            }
        }

        // Generate From Template function
        async function generateFromTemplate() {
            try {
                if (!sessionState.templatePdfBytes) {
                    alert('Please select a PDF template first');
                    return;
                }

                // Load the template PDF using the Uint8Array copy
                const pdfDoc = await PDFLib.PDFDocument.load(sessionState.templatePdfBytes);
                
                // Embed the Helvetica Bold font
                const helveticaBoldFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);
                
                // Get the first page
                const pages = pdfDoc.getPages();
                if (pages.length === 0) {
                    throw new Error('Template PDF has no pages');
                }
                
                const page = pages[0];
                
                // Get current timestamp for demo data
                const timestamp = new Date().toISOString();
                const dateStr = new Date().toLocaleDateString();
                
                // Add text overlay at fixed positions
                page.drawText('TICKET #12345', {
                    x: 100,
                    y: 700,
                    size: 16,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0, 0, 0)
                });
                
                page.drawText(`Date: ${dateStr}`, {
                    x: 100,
                    y: 650,
                    size: 12,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0.2, 0.2, 0.2)
                });
                
                page.drawText(`Generated: ${timestamp}`, {
                    x: 100,
                    y: 620,
                    size: 10,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0.4, 0.4, 0.4)
                });
                
                // Add some sample fields
                page.drawText('Customer: John Doe', {
                    x: 100,
                    y: 580,
                    size: 12,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0, 0, 0)
                });
                
                page.drawText('Amount: $99.99', {
                    x: 100,
                    y: 550,
                    size: 14,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0.8, 0, 0)
                });
                
                page.drawText('Status: PAID', {
                    x: 100,
                    y: 520,
                    size: 12,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0, 0.6, 0)
                });
                
                // Save the modified PDF
                const pdfBytes = await pdfDoc.save();
                
                // Create a blob and download link
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                
                // Create and trigger download
                const link = document.createElement('a');
                link.href = url;
                link.download = `template-generated-${Date.now()}.pdf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the URL
                URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error generating from template:', error);
                alert('Error generating from template: ' + error.message);
            }
        }

        // CSV file input handler
        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                parseCSVFile(file);
            }
        });

        function parseCSVFile(file) {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        console.error('CSV parsing errors:', results.errors);
                        alert('Error parsing CSV file. Please check the file format.');
                        return;
                    }

                    // Store CSV data in session state and global variable
                    sessionState.csv = file;
                    sessionState.csvRows = results.data;
                    csvData = results.data;
                    currentRecord = 0;
                    
                    // Update status indicators
                    updateStatusIndicators();
                    
                    // Display preview
                    displayCSVPreview(results.data);
                    
                    // Show record navigation
                    showRecordNavigation();
                    
                    // Update file label
                    document.getElementById('csvLabel').textContent = file.name;
                    
                    // Update box editor if a box is selected
                    if (sessionState.selectedBox) {
                        updateBoxEditorValues(sessionState.selectedBox);
                    }
                    
                    // Update all text boxes with CSV data
                    updateAllTextBoxesWithCSVData();
                    
                    // Update download button state
                    updateDownloadButtonState();
                    
                    // Update records info
                    updateRecordsInfo();
                    
                    // Update create records button state
                    updateCreateRecordsButtonState();
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    alert('Error reading CSV file: ' + error.message);
                }
            });
        }

        function displayCSVPreview(data) {
            if (!data || data.length === 0) {
                document.getElementById('csvPreview').style.display = 'none';
                return;
            }

            const container = document.getElementById('csvTableContainer');
            const headers = Object.keys(data[0]);
            const previewRows = data.slice(0, 5); // First 5 rows

            // Create table HTML
            let tableHTML = '<table class="csv-table"><thead><tr>';
            
            // Add headers
            headers.forEach(header => {
                tableHTML += `<th>${header}</th>`;
            });
            tableHTML += '</tr></thead><tbody>';
            
            // Add data rows
            previewRows.forEach(row => {
                tableHTML += '<tr>';
                headers.forEach(header => {
                    const value = row[header] || '';
                    tableHTML += `<td>${value}</td>`;
                });
                tableHTML += '</tr>';
            });
            
            tableHTML += '</tbody></table>';
            
            container.innerHTML = tableHTML;
            
            // Update info text
            const totalRows = data.length;
            const shownRows = Math.min(5, totalRows);
            document.getElementById('csvInfo').textContent = 
                `Showing ${shownRows} of ${totalRows} rows. Headers: ${headers.join(', ')}`;
            
            // Show preview
            document.getElementById('csvPreview').style.display = 'block';
        }

        function toggleCSVPreview() {
            const csvPreview = document.getElementById('csvPreview');
            const csvToggle = document.querySelector('.csv-toggle');
            csvPreview.classList.toggle('expanded');
            csvToggle.textContent = csvPreview.classList.contains('expanded') ? 'Hide CSV' : 'CSV Preview';
        }

        function resetSession() {
            // Clear session state
            sessionState = {
                templatePdf: null,
                templatePdfBytes: null,
                csv: null,
                csvRows: [],
                layout: null,
                boxes: [],
                selectedBox: null
            };
            
            // Reset box counter
            boxCounter = 0;
            currentBoxId = null;
            
            // Clear editor canvas
            if (editorCanvas) {
                editorCanvas.clear();
            }
            
            // Hide box editor
            updateBoxEditor();

            // Clear current variables
            currentPdf = null;
            currentFile = null;
            serverPdfUrl = null;

            // Reset UI
            document.getElementById('fileLabel').textContent = 'Click to select PDF file';
            document.getElementById('downloadLink').style.display = 'none';
            document.getElementById('noPdf').style.display = 'block';
            document.getElementById('noPdf').innerHTML = `
                <h3>No PDF selected</h3>
                <p>Choose a PDF file to start viewing</p>
            `;
            document.getElementById('loadingPdf').style.display = 'none';
            document.getElementById('viewer').style.display = 'none';

            // Clear file inputs
            document.getElementById('pdfFile').value = '';
            document.getElementById('csvFile').value = '';
            document.getElementById('csvLabel').textContent = 'Click to select CSV file';
            document.getElementById('csvPreview').style.display = 'none';

            // Disable Generate From Template button
            document.getElementById('generateFromTemplateBtn').disabled = true;
            
            // Disable Download PDFs button
            const downloadBtn = document.getElementById('downloadPdfsBtn');
            if (downloadBtn) {
                downloadBtn.disabled = true;
            }

            // Update status indicators
            updateStatusIndicators();

            // Revoke any ObjectURLs if they exist
            if (serverPdfUrl && serverPdfUrl.startsWith('blob:')) {
                URL.revokeObjectURL(serverPdfUrl);
            }
        }

        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('collapsed');
        }

        // Font Management Functions
        function initializeFontHandling() {
            const fontUploadArea = document.getElementById('fontUploadArea');
            const fontUploadInput = document.getElementById('fontUploadInput');
            const addFontUrlBtn = document.getElementById('addFontUrlBtn');
            const fontUrlInput = document.getElementById('fontUrlInput');

            if (fontUploadArea && fontUploadInput) {
                fontUploadArea.addEventListener('click', () => fontUploadInput.click());
                fontUploadArea.addEventListener('dragover', e => {
                    e.preventDefault();
                    fontUploadArea.classList.add('dragover');
                });
                fontUploadArea.addEventListener('dragleave', e => {
                    e.preventDefault();
                    fontUploadArea.classList.remove('dragover');
                });
                fontUploadArea.addEventListener('drop', e => {
                    e.preventDefault();
                    fontUploadArea.classList.remove('dragover');
                    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                        handleFontUpload(e.dataTransfer.files[0]);
                    }
                });
                fontUploadInput.addEventListener('change', e => {
                    if (fontUploadInput.files && fontUploadInput.files[0]) {
                        handleFontUpload(fontUploadInput.files[0]);
                    }
                });
            }

            if (addFontUrlBtn && fontUrlInput) {
                addFontUrlBtn.addEventListener('click', handleGoogleFontUrl);
            }
        }

        function handleFontUpload(file) {
            const status = document.getElementById('fontUploadStatus');
            
            if (!file.name.match(/\.(ttf|otf)$/i)) {
                status.textContent = 'Only .ttf and .otf files are allowed.';
                status.className = 'font-status error';
                return;
            }
            
            status.textContent = 'Processing font...';
            status.className = 'font-status';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const base64 = e.target.result.split(',')[1];
                    const fontName = file.name.replace(/\.(ttf|otf)$/i, '');
                    const fileExtension = file.name.match(/\.(ttf|otf)$/i)[1].toLowerCase();
                    const format = fileExtension === 'ttf' ? 'truetype' : 'opentype';
                    
                    // Remove existing font-face if it exists
                    const existingStyle = document.getElementById(`font-face-${fontName}`);
                    if (existingStyle) {
                        existingStyle.remove();
                    }
                    
                    // Create @font-face rule with data URL
                    const style = document.createElement('style');
                    style.id = `font-face-${fontName}`;
                    style.textContent = `
                        @font-face {
                            font-family: '${fontName}';
                            src: url(data:font/${fileExtension};base64,${base64}) format('${format}');
                            font-display: swap;
                        }
                    `;
                    document.head.appendChild(style);
                    
                    // Add to available fonts if not already present
                    if (!availableFonts.includes(fontName)) {
                        availableFonts.push(fontName);
                        updateFontDropdown();
                    }
                    
                    // Set as default font for new text boxes
                    defaultFontFamily = fontName;
                    
                    // Update current text box if selected
                    if (sessionState.selectedBox && sessionState.selectedBox.type === 'text') {
                        sessionState.selectedBox.fontFamily = fontName;
                        updateTextBoxFont(sessionState.selectedBox);
                        // Update the dropdown to show the new font
                        document.getElementById('boxFontFamily').value = fontName;
                    }
                    
                    status.textContent = `Font "${fontName}" loaded successfully!`;
                    status.className = 'font-status success';
                    
                } catch (error) {
                    console.error('Error processing font:', error);
                    status.textContent = 'Error processing font file.';
                    status.className = 'font-status error';
                }
            };
            
            reader.onerror = function() {
                status.textContent = 'Error reading font file.';
                status.className = 'font-status error';
            };
            
            reader.readAsDataURL(file);
        }

        async function handleGoogleFontUrl() {
            const urlInput = document.getElementById('fontUrlInput');
            const status = document.getElementById('fontUrlStatus');
            const url = urlInput.value.trim();
            
            if (!url) {
                status.textContent = 'Please paste a Google Fonts URL.';
                status.className = 'font-status error';
                return;
            }
            
            if (url.includes('fonts.google.com/share')) {
                status.textContent = 'This is a share link. Please use the "Use on the web" link from Google Fonts.';
                status.className = 'font-status error';
                return;
            }
            
            status.textContent = 'Adding font...';
            status.className = 'font-status';
            
            if (url.startsWith('http') && url.includes('fonts.googleapis.com')) {
                let fontName = await getFontFamilyFromGoogleFontsUrl(url);
                if (!fontName) {
                    status.textContent = 'Could not determine font name. Please check the URL.';
                    status.className = 'font-status error';
                    return;
                }
                
                if (!document.querySelector(`link[href="${url}"]`)) {
                    const link = document.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = url;
                    document.head.appendChild(link);
                }
                
                if (!availableFonts.includes(fontName)) {
                    availableFonts.push(fontName);
                    updateFontDropdown();
                }
                
                // Update current text box if selected
                if (sessionState.selectedBox && sessionState.selectedBox.type === 'text') {
                    sessionState.selectedBox.fontFamily = fontName;
                    updateTextBoxFont(sessionState.selectedBox);
                    // Update the dropdown to show the new font
                    document.getElementById('boxFontFamily').value = fontName;
                }
                
                status.textContent = `Font "${fontName}" added successfully!`;
                status.className = 'font-status success';
                urlInput.value = '';
                
            } else {
                status.textContent = 'Please enter a valid Google Fonts URL.';
                status.className = 'font-status error';
            }
        }

        async function getFontFamilyFromGoogleFontsUrl(url) {
            try {
                const res = await fetch(url);
                const css = await res.text();
                const match = css.match(/font-family:\s*'([^']+)'/);
                if (match) {
                    return match[1];
                }
            } catch (e) {
                console.warn('Could not fetch Google Fonts CSS:', e);
            }
            
            // Fallback: try to parse from URL
            const urlMatch = url.match(/family=([^:&]+)/);
            if (urlMatch) {
                return decodeURIComponent(urlMatch[1]).replace(/\+/g, ' ').split(':')[0];
            }
            return '';
        }

        function updateFontDropdown() {
            const fontSelect = document.getElementById('boxFontFamily');
            if (!fontSelect) return;
            
            // Store current selection
            const currentValue = fontSelect.value;
            
            // Clear and rebuild options
            fontSelect.innerHTML = '';
            availableFonts.forEach(font => {
                const option = document.createElement('option');
                option.value = font;
                option.textContent = font;
                option.selected = font === currentValue;
                fontSelect.appendChild(option);
            });
        }

        function updateTextBoxFont(box) {
            if (!box || box.type !== 'text') return;
            
            const element = box.element;
            if (element) {
                element.style.fontFamily = `'${box.fontFamily}', Arial, sans-serif`;
                element.style.fontSize = (box.fontSize || 16) + 'px';
                element.style.color = box.color || '#000000';
                element.style.fontWeight = box.bold ? 'bold' : 'normal';
                element.style.fontStyle = box.italic ? 'italic' : 'normal';
                element.style.textDecoration = box.underline ? 'underline' : 'none';
                
                // Set text alignment and flex properties for consistent positioning
                element.style.textAlign = box.textAlign || 'center';
                element.style.justifyContent = box.textAlign === 'left' ? 'flex-start' : 
                                             box.textAlign === 'right' ? 'flex-end' : 'center';
                
                // Don't auto-resize - let user manually resize to reveal hidden text
                // This keeps text position consistent regardless of content length
            }
        }

        // CSV Data Binding Functions
        function showRecordNavigation() {
            const nav = document.getElementById('recordNavigation');
            if (csvData && csvData.length > 0) {
                nav.style.display = 'block';
                updateRecordInfo();
                
                // Add event listeners
                document.getElementById('prevRecord').onclick = () => {
                    if (currentRecord > 0) {
                        currentRecord--;
                        updateRecordInfo();
                        updateAllTextBoxesWithCSVData();
                        
                        // Update record display
                        updateRecordDisplay();
                    }
                };
                
                document.getElementById('nextRecord').onclick = () => {
                    if (currentRecord < csvData.length - 1) {
                        currentRecord++;
                        updateRecordInfo();
                        updateAllTextBoxesWithCSVData();
                        
                        // Update record display
                        updateRecordDisplay();
                    }
                };
            } else {
                nav.style.display = 'none';
            }
        }

        function updateRecordInfo() {
            const recordInfo = document.getElementById('recordInfo');
            if (csvData && csvData.length > 0) {
                recordInfo.textContent = `Record ${currentRecord + 1} of ${csvData.length}`;
            }
        }

        function updateAllTextBoxesWithCSVData() {
            sessionState.boxes.forEach(box => {
                if (box.type === 'text' && box.csvColumn) {
                    // Use current record for this text box
                    updateTextBoxWithCSVData(box);
                }
            });
        }

        function updateTextBoxWithCSVData(box) {
            if (!box || !box.element || !csvData) return;
            
            // Calculate which record this text box should show based on its position
            const boxIndex = sessionState.boxes.indexOf(box);
            const recordIndex = currentPage * recordsPerPage + boxIndex;
            
            if (recordIndex >= csvData.length) {
                // No more records, show empty
                updateTextBoxContentSafely(box.element, '');
                return;
            }
            
            const row = csvData[recordIndex];
            const text = row[box.csvColumn] || '';
            
            // Update the text content while preserving resize handles
            updateTextBoxContentSafely(box.element, text);
            
            // Apply formatting
            updateTextBoxFont(box);
        }
        
        function updateTextBoxWithMappedCSVData(box) {
            if (!box || !box.element || !csvData) return;
            
            const mappedRowIndex = textBoxMappings[box.id];
            if (mappedRowIndex === undefined || !csvData[mappedRowIndex]) return;
            
            const row = csvData[mappedRowIndex];
            const text = row[box.csvColumn] || '';
            
            // Update the text content while preserving resize handles
            updateTextBoxContentSafely(box.element, text);
            
            // Apply formatting
            updateTextBoxFont(box);
        }

        function updateTextBoxContent(box) {
            if (!box || !box.element) return;
            
            let text = '';
            
            if (box.csvColumn && csvData && csvData[currentRecord]) {
                // Use CSV data
                text = csvData[currentRecord][box.csvColumn] || '';
            } else {
                // Use static text
                text = box.staticText || 'Sample Text';
            }
            
            updateTextBoxContentSafely(box.element, text);
            updateTextBoxFont(box);
        }

        function updateTextBoxContentSafely(element, text) {
            if (!element) return;
            
            // Store resize handles
            const resizeHandles = Array.from(element.querySelectorAll('.resize-handle'));
            
            // Update text content
            element.textContent = text;
            
            // Restore resize handles
            resizeHandles.forEach(handle => {
                element.appendChild(handle);
            });
        }

        function autoResizeTextBox(box) {
            if (!box || !box.element) return;
            
            const element = box.element;
            const text = element.textContent;
            
            if (!text) return;
            
            // Create a temporary element to measure text dimensions
            const tempElement = document.createElement('div');
            tempElement.style.cssText = `
                position: absolute;
                visibility: hidden;
                white-space: nowrap;
                font-family: ${element.style.fontFamily || 'Arial, sans-serif'};
                font-size: ${element.style.fontSize || '16px'};
                font-weight: ${element.style.fontWeight || 'normal'};
                font-style: ${element.style.fontStyle || 'normal'};
                padding: ${element.style.padding || '5px'};
                box-sizing: border-box;
            `;
            tempElement.textContent = text;
            
            document.body.appendChild(tempElement);
            
            // Get the measured dimensions
            const textWidth = tempElement.offsetWidth;
            const textHeight = tempElement.offsetHeight;
            
            // Remove the temporary element
            document.body.removeChild(tempElement);
            
            // Calculate new box dimensions with some padding
            const padding = 10;
            const newWidth = Math.max(80, textWidth + padding * 2);
            const newHeight = Math.max(25, textHeight + padding * 2);
            
            // Update the box dimensions
            element.style.width = newWidth + 'px';
            element.style.height = newHeight + 'px';
            
            // Update the box data
            box.width = newWidth;
            box.height = newHeight;
            
            // Update the position inputs in the editor
            const widthInput = document.getElementById('boxWidth');
            const heightInput = document.getElementById('boxHeight');
            if (widthInput) widthInput.value = newWidth;
            if (heightInput) heightInput.value = newHeight;
        }
    </script>
</body>
</html>
