<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Viewer</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>📄</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" id="jszip-cdn"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
            padding: 20px;
        }

        .main-container {
            display: flex;
            height: calc(100vh - 40px);
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }

        .sidebar.collapsed {
            width: 50px;
        }

        .sidebar-header {
            background: #007bff;
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h1 {
            font-size: 16px;
            white-space: nowrap;
            overflow: hidden;
        }

        .toggle-sidebar {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            padding: 5px;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .sidebar.collapsed .sidebar-content {
            display: none;
        }

        .section {
            margin-bottom: 20px;
        }

        .section-header {
            font-size: 11px;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Enhanced Box Management Styles */
        .box-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .box-type-buttons {
            display: flex;
            gap: 4px;
        }

        .box-type-buttons .btn {
            flex: 1;
            margin-bottom: 0;
            font-size: 10px;
            padding: 6px 4px;
        }

        .box-editor {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 12px;
            margin-top: 8px;
            display: none;
        }

        .box-editor.active {
            display: block;
        }

        .box-editor h4 {
            font-size: 12px;
            margin-bottom: 8px;
            color: #333;
        }

        .form-group {
            margin-bottom: 8px;
        }

        .form-group label {
            display: block;
            font-size: 10px;
            font-weight: 500;
            color: #666;
            margin-bottom: 2px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 10px;
        }

        .form-group input[type="color"] {
            height: 24px;
            padding: 2px;
        }

        .form-row {
            display: flex;
            gap: 6px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .checkbox-group {
            display: flex;
            gap: 8px;
            margin-top: 4px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .checkbox-item label {
            font-size: 9px;
            margin: 0;
            color: #666;
        }

        /* Image Loading Progress Bar */
        .image-loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .image-loading-overlay.active {
            display: flex;
        }

        .image-loading-content {
            background: white;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .image-loading-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
        }

        .image-loading-subtitle {
            font-size: 14px;
            color: #666;
            margin-bottom: 25px;
        }

        .image-progress-container {
            background: #f0f0f0;
            border-radius: 20px;
            height: 8px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .image-progress-bar {
            background: linear-gradient(90deg, #007bff, #0056b3);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 20px;
        }

        .image-progress-text {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }

        .image-loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Font Upload Styles */
        .font-upload-area {
            border: 2px dashed #ccc;
            border-radius: 4px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .font-upload-area:hover {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .font-upload-area.dragover {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .font-upload-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .font-upload-content span {
            font-size: 20px;
        }

        .font-upload-content p {
            font-size: 10px;
            margin: 0;
            color: #666;
        }

        .google-font-input {
            display: flex;
            gap: 4px;
        }

        .google-font-input input {
            flex: 1;
            font-size: 10px;
        }

        .google-font-input button {
            font-size: 10px;
            padding: 4px 8px;
            white-space: nowrap;
        }

        .font-status {
            font-size: 9px;
            margin-top: 4px;
            min-height: 12px;
        }

        .font-status.success {
            color: #28a745;
        }

        .font-status.error {
            color: #dc3545;
        }

        .font-status.warning {
            color: #ffc107;
        }
        
        /* Collapsible Drawers */
        .drawer {
            border-bottom: 1px solid #e0e0e0;
            background: white;
            margin-bottom: 10px;
        }

        .drawer-header {
            padding: 12px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #333;
            transition: background-color 0.2s;
            font-size: 12px;
        }

        .drawer-header:hover {
            background: #e9ecef;
        }

        .drawer-header.active {
            background: #007bff;
            color: white;
        }

        .drawer-icon {
            transition: transform 0.3s;
            font-size: 14px;
        }

        .drawer-header.active .drawer-icon {
            transform: rotate(180deg);
        }

        .drawer-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: white;
        }

        /* Make file uploads drawer open by default */
        #uploadContent {
            max-height: 600px;
            overflow-y: auto;
        }

        .drawer-content.open {
            max-height: 600px;
            overflow-y: auto;
        }

        .drawer-content-inner {
            padding: 15px;
        }


        


        .style-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .style-checkboxes .checkbox-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
        }

        .style-checkboxes .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .style-checkboxes .checkbox-item span {
            color: #666;
        }

        /* Record Navigation Styles */
        .record-navigation {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
        }

        .nav-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .nav-controls button {
            padding: 4px 8px;
            font-size: 10px;
            min-width: 30px;
        }

        .nav-controls span {
            font-size: 10px;
            color: #666;
            flex: 1;
            text-align: center;
        }

        .box-actions {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }

        .box-actions .btn {
            flex: 1;
            margin-bottom: 0;
            font-size: 9px;
            padding: 4px 6px;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        /* CSV Preview Enhancement */
        .csv-preview {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            max-height: 120px;
            overflow-y: auto;
        }

        .csv-table {
            width: 100%;
            font-size: 9px;
            border-collapse: collapse;
        }

        .csv-table th,
        .csv-table td {
            padding: 2px 4px;
            border: 1px solid #e9ecef;
            text-align: left;
        }

        .csv-table th {
            background: #f8f9fa;
            font-weight: 600;
        }

        .csv-table td {
            max-width: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-input {
            display: block;
            width: 100%;
            padding: 8px;
            border: 2px dashed #ccc;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            text-align: center;
            transition: border-color 0.3s;
            font-size: 11px;
            margin-bottom: 8px;
        }

        .file-input:hover {
            border-color: #007bff;
        }

        .file-input input[type="file"] {
            display: none;
        }

        .btn {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-bottom: 6px;
            transition: background-color 0.3s;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #1e7e34;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .status-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #666;
        }



        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #f8f9fa;
            position: relative;
        }

        .content-header {
            background: white;
            border-bottom: 1px solid #e9ecef;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .content-header .download-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .content-header .download-buttons .btn {
            padding: 8px 16px;
            font-size: 12px;
            white-space: nowrap;
        }

        .content-header .download-buttons #deleteBoxBtn {
            padding: 8px 16px;
            font-size: 12px;
        }

        .content-header .download-buttons #downloadPdfsMessage {
            font-size: 11px;
            color: #6c757d;
            margin-left: 10px;
            white-space: nowrap;
        }

        .content-header h3 {
            font-size: 14px;
            color: #333;
        }

        .editor-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .editor-btn {
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: background-color 0.3s;
        }

        .editor-btn-primary {
            background: #007bff;
            color: white;
        }

        .editor-btn-primary:hover {
            background: #0056b3;
        }

        .editor-btn-secondary {
            background: #6c757d;
            color: white;
        }

        .editor-btn-secondary:hover {
            background: #545b62;
        }

        .editor-btn-success {
            background: #28a745;
            color: white;
        }

        .editor-btn-success:hover {
            background: #1e7e34;
        }

        .editor-btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .editor-btn-warning:hover {
            background: #e0a800;
        }

        .editor-btn-danger {
            background: #dc3545;
            color: white;
        }

        .editor-btn-danger:hover {
            background: #c82333;
        }

        .editor-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .viewer-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #f0f0f0;
        }

        .pdf-viewer {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
        }

        .pdf-viewer.dragging {
            cursor: grabbing;
        }
        
        .pdf-area-outline {
            position: absolute;
            border: 2px dashed #ff6b6b;
            background: transparent;
            pointer-events: none;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .pdf-area-outline.active {
            border-color: #4ecdc4;
            background: transparent;
        }
        
        .simple-multiple-records {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .simple-multiple-records h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }
        
        .records-info {
            margin-top: 10px;
            padding: 8px 12px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 12px;
            color: #495057;
            font-weight: 500;
        }
        
        .multiple-textboxes-section {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .multiple-textboxes-section h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }
        
        .multiple-textboxes-section h4 {
            margin: 10px 0 10px 0;
            font-size: 14px;
            color: #555;
        }
        
        .textbox-mapping-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        .textbox-mapping-item label {
            font-size: 12px;
            color: #666;
            min-width: 40px;
        }
        
        .textbox-mapping-item select {
            flex: 1;
            font-size: 12px;
            padding: 4px;
        }

        .pdf-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            transition: transform 0.1s ease;
        }



        .pdf-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }

        .pdf-control-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s;
        }

        .pdf-control-btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }
        
        /* Enhanced zoom transitions for boxes */
        .draggable-text-box,
        .draggable-image-box {
            transition: transform 0.2s ease-out;
        }
        
        /* Smooth zoom transitions */
        .pdf-content {
            transition: transform 0.2s ease-out;
        }

        .pdf-control-btn:disabled {
            background: rgba(0, 0, 0, 0.3);
            cursor: not-allowed;
        }

        .zoom-display {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            min-width: 60px;
            text-align: center;
        }

        .no-pdf {
            text-align: center;
            color: #666;
            padding: 40px;
        }

        .no-pdf h3 {
            margin-bottom: 10px;
            color: #333;
        }

        #viewer {
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            background: white;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            border: 2px solid red; /* Temporary debug border */
        }

        .loading {
            text-align: center;
            color: #666;
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Layout Editor Styles */
        .editor-sidebar {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 250px;
            background: white;
            border-left: 1px solid #ddd;
            padding: 15px;
            overflow-y: auto;
            display: none;
            box-shadow: -2px 0 8px rgba(0,0,0,0.1);
        }

        .editor-sidebar.active {
            display: block;
        }

        .editor-sidebar h4 {
            font-size: 12px;
            margin-bottom: 10px;
            color: #333;
        }

        .editor-form-group {
            margin-bottom: 10px;
        }

        .editor-form-group label {
            display: block;
            margin-bottom: 3px;
            font-size: 10px;
            color: #666;
        }

        .editor-form-group input, .editor-form-group select, .editor-form-group textarea {
            width: 100%;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 10px;
        }

        .editor-form-group textarea {
            height: 40px;
            resize: vertical;
        }

        .grid-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .grid-toggle label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            cursor: pointer;
        }

        .grid-toggle input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .editor-status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
        }

        /* Fabric.js canvas styling */
        .canvas-container {
            position: relative;
            display: inline-block;
        }

        #editorCanvas {
            border: 1px solid #ddd;
            background: transparent;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: auto;
            z-index: 10;
        }

        /* Visual feedback for placement mode */
        .placement-mode {
            background: rgba(0, 123, 255, 0.1) !important;
            border: 2px dashed #007bff !important;
        }

        /* Enhanced text box styles */
        .draggable-text-box {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #007bff;
            padding: 5px;
            cursor: move;
            min-width: 20px;
            min-height: 15px;
            font-family: Arial, sans-serif;
            font-size: 16px;
            color: #000;
            text-align: center;
            user-select: none;
            z-index: 20;
            transition: all 0.1s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: block;
            overflow: hidden;
            word-wrap: break-word;
            white-space: normal;
            line-height: 1.2;
        }

        .draggable-text-box.selected .resize-handle {
            background: #007bff !important;
        }



        /* Image box styles - matching MERGE-ONLINE behavior */
        .draggable-image-box {
            position: absolute;
            border: 2px dashed #007bff;
            background: rgba(255,255,255,0.2);
            cursor: move;
            z-index: 10;
            overflow: hidden;
            min-width: 40px;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .draggable-image-box.selected {
            border: 2px solid #007bff;
            background: rgba(0,123,255,0.08);
        }

        .draggable-image-box.selected .resize-handle {
            background: #007bff !important;
        }

        .draggable-image-box img {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            object-fit: contain !important;
            object-position: center;
            aspect-ratio: auto;
            image-rendering: auto;
        }
        
        /* Force aspect ratio preservation for all image box sizes */
        .draggable-image-box img[style*="object-fit"] {
            object-fit: contain !important;
            object-position: center !important;
            aspect-ratio: auto !important;
        }

        /* Ensure resize handles are visible for image boxes */
        .draggable-image-box .resize-handle {
            display: block !important;
            opacity: 1 !important;
        }

        .draggable-text-box:hover {
            border-color: #0056b3;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .draggable-text-box:focus {
            outline: none;
            border-color: #28a745;
            box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.25);
        }

        .draggable-text-box.resizing {
            border-color: #ff6b35;
            box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.25);
        }



        /* Snap-to-Grid Styles */
        .snap-guide {
            position: absolute;
            background: #007bff;
            opacity: 0.6;
            z-index: 1000;
            pointer-events: none;
            transition: opacity 0.1s ease;
        }

        .snap-guide.vertical {
            width: 1px;
            height: 100%;
        }

        .snap-guide.horizontal {
            width: 100%;
            height: 1px;
        }

        .snap-guide.active {
            opacity: 0.8;
            background: #28a745;
        }


    </style>
</head>
<body>
    <!-- Image Loading Progress Overlay -->
    <div class="image-loading-overlay" id="imageLoadingOverlay">
        <div class="image-loading-content">
            <div class="image-loading-title">
                <span class="image-loading-spinner"></span>
                Loading Images...
            </div>
            <div class="image-loading-subtitle" id="imageLoadingSubtitle">
                Preparing images for PDF generation
            </div>
            <div class="image-progress-container">
                <div class="image-progress-bar" id="imageProgressBar"></div>
            </div>
            <div class="image-progress-text" id="imageProgressText">0%</div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-content">


                <!-- File Uploads -->
                <div class="section">
                    <div class="form-group">
                    <label class="file-input" for="pdfFile">
                        <input type="file" id="pdfFile" accept="application/pdf">
                            <div id="fileLabel">📄 Click to select PDF file</div>
                    </label>
                    </div>
                    
                    <div class="form-group">
                    <label class="file-input" for="csvFile">
                        <input type="file" id="csvFile" accept=".csv,text/csv">
                            <div id="csvLabel">📊 Click to select CSV file</div>
                    </label>
                    </div>
                </div>

                <!-- Add Box Buttons (Above Layout Editor) -->
                <div class="section" style="margin-bottom: 20px;">
                    <div class="box-type-buttons" style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="btn btn-primary" onclick="addText()">Add Text Box(es)</button>
                        <button class="btn btn-secondary" onclick="addImagePlaceholder()">Add Image Box(es)</button>
                    </div>
                    
                    <!-- Box Count Selection -->
                    <div class="form-group" style="margin-top: 10px;">
                        <label>Number of Boxes:</label>
                        <select id="boxCountSelect" class="form-control">
                            <option value="1">1 Box</option>
                            <option value="2">2 Boxes</option>
                            <option value="3">3 Boxes</option>
                            <option value="4">4 Boxes</option>
                            <option value="5">5 Boxes</option>
                            <option value="6">6 Boxes</option>
                            <option value="8">8 Boxes</option>
                            <option value="10">10 Boxes</option>
                            <option value="12">12 Boxes</option>
                            <option value="15">15 Boxes</option>
                            <option value="20">20 Boxes</option>
                            </select>
                            </div>
                        </div>
                        
                        <!-- Page Navigation -->
                <div id="pageNavigation" class="page-navigation" style="border-top: 1px solid #e9ecef; padding: 12px; background: #f8f9fa; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
                        <button id="prevPageBtn" class="btn btn-sm btn-outline-secondary" onclick="previousPage()" style="font-size: 11px; padding: 4px 8px; min-width: 60px;">
                            ← Prev
                                </button>
                        <div style="text-align: center; flex: 1;">
                            <div id="pageInfo" style="font-size: 11px; color: #495057; font-weight: 500;">
                                    Page 1 of 1
                            </div>
                            <div id="pageRecordsInfo" style="font-size: 10px; color: #6c757d;">
                                Records 1-4
                            </div>
                        </div>
                        <button id="nextPageBtn" class="btn btn-sm btn-outline-secondary" onclick="nextPage()" style="font-size: 11px; padding: 4px 8px; min-width: 60px;">
                            Next →
                        </button>
                    </div>
                </div>

                <!-- Compact Layout Editor -->
                <div class="section">
                    <!-- Font Upload -->
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label style="font-size: 12px; font-weight: bold; color: #333;">Add Font:</label>
                        <div class="font-upload-area" id="fontUploadArea" style="height: 50px; font-size: 11px; border: 2px dashed #007bff; border-radius: 6px; background: #f8f9fa; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease;">
                            <input type="file" id="fontUploadInput" accept=".ttf,.otf" style="display: none;">
                            <div class="font-upload-content" style="text-align: center;">
                                <p style="margin: 0; font-size: 11px; color: #495057;">Drop TTF/OTF file here or click to browse</p>
                            </div>
                        </div>
                        <div id="fontUploadStatus" class="font-status" style="font-size: 10px;"></div>
                        </div>
                        
                    <!-- CSV Column Selection -->
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label style="font-size: 12px; font-weight: bold;">CSV Column:</label>
                        <select id="boxColumnSelect" class="form-control" style="font-size: 11px; padding: 4px 8px;">
                                        <option value="">Select CSV column...</option>
                                    </select>
                                </div>
                                
                    <!-- Apply Mode Toggle -->
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label style="font-size: 12px; font-weight: bold;">Apply To:</label>
                        <div style="display: flex; gap: 4px;">
                            <button type="button" id="applyToAllBtn" class="btn btn-sm btn-primary" style="flex: 1; font-size: 10px; padding: 4px 6px;" onclick="setApplyMode('all')">All Boxes</button>
                            <button type="button" id="applyToSelectedBtn" class="btn btn-sm btn-outline-secondary" style="flex: 1; font-size: 10px; padding: 4px 6px;" onclick="setApplyMode('selected')">Selected Only</button>
                                </div>
                                </div>
                                
                    <!-- Compact Formatting Controls -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 11px;">Font:</label>
                            <select id="formatAllFontFamily" class="form-control" style="font-size: 11px; padding: 4px 6px;" onchange="applyLiveFormatting()">
                                        <option value="Arial">Arial</option>
                                        <option value="Helvetica">Helvetica</option>
                                <option value="Times New Roman">Times New Roman</option>
                                        <option value="Georgia">Georgia</option>
                                        <option value="Verdana">Verdana</option>
                                        <option value="Courier New">Courier New</option>
                                <option value="Impact">Impact</option>
                                <option value="Comic Sans MS">Comic Sans MS</option>
                                    </select>
                                </div>
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 11px;">Size:</label>
                            <input type="number" id="formatAllFontSize" class="form-control" value="16" min="1" max="72" style="font-size: 11px; padding: 4px 6px;" onchange="applyLiveFormatting()">
                                    </div>
                                </div>
                                
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 11px;">Color:</label>
                            <input type="color" id="formatAllTextColor" class="form-control" value="#000000" style="height: 30px; padding: 2px;" onchange="applyLiveFormatting()">
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 11px;">Align:</label>
                            <select id="formatAllTextAlign" class="form-control" style="font-size: 11px; padding: 4px 6px;" onchange="applyLiveFormatting()">
                                        <option value="left">Left</option>
                                        <option value="center" selected>Center</option>
                                        <option value="right">Right</option>
                                <option value="justify">Justify</option>
                                    </select>
                        </div>
                                </div>
                                
                    <!-- Text Style Buttons -->
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label style="font-size: 11px;">Style:</label>
                        <div style="display: flex; gap: 4px;">
                                            <button type="button" id="formatAllBold" class="btn btn-sm btn-outline-secondary" style="flex: 1; font-size: 10px; padding: 4px 6px;">B</button>
                <button type="button" id="formatAllItalic" class="btn btn-sm btn-outline-secondary" style="flex: 1; font-size: 10px; padding: 4px 6px;">I</button>
                <button type="button" id="formatAllUnderline" class="btn btn-sm btn-outline-secondary" style="flex: 1; font-size: 10px; padding: 4px 6px;">U</button>
                                    </div>
                                </div>

                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 6px; margin-bottom: 10px;">
                                </div>
                            </div>
                            




                <!-- Download Link Section -->
                <div class="download-section" style="border-top: 1px solid #e9ecef; padding: 15px; background: #f8f9fa; margin-bottom: 15px;">
                    <div id="downloadLink" style="display: none;">
                        <a id="downloadAnchor" href="#" target="_blank" class="btn btn-primary" style="text-decoration: none; display: inline-block; width: 100%;">Download Original PDF</a>
                    </div>
                </div>
                            



            </div>
        </div>

        <div class="main-content">
            <div class="content-header">
                <h3>PDF Viewer</h3>
                <div class="download-buttons">
                    <button id="screenshotBtn" class="btn btn-primary" onclick="downloadCurrentPdf()">
                        📄 Download Current PDF
                    </button>
                    
                    <button id="downloadPdfsBtn" class="btn btn-success" onclick="downloadPdfs()" disabled>
                        Download PDFs
                    </button>
                    <div id="downloadPdfsMessage" class="text-muted" style="display: none;">
                        Multiple boxes detected. Use single page download instead.
                    </div>
                    
                    <button class="btn btn-danger" onclick="deleteSelectedBox()" id="deleteBoxBtn" disabled title="Delete selected box (or press Delete key)">
                        🗑️ Delete
                    </button>
                </div>
            </div>

            <div class="viewer-container">
                <div id="noPdf" class="no-pdf">
                    <h3>No PDF selected</h3>
                    <p>Choose a PDF file to start viewing</p>
                </div>

                <div id="loadingPdf" class="loading" style="display: none;">
                    <div class="spinner"></div>
                    <p>Loading PDF...</p>
                </div>

                <div id="pdfViewer" class="pdf-viewer" style="display: none;">
                    <div class="pdf-controls">
                        <button class="pdf-control-btn" onclick="resetView()" title="Reset View">⌂</button>
                        <button class="pdf-control-btn" onclick="zoomIn()" title="Zoom In">+</button>
                        <button class="pdf-control-btn" onclick="zoomOut()" title="Zoom Out">−</button>
                        <button class="pdf-control-btn" onclick="togglePDFLock()" title="Toggle PDF Lock" id="pdfLockBtn">🔒</button>
                        <div class="zoom-display" id="zoomDisplay">100%</div>
                    </div>
                    
                                    <div class="pdf-content" id="pdfContent">
                    <canvas id="viewer"></canvas>
                        <canvas id="editorCanvas" style="display: none;"></canvas>
                    <div id="pdfAreaOutline" class="pdf-area-outline" style="display: none;"></div>
                </div>
                </div>
            </div>



            <!-- Editor Properties Sidebar -->
            <div id="editorSidebar" class="editor-sidebar">
                <h4>Object Properties</h4>
                
                <div class="editor-form-group">
                    <label>Bind to CSV Field:</label>
                    <select id="bindField">
                        <option value="">None (Static)</option>
                        <option value="title">Title</option>
                        <option value="subtitle">Subtitle</option>
                        <option value="price">Price</option>
                        <option value="features">Features</option>
                        <option value="image">Image</option>
                    </select>
                </div>

                <div class="editor-form-group">
                    <label>Static Content:</label>
                    <textarea id="staticContent" placeholder="Enter static text content..."></textarea>
                </div>

                <div class="editor-form-group">
                    <label>Position X:</label>
                    <input type="number" id="posX" step="1">
                </div>

                <div class="editor-form-group">
                    <label>Position Y:</label>
                    <input type="number" id="posY" step="1">
                </div>

                <div class="editor-form-group">
                    <label>Width:</label>
                    <input type="number" id="width" step="1">
                </div>

                <div class="editor-form-group">
                    <label>Height:</label>
                    <input type="number" id="height" step="1">
                </div>
            </div>
            
        </div>
    </div>

    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let currentPdf = null;
        let currentFile = null;
        let serverPdfUrl = null;

        // Session state management
        let sessionState = {
            templatePdf: null,
            templatePdfBytes: null,
            csv: null,
            csvRows: [],
            layout: null,
            boxes: [],
            selectedBox: null,
            // File metadata for change detection
            pdfMetadata: null,
            csvMetadata: null,
            // Live file monitoring
            liveMonitoringEnabled: false
        };

        // Enhanced box management system
        let boxCounter = 0;
        let currentBoxId = null;
        
        // Font management system
        let availableFonts = ['Arial', 'Times New Roman', 'Helvetica', 'Georgia', 'Verdana', 'Courier New'];
// Initialize sessionState fonts
if (!sessionState.availableFonts) {
    sessionState.availableFonts = [...availableFonts];
}
if (!sessionState.defaultFontFamily) {
    sessionState.defaultFontFamily = 'Arial';
}
        let loadedFonts = {};
        let defaultFontFamily = 'Arial';
        
        // CSV data management
        let currentRecord = 0;
        let csvData = null;

        // Editor canvas management
        let editorCanvas = null;
        
        // PDF viewer management
        let pdfViewer = null;
        let pdfContent = null;
        let pdfLocked = true; // PDF is locked by default when uploaded
        let isEditorMode = false;
        
        // PDF transform management
        let currentTransform = { x: 0, y: 0, scale: 1 };
        
        // PDF dragging state
        let isDragging = false;
        let lastMousePos = { x: 0, y: 0 };


        
        // Initialize editor canvas
        function initEditorCanvas() {
            if (editorCanvas) return; // Already initialized
            
            const canvasElement = document.getElementById('editorCanvas');
            if (!canvasElement) {
                console.error('Editor canvas element not found');
                return;
            }
            
            // Set canvas size to match PDF viewer
            const pdfViewer = document.getElementById('pdfViewer');
            if (pdfViewer) {
                const rect = pdfViewer.getBoundingClientRect();
                canvasElement.width = rect.width;
                canvasElement.height = rect.height;
            }
            
            // Initialize Fabric.js canvas
            editorCanvas = new fabric.Canvas('editorCanvas', {
                selection: true,
                preserveObjectStacking: true
            });
            
            // Set canvas position to overlay PDF
            canvasElement.style.position = 'absolute';
            canvasElement.style.top = '20px';
            canvasElement.style.left = '20px';
            canvasElement.style.pointerEvents = 'auto';
            canvasElement.style.zIndex = '15';
            
            // Make canvas visible when in editor mode
            canvasElement.style.display = 'block';
            
            // Set Fabric.js canvas dimensions to match
            editorCanvas.setDimensions({
                width: canvasElement.width,
                height: canvasElement.height
            });
            
            console.log('Editor canvas initialized');
        }

        // File input handler
        document.getElementById('pdfFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                currentFile = file;
                document.getElementById('fileLabel').textContent = file.name;
                 
                 // Store file metadata for change detection
                 sessionState.pdfMetadata = {
                     name: file.name,
                     lastModified: file.lastModified,
                     size: file.size
                 };
                
                // Hide download link
                document.getElementById('downloadLink').style.display = 'none';
                serverPdfUrl = null;

                // Automatically load and preview the PDF
                loadPdf(file);
            }
        });



        async function loadPdf(file) {
            try {
                console.log('Loading PDF file:', file.name);
                
                // Show loading state
                document.getElementById('noPdf').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'none';
                document.getElementById('loadingPdf').style.display = 'block';

                // Cancel any ongoing rendering operations
                if (window.currentRenderTask) {
                    try {
                        await window.currentRenderTask.cancel();
                        console.log('Cancelled previous render task');
                    } catch (cancelError) {
                        console.log('Previous render task already completed or cancelled');
                    }
                    window.currentRenderTask = null;
                }
                
                // Clear the canvas
                const canvas = document.getElementById('viewer');
                if (canvas) {
                    const context = canvas.getContext('2d');
                    context.clearRect(0, 0, canvas.width, canvas.height);
                }
                
                // Reset current PDF
                currentPdf = null;

                // Read file as ArrayBuffer
                const arrayBuffer = await file.arrayBuffer();

                // Create a separate copy for PDF-lib BEFORE loading with PDF.js
                const templateBytes = new Uint8Array(arrayBuffer).slice();

                // Load PDF document
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                
                // Store PDF info
                currentPdf = pdf;

                // Update session state with the separate copy
                sessionState.templatePdf = pdf;
                sessionState.templatePdfBytes = templateBytes;
                


                // Enable Generate From Template button
                // generateFromTemplateBtn was removed
                
                // Enable Download PDFs button if CSV and boxes are also loaded
                updateDownloadButtonState();
                
                // Update records info
                updateRecordsInfo();

                // Render the page (always page 1 for single-page PDFs)
                await renderPage(1);

                // Initialize simple editor after PDF is loaded
                initEditor();

                // Hide loading and noPdf message, show PDF viewer
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'block';
                
                // Initialize PDF dragging functionality
                initPDFDragging();
                
                // Initialize PDF lock status
                updatePDFLockStatus();
                
                // Update PDF area outline
                updatePdfAreaOutline();

            } catch (error) {
                console.error('Error loading PDF:', error);
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'block';
                document.getElementById('noPdf').innerHTML = `
                    <h3>Error loading PDF</h3>
                    <p>${error.message}</p>
                `;
            }
        }

        async function loadPdfFromUrl(url) {
            try {
                // Fetch PDF from server
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Failed to fetch PDF from server');
                }
                
                const arrayBuffer = await response.arrayBuffer();

                // Load PDF document
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                
                // Store PDF info
                currentPdf = pdf;

                // Update session state
                sessionState.templatePdf = pdf;
                sessionState.templatePdfBytes = arrayBuffer.slice(0); // Create a copy to avoid detachment

                // Render the page (always page 1 for single-page PDFs)
                await renderPage(1);

                // Hide loading and noPdf message, show PDF viewer
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'none';
                document.getElementById('pdfViewer').style.display = 'block';
                
                // Initialize PDF dragging functionality
                initPDFDragging();

            } catch (error) {
                console.error('Error loading PDF from URL:', error);
                document.getElementById('loadingPdf').style.display = 'none';
                document.getElementById('noPdf').style.display = 'block';
                document.getElementById('noPdf').innerHTML = `
                    <h3>Error loading PDF</h3>
                    <p>${error.message}</p>
                `;
            }
        }

        async function renderPage(pageNumber) {
            if (!currentPdf) return;

            try {
                // Cancel any ongoing rendering operations
                if (window.currentRenderTask) {
                    try {
                        await window.currentRenderTask.cancel();
                        console.log('Cancelled previous render task');
                    } catch (cancelError) {
                        console.log('Previous render task already completed or cancelled');
                    }
                }

                // Get page
                const page = await currentPdf.getPage(pageNumber);

                // Set up canvas
                const canvas = document.getElementById('viewer');
                const context = canvas.getContext('2d');

                // Clear the canvas first
                context.clearRect(0, 0, canvas.width, canvas.height);

                // Render PDF at original quality without scaling down
                const viewport = page.getViewport({scale: 1.0});
                
                // Enable high-quality rendering
                context.imageSmoothingEnabled = true;
                context.imageSmoothingQuality = 'high';

                // Set canvas dimensions to original PDF size
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                // Set canvas display size to fit viewer while maintaining aspect ratio
                const viewerContainer = document.querySelector('.viewer-container');
                const containerWidth = viewerContainer.clientWidth;
                const containerHeight = viewerContainer.clientHeight;
                
                const scaleX = containerWidth / viewport.width;
                const scaleY = containerHeight / viewport.height;
                const displayScale = Math.min(scaleX, scaleY, 1.0); // Don't scale up, only down
                
                canvas.style.width = (viewport.width * displayScale) + 'px';
                canvas.style.height = (viewport.height * displayScale) + 'px';

                // Make sure canvas is visible
                canvas.style.display = 'block';

                // Render page at original quality
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };

                // Store the render task so it can be cancelled if needed
                window.currentRenderTask = page.render(renderContext);
                await window.currentRenderTask.promise;

                // Debug canvas visibility after rendering
                const canvasRect = canvas.getBoundingClientRect();
                console.log('Canvas rendered successfully!');
                console.log('Canvas bounding rect:', canvasRect);
                console.log('Canvas computed styles:', {
                    position: getComputedStyle(canvas).position,
                    top: getComputedStyle(canvas).top,
                    left: getComputedStyle(canvas).left,
                    width: getComputedStyle(canvas).width,
                    height: getComputedStyle(canvas).height,
                    zIndex: getComputedStyle(canvas).zIndex,
                    display: getComputedStyle(canvas).display,
                    visibility: getComputedStyle(canvas).visibility
                });

                // Update editor canvas size to match the rendered PDF
                if (typeof editorCanvas !== 'undefined' && editorCanvas) {
                    updateEditorPageSize();
                }

                console.log('PDF rendered at original quality:', viewport.width, 'x', viewport.height);

            } catch (error) {
                console.error('Error rendering page:', error);
            }
        }
        
        // Update editor canvas size to match PDF
        function updateEditorPageSize() {
            if (!editorCanvas) return;
            
            const canvas = document.getElementById('viewer');
            const canvasElement = document.getElementById('editorCanvas');
            
            if (canvas && canvasElement) {
                // Get the display size of the PDF canvas
                const displayWidth = parseInt(canvas.style.width) || canvas.width;
                const displayHeight = parseInt(canvas.style.height) || canvas.height;
                
                // Update editor canvas size to match
                canvasElement.width = displayWidth;
                canvasElement.height = displayHeight;
                
                // Update Fabric.js canvas dimensions
                editorCanvas.setDimensions({
                    width: displayWidth,
                    height: displayHeight
                });
                
                // Re-render the canvas
                editorCanvas.renderAll();
                
                console.log('Editor canvas resized to:', displayWidth, 'x', displayHeight);
            }
        }

        // Drag and drop support
        const uploadArea = document.querySelector('.sidebar');
        const fileInput = document.getElementById('pdfFile');

        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.style.backgroundColor = '#e3f2fd';
        });

        uploadArea.addEventListener('dragleave', function(e) {
            e.preventDefault();
            uploadArea.style.backgroundColor = '';
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.style.backgroundColor = '';
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                fileInput.files = files;
                currentFile = files[0];
                document.getElementById('fileLabel').textContent = files[0].name;
                 
                 // Store file metadata for change detection
                 sessionState.pdfMetadata = {
                     name: files[0].name,
                     lastModified: files[0].lastModified,
                     size: files[0].size
                 };
                
                // Hide download link
                document.getElementById('downloadLink').style.display = 'none';
                serverPdfUrl = null;

                // Automatically load and preview the PDF
                loadPdf(files[0]);
            }
        });


        
        // Initialize snap-to-grid toggle
        const snapToGridToggle = document.getElementById('snapToGridToggle');
        if (snapToGridToggle) {
            snapToGridToggle.addEventListener('change', function() {
                snapToGridEnabled = this.checked;
                console.log('Snap to grid:', snapToGridEnabled ? 'enabled' : 'disabled');
            });
        }
        
        // Function to update download button state
        function updateDownloadButtonState() {
            const hasTemplate = sessionState.templatePdfBytes !== null;
            const hasCSV = sessionState.csvRows.length > 0;
            const hasBoxes = sessionState.boxes.length > 0;
            const boxCount = sessionState.boxes.length;
            
            const downloadBtn = document.getElementById('downloadPdfsBtn');
            const messageDiv = document.getElementById('downloadPdfsMessage');
            
            console.log('updateDownloadButtonState called:', {
                hasTemplate,
                hasCSV,
                hasBoxes,
                boxCount,
                shouldDisable: !(hasTemplate && hasCSV && hasBoxes) || boxCount > 1
            });
            
            if (downloadBtn) {
                // Disable "Download PDFs" button if more than one box is present
                // This prevents bulk PDF generation with multiple boxes
                // Single page downloads (screenshot, current page) remain active
                const shouldDisable = !(hasTemplate && hasCSV && hasBoxes) || boxCount > 1;
                downloadBtn.disabled = shouldDisable;
                
                // Update button text to indicate why it's disabled
                if (boxCount > 1) {
                    downloadBtn.title = 'Multiple boxes detected. Use single page download instead.';
                } else if (!(hasTemplate && hasCSV && hasBoxes)) {
                    downloadBtn.title = 'Requires template PDF, CSV data, and at least one box.';
                } else {
                    downloadBtn.title = 'Download PDFs for all CSV records';
                }
            }
            
            // Show/hide the message about multiple boxes
            if (messageDiv) {
                if (boxCount > 1) {
                    messageDiv.style.display = 'block';
                    messageDiv.textContent = `Multiple boxes detected (${boxCount}). Use single page download instead.`;
                } else {
                    messageDiv.style.display = 'none';
                }
            }
        }
        

        
        // Function to update PDF area outline
        function updatePdfAreaOutline() {
            const canvas = document.getElementById('viewer');
            const outline = document.getElementById('pdfAreaOutline');
            
            if (!canvas || !outline) return;
            
            const rect = canvas.getBoundingClientRect();
            const viewerRect = document.getElementById('pdfViewer').getBoundingClientRect();
            
            // Calculate position relative to the viewer
            const left = rect.left - viewerRect.left;
            const top = rect.top - viewerRect.top;
            
            // Apply the same transform as the PDF content to keep outline aligned
            outline.style.transform = `translate(${currentTransform.x}px, ${currentTransform.y}px) scale(${currentTransform.scale})`;
            outline.style.transformOrigin = '0 0';
            
            // Set base position (before transform)
            outline.style.left = left + 'px';
            outline.style.top = top + 'px';
            outline.style.width = rect.width + 'px';
            outline.style.height = rect.height + 'px';
            outline.style.display = 'block';
            
            console.log(`PDF area outline updated: ${rect.width}x${rect.height} at (${left}, ${top}) with transform: scale(${currentTransform.scale})`);
            console.log(`Canvas actual size: ${canvas.width}x${canvas.height}, Display size: ${rect.width}x${rect.height}`);
        }
        
        // Update outline when zoom changes
        function updateOutlineOnZoom() {
            setTimeout(updatePdfAreaOutline, 100); // Small delay to ensure zoom is applied
        }
        
        // Field Selection Modal
        function showFieldSelectionModal(csvColumns, boxCount, boxType) {
            return new Promise((resolve) => {
                // Create modal overlay
                const modalOverlay = document.createElement('div');
                modalOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;

                // Create modal content
                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background: white;
                    padding: 30px;
                    border-radius: 10px;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                    max-width: 400px;
                    width: 90%;
                    text-align: center;
                `;

                // Create title
                const title = document.createElement('h3');
                title.textContent = `Select CSV Field for ${boxCount} ${boxType === 'text' ? 'Text' : 'Image'} Boxes`;
                title.style.cssText = `
                    margin: 0 0 20px 0;
                    color: #333;
                    font-size: 18px;
                `;

                // Create description
                const description = document.createElement('p');
                description.textContent = `Choose which CSV field to use for all ${boxCount} boxes:`;
                description.style.cssText = `
                    margin: 0 0 20px 0;
                    color: #666;
                    font-size: 14px;
                `;

                // Create dropdown
                const dropdown = document.createElement('select');
                dropdown.style.cssText = `
                    width: 100%;
                    padding: 12px;
                    border: 2px solid #ddd;
                    border-radius: 6px;
                    font-size: 16px;
                    margin-bottom: 20px;
                    background: white;
                `;

                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- Select a field --';
                defaultOption.disabled = true;
                defaultOption.selected = true;
                dropdown.appendChild(defaultOption);

                // Add CSV columns as options
                csvColumns.forEach(column => {
                    const option = document.createElement('option');
                    option.value = column;
                    option.textContent = column;
                    dropdown.appendChild(option);
                });

                // Create button container
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = `
                    display: flex;
                    gap: 10px;
                    justify-content: center;
                `;

                // Create OK button
                const okButton = document.createElement('button');
                okButton.textContent = 'Create Boxes';
                okButton.style.cssText = `
                    padding: 10px 20px;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 14px;
                `;
                okButton.onclick = () => {
                    const selectedValue = dropdown.value;
                    if (selectedValue) {
                        modalOverlay.remove();
                        resolve(selectedValue);
                    } else {
                        alert('Please select a field first.');
                    }
                };

                // Create Cancel button
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.style.cssText = `
                    padding: 10px 20px;
                    background: #6c757d;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 14px;
                `;
                cancelButton.onclick = () => {
                    modalOverlay.remove();
                    resolve(null);
                };

                // Add hover effects
                okButton.onmouseover = () => okButton.style.background = '#0056b3';
                okButton.onmouseout = () => okButton.style.background = '#007bff';
                cancelButton.onmouseover = () => cancelButton.style.background = '#545b62';
                cancelButton.onmouseout = () => cancelButton.style.background = '#6c757d';

                // Assemble modal
                buttonContainer.appendChild(okButton);
                buttonContainer.appendChild(cancelButton);
                modalContent.appendChild(title);
                modalContent.appendChild(description);
                modalContent.appendChild(dropdown);
                modalContent.appendChild(buttonContainer);
                modalOverlay.appendChild(modalContent);

                // Add to page
                document.body.appendChild(modalOverlay);

                // Focus on dropdown
                dropdown.focus();

                // Handle Enter key
                dropdown.onkeydown = (e) => {
                    if (e.key === 'Enter' && dropdown.value) {
                        okButton.click();
                    }
                };
            });
        }

        // Toggle Format Style Function
        function toggleFormatStyle(buttonId) {
            const button = document.getElementById(buttonId);
            if (button) {
                button.classList.toggle('active');
                button.style.background = button.classList.contains('active') ? '#007bff' : '';
                button.style.color = button.classList.contains('active') ? 'white' : '';
            }
        }

        // Update Font Dropdowns Function
        function updateFontDropdowns() {
            const fontSelects = [
                document.getElementById('formatAllFontFamily'),
                document.getElementById('boxFontFamily')
            ];
            
            fontSelects.forEach(select => {
                if (select) {
                    // Store current selection
                    const currentValue = select.value;
                    
                    // Clear existing options
                    select.innerHTML = '';
                    
                    // Add all available fonts
                    sessionState.availableFonts.forEach(fontName => {
                        const option = document.createElement('option');
                        option.value = fontName;
                        option.textContent = fontName;
                        select.appendChild(option);
                    });
                    
                    // Restore selection if it still exists, otherwise use default
                    if (sessionState.availableFonts.includes(currentValue)) {
                        select.value = currentValue;
                    } else if (sessionState.defaultFontFamily && sessionState.availableFonts.includes(sessionState.defaultFontFamily)) {
                        select.value = sessionState.defaultFontFamily;
                    }
                }
            });
        }

        // Format All Text Boxes Function
        function formatAllTextBoxes() {
            const textBoxes = sessionState.boxes.filter(box => box.boxType === 'text');
            
            if (textBoxes.length === 0) {
                alert('No text boxes found to format.');
                return;
            }
            
            // Get formatting values from the form
            const fontFamily = document.getElementById('formatAllFontFamily').value;
            const fontSize = document.getElementById('formatAllFontSize').value;
            const textColor = document.getElementById('formatAllTextColor').value;
            const textAlign = document.getElementById('formatAllTextAlign').value;
            
            // Get text style states
            const boldBtn = document.getElementById('formatAllBold');
            const italicBtn = document.getElementById('formatAllItalic');
            const underlineBtn = document.getElementById('formatAllUnderline');
            
            const isBold = boldBtn.classList.contains('active');
            const isItalic = italicBtn.classList.contains('active');
            const isUnderline = underlineBtn.classList.contains('active');

            // Apply formatting to all text boxes
            textBoxes.forEach(box => {
                if (box.element) {
                    const element = box.element;
                    
                    // Update element styles with proper font family formatting
                    element.style.fontFamily = `'${fontFamily}', Arial, sans-serif`;
                    element.style.fontSize = fontSize + 'px';
                    element.style.color = textColor;
                    element.style.textAlign = textAlign;
                    
                    // Apply text styles
                    element.style.fontWeight = isBold ? 'bold' : 'normal';
                    element.style.fontStyle = isItalic ? 'italic' : 'normal';
                    element.style.textDecoration = isUnderline ? 'underline' : 'none';
                    
                    // Update box data in session state
                    box.fontFamily = fontFamily;
                    box.fontSize = parseInt(fontSize);
                    box.color = textColor;
                    box.textAlign = textAlign;
                    box.bold = isBold;
                    box.italic = isItalic;
                    box.underline = isUnderline;
                }
            });

            // Show success message
            alert(`Applied formatting to ${textBoxes.length} text box(es)!`);
        }

        // Global variable for apply mode (default: all boxes)
        let applyMode = 'all';

        // Function to set apply mode (all boxes vs selected only)
        function setApplyMode(mode) {
            applyMode = mode;
            
            // Update button styles
            const allBtn = document.getElementById('applyToAllBtn');
            const selectedBtn = document.getElementById('applyToSelectedBtn');
            
            if (allBtn && selectedBtn) {
                if (mode === 'all') {
                    allBtn.className = 'btn btn-sm btn-primary';
                    selectedBtn.className = 'btn btn-sm btn-outline-secondary';
                } else {
                    allBtn.className = 'btn btn-sm btn-outline-secondary';
                    selectedBtn.className = 'btn btn-sm btn-primary';
                }
            }
        }

        // Function to apply live formatting instantly
        function applyLiveFormatting() {
            console.log('applyLiveFormatting called');
            
            // Get formatting values from the form
            const fontFamily = document.getElementById('formatAllFontFamily').value;
            const fontSize = document.getElementById('formatAllFontSize').value;
            const textColor = document.getElementById('formatAllTextColor').value;
            const textAlign = document.getElementById('formatAllTextAlign').value;
            
            // Get text style states
            const boldBtn = document.getElementById('formatAllBold');
            const italicBtn = document.getElementById('formatAllItalic');
            const underlineBtn = document.getElementById('formatAllUnderline');
            
            const isBold = boldBtn.classList.contains('active');
            const isItalic = italicBtn.classList.contains('active');
            const isUnderline = underlineBtn.classList.contains('active');
            
            console.log('Style states:', { isBold, isItalic, isUnderline });

            // Determine which boxes to format based on apply mode
            let boxesToFormat = [];
            if (applyMode === 'all') {
                boxesToFormat = sessionState.boxes.filter(box => box.boxType === 'text');
            } else {
                // Format only selected box
                if (sessionState.selectedBox && sessionState.selectedBox.boxType === 'text') {
                    boxesToFormat = [sessionState.selectedBox];
                }
            }

            if (boxesToFormat.length === 0) {
                return; // No boxes to format
            }

            // Apply formatting to the determined boxes
            boxesToFormat.forEach(box => {
                if (box.element) {
                    const element = box.element;
                    
                    // Update element styles with proper font family formatting
                    element.style.fontFamily = `'${fontFamily}', Arial, sans-serif`;
                    element.style.fontSize = fontSize + 'px';
                    element.style.color = textColor;
                    element.style.textAlign = textAlign;
                    
                    // Apply text styles
                    element.style.fontWeight = isBold ? 'bold' : 'normal';
                    element.style.fontStyle = isItalic ? 'italic' : 'normal';
                    element.style.textDecoration = isUnderline ? 'underline' : 'none';
                    
                    // Update box data in session state
                    box.fontFamily = fontFamily;
                    box.fontSize = parseInt(fontSize);
                    box.color = textColor;
                    box.textAlign = textAlign;
                    box.bold = isBold;
                    box.italic = isItalic;
                    box.underline = isUnderline;
                }
            });
        }

        // Updated function to toggle format styles with live application
        function toggleFormatStyle(buttonId) {
            const button = document.getElementById(buttonId);
            if (button) {
                button.classList.toggle('active');
                button.style.background = button.classList.contains('active') ? '#007bff' : '';
                button.style.color = button.classList.contains('active') ? 'white' : '';
                
                // Apply formatting immediately after style toggle
                applyLiveFormatting();
            }
        }

        // Add event listeners for text style buttons
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize alignment dropdown to center by default
            const alignmentSelect = document.getElementById('formatAllTextAlign');
            if (alignmentSelect) {
                alignmentSelect.value = 'center';
            }

            // Bold button
            const boldBtn = document.getElementById('formatAllBold');
            if (boldBtn) {
                boldBtn.addEventListener('click', function() {
                    this.classList.toggle('active');
                    if (this.classList.contains('active')) {
                        this.style.background = '#007bff';
                        this.style.color = 'white';
                        this.style.borderColor = '#007bff';
                    } else {
                        this.style.background = '';
                        this.style.color = '';
                        this.style.borderColor = '';
                    }
                    applyLiveFormatting(); // Apply formatting immediately
                });
            }

            // Italic button
            const italicBtn = document.getElementById('formatAllItalic');
            if (italicBtn) {
                italicBtn.addEventListener('click', function() {
                    this.classList.toggle('active');
                    if (this.classList.contains('active')) {
                        this.style.background = '#007bff';
                        this.style.color = 'white';
                        this.style.borderColor = '#007bff';
                    } else {
                        this.style.background = '';
                        this.style.color = '';
                        this.style.borderColor = '';
                    }
                    applyLiveFormatting(); // Apply formatting immediately
                });
            }

            // Underline button
            const underlineBtn = document.getElementById('formatAllUnderline');
            if (underlineBtn) {
                underlineBtn.addEventListener('click', function() {
                    this.classList.toggle('active');
                    if (this.classList.contains('active')) {
                        this.style.background = '#007bff';
                        this.style.color = 'white';
                        this.style.borderColor = '#007bff';
                    } else {
                        this.style.background = '';
                        this.style.color = '';
                        this.style.borderColor = '';
                    }
                    applyLiveFormatting(); // Apply formatting immediately
                });
            }

            // CSV file input handler
            const csvFileInput = document.getElementById('csvFile');
            console.log('Looking for CSV file input:', csvFileInput);
            if (csvFileInput) {
                console.log('CSV file input found, adding event listener');
                csvFileInput.addEventListener('change', function(e) {
                    console.log('CSV file selected:', e.target.files[0]);
                    const file = e.target.files[0];
                    if (file) {
                        console.log('CSV file selected:', file.name, file.size);
                        
                        // Store file metadata for change detection
                        sessionState.csvMetadata = {
                            name: file.name,
                            lastModified: file.lastModified,
                            size: file.size
                        };
                        
                        parseCSVFile(file);
                    } else {
                        console.log('No file selected');
                    }
                });
            } else {
                console.error('CSV file input not found!');
            }

            // Setup keyboard shortcuts for box management
            setupKeyboardShortcuts();
             
             // Setup file change monitoring
             setupFileChangeMonitoring();
             
             // Setup enhanced zoom functionality
             setupMouseWheelZoom();
             
             // Add live file monitoring controls
             setupLiveFileMonitoringControls();
         });

                 // File change monitoring system
         function setupFileChangeMonitoring() {
             // Monitor file inputs for changes
             const pdfFileInput = document.getElementById('pdfFile');
             const csvFileInput = document.getElementById('csvFile');
             
             if (pdfFileInput) {
                 pdfFileInput.addEventListener('change', function(e) {
                     const file = e.target.files[0];
                     if (file) {
                         // Store file metadata for change detection
                         sessionState.pdfMetadata = {
                             name: file.name,
                             lastModified: file.lastModified,
                             size: file.size
                         };
                         
                         // Load the PDF
                         loadPdf(file);
                         
                         // If live monitoring is enabled, keep the file selected
                         if (sessionState.liveMonitoringEnabled) {
                             console.log('Live monitoring enabled - keeping PDF file selected for updates');
                         }
                     }
                 });
             }
             
             if (csvFileInput) {
                 csvFileInput.addEventListener('change', function(e) {
                     const file = e.target.files[0];
                     if (file) {
                         // Store file metadata for change detection
                         sessionState.csvMetadata = {
                             name: file.name,
                             lastModified: file.lastModified,
                             size: file.size
                         };
                         
                         // Parse the CSV
                         parseCSVFile(file);
                         
                         // If live monitoring is enabled, keep the file selected
                         if (sessionState.liveMonitoringEnabled) {
                             console.log('Live monitoring enabled - keeping CSV file selected for updates');
                         }
                     }
                 });
             }
             
             // Start periodic file checking
             setInterval(checkForFileChanges, 2000); // Check every 2 seconds
             
             // Also monitor for manual file removal
             if (pdfFileInput) {
                 pdfFileInput.addEventListener('input', function(e) {
                     if (e.target.files.length === 0 && sessionState.pdfMetadata) {
                         if (sessionState.liveMonitoringEnabled) {
                             console.log('PDF file removed but live monitoring is enabled - consider re-selecting for updates');
                         } else {
                             console.log('PDF file manually removed, clearing metadata');
                             sessionState.pdfMetadata = null;
                         }
                     }
                 });
             }
             
             if (csvFileInput) {
                 csvFileInput.addEventListener('input', function(e) {
                     if (e.target.files.length === 0 && sessionState.csvMetadata) {
                         if (sessionState.liveMonitoringEnabled) {
                             console.log('CSV file removed but live monitoring is enabled - consider re-selecting for updates');
                         } else {
                             console.log('CSV file manually removed, clearing metadata');
                             sessionState.csvMetadata = null;
                         }
                     }
                 });
             }
             
             // Check for file changes when page becomes visible again
             document.addEventListener('visibilitychange', function() {
                 if (!document.hidden) {
                     console.log('Page became visible, checking for file changes...');
                     checkForFileChanges();
                 }
             });
             
             // Cleanup render tasks when page is unloaded
             window.addEventListener('beforeunload', function() {
                 if (window.currentRenderTask) {
                     try {
                         window.currentRenderTask.cancel();
                     } catch (cancelError) {
                         // Ignore errors during page unload
                     }
                 }
             });
         }
         
         // Check for external file changes
         function checkForFileChanges() {
             try {
                 const pdfFileInput = document.getElementById('pdfFile');
                 const csvFileInput = document.getElementById('csvFile');
                 
                 // Check PDF file changes
                 if (pdfFileInput && pdfFileInput.files.length > 0 && sessionState.pdfMetadata) {
                     const currentFile = pdfFileInput.files[0];
                     if (currentFile.name === sessionState.pdfMetadata.name && 
                         (currentFile.lastModified !== sessionState.pdfMetadata.lastModified || 
                          currentFile.size !== sessionState.pdfMetadata.size)) {
                         
                         console.log('PDF file change detected, updating...');
                         
                         // Update metadata
                         sessionState.pdfMetadata.lastModified = currentFile.lastModified;
                         sessionState.pdfMetadata.size = currentFile.size;
                         
                         console.log('PDF file change detected, updating...');
                         
                         // Reload PDF in background (only if not currently rendering)
                         if (!window.currentRenderTask || window.currentRenderTask.destroyed) {
                             // Add a small delay to prevent rapid successive reloads
                             setTimeout(() => {
                                 loadPdf(currentFile);
                             }, 100);
                         } else {
                             console.log('PDF currently rendering, will check again later');
                         }
                     }
                 }
                 
                 // Check CSV file changes
                 if (csvFileInput && csvFileInput.files.length > 0 && sessionState.csvMetadata) {
                     const currentFile = csvFileInput.files[0];
                     if (currentFile.name === sessionState.csvMetadata.name && 
                         (currentFile.lastModified !== sessionState.csvMetadata.lastModified || 
                          currentFile.size !== sessionState.csvMetadata.size)) {
                         
                         console.log('CSV file change detected, updating...');
                         
                         // Update metadata
                         sessionState.csvMetadata.lastModified = currentFile.lastModified;
                         sessionState.csvMetadata.size = currentFile.size;
                         
                         // Reload CSV in background (add small delay to prevent rapid successive parsing)
                         setTimeout(() => {
                             parseCSVFile(currentFile);
                         }, 100);
                     }
                 }
             } catch (error) {
                 console.error('Error checking for file changes:', error);
             }
         }

        // Live File Monitoring Controls
        function setupLiveFileMonitoringControls() {
            // Add live monitoring toggle to the UI
            const fileControls = document.querySelector('.file-controls');
            if (fileControls) {
                const liveMonitoringDiv = document.createElement('div');
                liveMonitoringDiv.className = 'live-monitoring-controls';
                liveMonitoringDiv.innerHTML = `
                    <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px; border: 1px solid #dee2e6;">
                        <h4 style="margin: 0 0 10px 0; color: #495057;">🔄 Live File Monitoring</h4>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 14px;">
                                <input type="checkbox" id="enableLiveMonitoring" style="margin: 0;">
                                Enable live updates when files change
                            </label>
                            <button id="refreshFilesBtn" style="padding: 5px 10px; font-size: 12px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                🔄 Refresh Files
                            </button>
                        </div>
                        <p style="margin: 10px 0 0 0; font-size: 12px; color: #6c757d;">
                            <strong>Note:</strong> For live updates to work, files must remain selected in the file inputs above.
                        </p>
                    </div>
                `;
                
                fileControls.appendChild(liveMonitoringDiv);
                
                // Add event listeners
                document.getElementById('enableLiveMonitoring').addEventListener('change', function(e) {
                    sessionState.liveMonitoringEnabled = e.target.checked;
                    console.log('Live monitoring:', e.target.checked ? 'enabled' : 'disabled');
                });
                
                document.getElementById('refreshFilesBtn').addEventListener('click', function() {
                    refreshFilesForLiveMonitoring();
                });
            }
        }
        
        // Refresh files for live monitoring
        function refreshFilesForLiveMonitoring() {
            if (sessionState.pdfMetadata) {
                console.log('Refreshing PDF file for live monitoring...');
                // This would typically prompt user to re-select the file
                alert('Please re-select your PDF file to enable live monitoring');
            }
            
            if (sessionState.csvMetadata) {
                console.log('Refreshing CSV file for live monitoring...');
                // This would typically prompt user to re-select the file
                alert('Please re-select your CSV file to enable live monitoring');
            }
        }

        // Simple Multiple Records Management
        let recordsCreated = 0;
        
        function createMultipleTextRecords() {
            // Check if CSV data is loaded
            if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                alert('Please upload CSV data first!');
                return;
            }
            
            // Check if we have text boxes with CSV columns assigned
            const textBoxes = sessionState.boxes.filter(box => box.boxType === 'text' && box.csvColumn);
            
            if (textBoxes.length === 0) {
                alert('Please create at least one text box with a CSV field assigned!');
                return;
            }
            
            // Get the number of records to create from dropdown
            const recordsCount = parseInt(document.getElementById('recordsCountSelect').value);
            
            // Remove initial text boxes
            textBoxes.forEach(box => {
                if (box.element) {
                    box.element.remove();
                }
            });
            sessionState.boxes = sessionState.boxes.filter(box => box.boxType !== 'text');
            
            // Create multiple text boxes for each record
            for (let i = 0; i < recordsCount; i++) {
                if (i >= sessionState.csvRows.length) break; // Don't create more than available records
                
                const record = sessionState.csvRows[i];
                const verticalOffset = i * 120; // Space between record groups
                
                // Create text boxes
                textBoxes.forEach((templateBox, txtIndex) => {
                    // Create text box (existing logic)
                    const recordText = record[templateBox.csvColumn] || `Record ${i + 1}`;
                    
                const newBox = {
                        ...templateBox,
                    id: ++boxCounter,
                        boxId: boxCounter, // Add boxId for consistency with delete function
                        y: templateBox.y + verticalOffset, // Stack vertically with spacing
                    element: null
                };
                
                // Create the text box element
                const textBox = document.createElement('div');
                textBox.className = 'draggable-text-box';
                textBox.id = 'textBox_' + newBox.id;
                textBox.style.cssText = `
                    position: absolute;
                    left: ${newBox.x}px;
                    top: ${newBox.y}px;
                    width: ${newBox.width}px;
                    height: ${newBox.height}px;
                    min-width: 20px;
                    min-height: 15px;
                    background: transparent;
                    border: none;
                    padding: 5px;
                    cursor: move;
                    pointer-events: auto;
                    z-index: 20;
                    font-family: ${newBox.fontFamily}, sans-serif;
                    font-size: ${newBox.fontSize}px;
                    color: ${newBox.color};
                    text-align: ${newBox.textAlign};
                    user-select: none;
                    box-sizing: border-box;
                    overflow: hidden;
                    box-shadow: none;
                    transition: all 0.1s ease;
                    display: block;
                    line-height: 1.2;
                `;
                textBox.textContent = recordText;
                textBox.contentEditable = false;
                    

                
                // Add to overlay container
                const overlayContainer = document.getElementById('overlayContainer');
                overlayContainer.appendChild(textBox);
                
                // Make it draggable
                makeDraggable(textBox);
                
                // Add click handler
                textBox.addEventListener('click', function(e) {
                    e.stopPropagation();
                    // Remove selection from all boxes
                    document.querySelectorAll('.draggable-text-box, .draggable-image-box').forEach(box => {
                        box.style.border = 'none';
                        box.classList.remove('selected');
                    });
                    textBox.style.border = 'none';
                    textBox.classList.add('selected');
                    sessionState.selectedBox = textBox; // Store the DOM element, not the box object
                    updateBoxEditor();
                    updateBoxEditorValues(newBox);
                });
                
                newBox.element = textBox;
                sessionState.boxes.push(newBox);
                });
            }
            
            recordsCreated += recordsCount;
            updateRecordsInfo();
            
            // Reset to first page and update navigation
            currentPage = 0;
            updatePageNavigation();
            updateAllTextBoxesWithCSVData();
            
            const totalBoxes = textBoxes.length * recordsCount;
            alert(`Created ${totalBoxes} text boxes for ${recordsCount} records!`);
            
            // Update download button state to enable downloads
            updateDownloadButtonState();
            
            // Update text box scaling to match current PDF viewer state
            updateTextBoxScaling();
        }
        
        function updateRecordsInfo() {
            // recordsInfo element was removed with the Multiple Records section
            // This function is kept for compatibility but does nothing
        }
        
        function createMultipleImageRecords() {
            // Check if CSV data is loaded
            if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                alert('Please upload CSV data first!');
                return;
            }
            
            // Check if we have image boxes with CSV columns assigned
            const imageBoxes = sessionState.boxes.filter(box => box.boxType === 'image' && box.csvColumn);
            
            if (imageBoxes.length === 0) {
                alert('Please create at least one image box with a CSV field assigned!');
                return;
            }
            
            // Get the number of records to create from dropdown
            const recordsCount = parseInt(document.getElementById('recordsCountSelect').value);
            
            // Remove initial image boxes
            imageBoxes.forEach(box => {
                if (box.parentNode) {
                    box.remove();
                }
            });
            sessionState.boxes = sessionState.boxes.filter(box => box.boxType !== 'image');
            
            // Create multiple image boxes for each record
            for (let i = 0; i < recordsCount; i++) {
                if (i >= sessionState.csvRows.length) break; // Don't create more than available records
                
                const record = sessionState.csvRows[i];
                const verticalOffset = i * 120; // Space between record groups
                
                // Create image boxes
                imageBoxes.forEach((templateBox, imgIndex) => {
                    // Create image box using DOM elements
                    const centerX = parseFloat(templateBox.style?.left) || 100;
                    const centerY = (parseFloat(templateBox.style?.top) || 100) + verticalOffset; // Stack vertically
                    
                    // Create a DOM-based image box
                    const imageBox = document.createElement('div');
                    imageBox.className = 'draggable-image-box';
                    imageBox.style.cssText = `
                        position: absolute;
                        left: ${(centerX - 50)}px;
                        top: ${(centerY - 50)}px;
                        width: 100px;
                        height: 100px;
                        border: 2px dashed #007bff;
                        background: transparent;
                        cursor: move;
                        z-index: 10;
                        overflow: hidden;
                        box-sizing: border-box;
                        transition: all 0.1s ease;
                    `;

                    // Add custom properties
                    imageBox.boxId = ++boxCounter;
                    imageBox.boxType = 'image';
                    imageBox.csvColumn = templateBox.csvColumn;
                    imageBox.imageSource = 'csv';
                    imageBox.imageUrl = '';
                    imageBox.boxIndex = i; // Track which record this box represents

                    // Add click handler for selection
                    imageBox.addEventListener('click', function(e) {
                        e.stopPropagation();
                        // Remove selection from all boxes
                        document.querySelectorAll('.draggable-image-box, .draggable-text-box').forEach(box => {
                            box.classList.remove('selected');
                        });
                        imageBox.classList.add('selected');
                        sessionState.selectedBox = imageBox; // Store the DOM element
                        currentBoxId = imageBox.boxId;
                        updateBoxEditor();
                        updateBoxEditorValues(imageBox);
                    });

                    // Add to PDF viewer and enable drag/resize
                    const pdfViewer = document.getElementById('pdfViewer');
                    pdfViewer.appendChild(imageBox);
                    enableDragResize(imageBox);
                    
                    // Create a proper box object for the image box
                    const imageBoxObject = {
                        boxId: imageBox.boxId,
                        boxType: 'image',
                        csvColumn: imageBox.csvColumn,
                        imageSource: imageBox.imageSource,
                        imageUrl: imageBox.imageUrl,
                        element: imageBox
                    };
                    
                    sessionState.boxes.push(imageBoxObject);
                    
                    // Update the image with CSV data
                    updateImageBoxWithCSVData(imageBoxObject);
                });
            }
            
            recordsCreated += recordsCount;
            updateRecordsInfo();
            
            // Reset to first page and update navigation
            currentPage = 0;
            updatePageNavigation();
            
            const totalBoxes = imageBoxes.length * recordsCount;
            alert(`Created ${totalBoxes} image boxes for ${recordsCount} records!`);
            
            // Update download button state to enable downloads
            updateDownloadButtonState();
            
            // Update image box scaling to match current PDF viewer state
            updateImageBoxScaling();
        }

        function updateCreateRecordsButtonState() {
            // Multiple records buttons were removed
            // This function is kept for compatibility but does nothing
        }
        
        // Page navigation variables
        let currentPage = 0;
        let recordsPerPage = 4;
        let totalPages = 1;
        
        function updatePageNavigation() {
            const pageNav = document.getElementById('pageNavigation');
            const pageInfo = document.getElementById('pageInfo');
            const pageRecordsInfo = document.getElementById('pageRecordsInfo');
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            
            if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                pageNav.style.display = 'none';
                return;
            }
            
            // Calculate records per page based on number of boxes
            const totalBoxes = sessionState.boxes.length;
            recordsPerPage = totalBoxes > 0 ? totalBoxes : 1; // At least 1 record per page
            totalPages = Math.ceil(sessionState.csvRows.length / recordsPerPage);
            
            // Update page info
            pageInfo.textContent = `Page ${currentPage + 1} of ${totalPages}`;
            
            // Calculate record range for current page
            const startRecord = currentPage * recordsPerPage;
            const endRecord = Math.min(startRecord + recordsPerPage - 1, sessionState.csvRows.length - 1);
            pageRecordsInfo.textContent = `Showing records ${startRecord + 1}-${endRecord + 1}`;
            
            // Update button states
            prevBtn.disabled = currentPage === 0;
            nextBtn.disabled = currentPage >= totalPages - 1;
            
            // Show navigation
            pageNav.style.display = 'block';
        }
        
        function previousPage() {
            if (currentPage > 0) {
                currentPage--;
                updatePageNavigation();
                updateAllTextBoxesWithCSVData(); // This already handles both text and image boxes
            }
        }
        
        function nextPage() {
            if (currentPage < totalPages - 1) {
                currentPage++;
                updatePageNavigation();
                updateAllTextBoxesWithCSVData(); // This already handles both text and image boxes
            }
        }
        
        function updateRecordDisplay() {
            updatePageNavigation();
        }
        
        function generateRecordsPreview() {
            const previewContainer = document.getElementById('previewContainer');
            if (!previewContainer || !sessionState.csvRows || sessionState.csvRows.length === 0) return;
            
            const totalRecords = sessionState.csvRows.length;
            const totalPages = Math.ceil(totalRecords / recordsPerPage);
            
            let previewHTML = '';
            
            for (let pageIndex = 0; pageIndex < totalPages; pageIndex++) {
                const startRecord = pageIndex * recordsPerPage;
                const endRecord = Math.min(startRecord + recordsPerPage, totalRecords);
                const recordsOnThisPage = endRecord - startRecord;
                
                previewHTML += `
                    <div style="margin-bottom: 15px; padding: 10px; border: 1px solid #ccc; background: white;">
                        <div style="font-weight: bold; color: #007bff; margin-bottom: 8px;">
                            Page ${pageIndex + 1} (Records ${startRecord + 1}-${endRecord})
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 5px;">
                `;
                
                for (let i = 0; i < recordsOnThisPage; i++) {
                    const recordIndex = startRecord + i;
                    const record = sessionState.csvRows[recordIndex];
                    const recordText = Object.values(record).slice(0, 3).join(' | '); // Show first 3 fields
                    
                    previewHTML += `
                        <div style="padding: 5px; background: #f0f0f0; border-left: 3px solid #007bff; font-size: 11px;">
                            <strong>Record ${recordIndex + 1}:</strong> ${recordText}
                        </div>
                    `;
                }
                
                previewHTML += `
                        </div>
                    </div>
                `;
            }
            
            previewContainer.innerHTML = previewHTML;
        }
        
        // Initialize simple system when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing simple system...');
            updateRecordsInfo();
        });


        
        // InDesign-style layout management
        
        function updateTextBoxMappingDisplay() {
            // For InDesign-style data merge: each text box shows current record
            // The records per page feature will duplicate the layout multiple times
            sessionState.boxes.forEach((box) => {
                const select = document.getElementById(`mapping_${box.id}`);
                if (select) {
                    select.value = currentRecord;
                    textBoxMappings[box.id] = currentRecord;
                }
            });
            
            // Update all text boxes with current record data
            updateAllTextBoxesWithCSVData();
        }
        
        // Initialize font handling
        initializeFontHandling();

        // Layout Editor Variables
        let selectedBox = null;

        // Page size definitions (in points)
        const PAGE_SIZES = {
            'A4': { width: 595, height: 842 },
            'A5': { width: 420, height: 595 },
            'A6': { width: 298, height: 420 }
        };

        // Initialize simple HTML-based editor
        function initEditor() {
            // Create the overlay container for text boxes
            const overlayContainer = document.createElement('div');
            overlayContainer.id = 'overlayContainer';
            overlayContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 10;
            `;
            
            const pdfViewer = document.getElementById('pdfViewer');
            if (pdfViewer) {
                pdfViewer.appendChild(overlayContainer);
                pdfViewer.style.position = 'relative';
            }
        }

        function toggleEditorMode() {
            isEditorMode = !isEditorMode;
            const viewer = document.getElementById('viewer');
            const editorCanvasElement = document.getElementById('editorCanvas');
            const pdfViewer = document.getElementById('pdfViewer');
            
            if (isEditorMode) {
                // Show both PDF and editor canvas
                viewer.style.display = 'block';
                editorCanvasElement.style.display = 'block';
                
                // Disable PDF dragging when in editor mode
                if (pdfViewer) {
                    pdfViewer.style.cursor = 'default';
                }
                
                if (editorCanvas) {
                    editorCanvas.renderAll();
                }
            } else {
                // Hide editor canvas, keep PDF visible
                editorCanvasElement.style.display = 'none';
                viewer.style.display = 'block';
                
                // Re-enable PDF dragging when not in editor mode
                if (pdfViewer) {
                    pdfViewer.style.cursor = 'grab';
                }
            }
        }



        async function addText() {
            // Ensure editor is initialized
            if (!document.getElementById('overlayContainer')) {
                initEditor();
            }
            
            // Get PDF viewer dimensions for centering
            const pdfViewer = document.getElementById('pdfViewer');
            if (!pdfViewer || !sessionState.templatePdf) {
                alert('Please upload a PDF template first');
                return;
            }
            
            // Check if CSV data is available
            if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                alert('Please upload CSV data first!');
                return;
            }
            
            // Get number of boxes to add from dropdown
            const boxCount = parseInt(document.getElementById('boxCountSelect').value) || 1;
            
            const rect = pdfViewer.getBoundingClientRect();
            const centerX = (rect.width / 2) - 60;
            const centerY = (rect.height / 2) - 20;
            
            // Get available CSV columns
            const csvColumns = sessionState.csvColumns || [];
            if (csvColumns.length === 0) {
                alert('No CSV columns found. Please check your CSV file.');
                return;
            }
            
            // Create field selection modal
            const selectedField = await showFieldSelectionModal(csvColumns, boxCount, 'text');
            if (!selectedField) {
                return; // User cancelled
            }
            
            // Add multiple boxes for the same field across different records
            for (let i = 0; i < boxCount; i++) {
                const offsetX = i * 20; // Small horizontal offset for each box
                const offsetY = i * 15; // Small vertical offset for each box
                const boxX = centerX + offsetX;
                const boxY = centerY + offsetY;
                
                // Get data from the corresponding record
                const recordIndex = i % sessionState.csvRows.length; // Cycle through records
                const recordData = sessionState.csvRows[recordIndex];
                const sampleText = recordData ? recordData[selectedField] || `Record ${recordIndex + 1}` : `Record ${recordIndex + 1}`;
            
            // Create text box element
            const textBox = document.createElement('div');
            textBox.className = 'draggable-text-box';
            textBox.id = 'textBox_' + ++boxCounter;
            
            textBox.style.cssText = `
                position: absolute;
                left: ${boxX}px;
                top: ${boxY}px;
                width: 120px;
                height: 40px;
                min-width: 20px;
                min-height: 15px;
                background: transparent;
                border: none;
                padding: 5px;
                cursor: move;
                pointer-events: auto;
                z-index: 20;
                font-family: '${sessionState.defaultFontFamily || 'Arial'}', Arial, sans-serif;
                font-size: 16px;
                color: #000;
                text-align: center;
                user-select: none;
                box-sizing: border-box;
                overflow: hidden;
                box-shadow: none;
                transition: all 0.1s ease;
                display: block;
                line-height: 1.2;
            `;
            textBox.textContent = sampleText;
            textBox.contentEditable = false; // Disable direct editing since we use the panel
            
            // Add to overlay container
            const overlayContainer = document.getElementById('overlayContainer');
            overlayContainer.appendChild(textBox);
            
            // Make it draggable
            makeDraggable(textBox);
            
            // Add to session state
            const boxData = {
                id: boxCounter,
                boxId: boxCounter, // Add boxId for consistency with delete function
                element: textBox,
                type: 'text',
                boxType: 'text',
                csvColumn: selectedField,
                staticText: sampleText,
                bold: false,
                italic: false,
                underline: false,
                fontSize: 16,
                fontFamily: sessionState.defaultFontFamily || 'Arial',
                color: '#000000',
                textAlign: 'center',
                x: boxX,
                y: boxY,
                width: 120,
                height: 40
            };
            
            // Add click handler for selection
            textBox.addEventListener('click', function(e) {
                e.stopPropagation();
                
                // Remove selection from all boxes
                document.querySelectorAll('.draggable-text-box, .draggable-image-box').forEach(box => {
                    box.style.border = 'none';
                    box.classList.remove('selected');
                });
                
                // Select this box
                textBox.style.border = 'none';
                textBox.classList.add('selected');
                sessionState.selectedBox = boxData;
                updateBoxEditor();
                updateBoxEditorValues(boxData);
            });
            
            sessionState.boxes.push(boxData);
            sessionState.selectedBox = boxData;
            currentBoxId = boxCounter;
            
            // Update box editor
            updateBoxEditor();
            updateBoxEditorValues(boxData);
            
            // Update download button state
            updateDownloadButtonState();
            
            // Update text box scaling to match current PDF viewer state
            updateTextBoxScaling();
            
            // Select the text box immediately for editing
            textBox.focus();
            // Remove the problematic select() call - text boxes don't have select() method
            
            // Update text size to fit the initial box dimensions
            updateTextSize(textBox);
        }
        }

        async function addImagePlaceholder() {
            console.log('addImagePlaceholder called');
            
            // Don't toggle editor mode for image boxes - they use DOM elements, not canvas

            // Check if CSV data is available
            if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                alert('Please upload CSV data first!');
                return;
            }

            // Get number of boxes to add from dropdown
            const boxCount = parseInt(document.getElementById('boxCountSelect').value) || 1;
            
            // Get available CSV columns
            const csvColumns = sessionState.csvColumns || [];
            if (csvColumns.length === 0) {
                alert('No CSV columns found. Please check your CSV file.');
                return;
            }
            
            // Create field selection modal
            const selectedField = await showFieldSelectionModal(csvColumns, boxCount, 'image');
            if (!selectedField) {
                return; // User cancelled
            }
            
            // Add multiple image boxes for the same field across different records
            for (let i = 0; i < boxCount; i++) {
                const offsetX = i * 20; // Small horizontal offset for each box
                const offsetY = i * 15; // Small vertical offset for each box
                const boxX = 50 + offsetX;
                const boxY = 50 + offsetY;
                
                // Get data from the corresponding record
                const recordIndex = i % sessionState.csvRows.length; // Cycle through records
                const recordData = sessionState.csvRows[recordIndex];
                const sampleImageUrl = recordData ? recordData[selectedField] || '' : '';
                
                // Create a DOM-based image box (similar to MERGE-ONLINE approach)
                const imageBox = document.createElement('div');
            imageBox.className = 'draggable-image-box';
            
            imageBox.style.cssText = `
                position: absolute;
                left: ${boxX}px;
                top: ${boxY}px;
                width: 100px;
                height: 100px;
                min-width: 40px;
                min-height: 30px;
                background: transparent;
                border: 2px dashed #007bff;
                cursor: move;
                pointer-events: auto;
                z-index: 10;
                overflow: hidden;
                box-sizing: border-box;
                transition: all 0.1s ease;
                transform-origin: top left;
            `;

            // Add custom properties
            imageBox.boxId = ++boxCounter;
            imageBox.boxType = 'image';
            imageBox.csvColumn = selectedField;
            imageBox.imageSource = 'csv';
            imageBox.imageUrl = sampleImageUrl;

            // Load image if URL is available
            if (sampleImageUrl && sampleImageUrl.trim() !== '') {
                // Use proxy to handle CORS
                const proxiedUrl = 'proxy_image.php?url=' + encodeURIComponent(sampleImageUrl);
                console.log('Loading sample image via proxy:', proxiedUrl);
                
                // Create image element
                const img = document.createElement('img');
                img.crossOrigin = 'anonymous';
                img.src = proxiedUrl;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                img.style.objectPosition = 'center';
                
                // Add error handling
                img.onerror = function() {
                    console.error('Failed to load sample image:', sampleImageUrl);
                    imageBox.textContent = 'Load Failed';
                    imageBox.style.color = '#ffc107';
                    imageBox.style.fontWeight = 'bold';
                    imageBox.style.fontSize = '12px';
                    imageBox.style.border = '2px dashed #ffc107';
                    imageBox.style.background = 'rgba(255, 193, 7, 0.1)';
                };
                
                img.onload = function() {
                    console.log('Sample image loaded successfully');
                };
                
                // Clear existing content and add image
                imageBox.innerHTML = '';
                imageBox.appendChild(img);
            }

            // Add click handler for selection
            imageBox.addEventListener('click', function(e) {
                e.stopPropagation();
                // Remove selected class from all boxes
                document.querySelectorAll('.draggable-image-box, .draggable-text-box').forEach(box => {
                    box.classList.remove('selected');
                });
                // Add selected class to this box
                imageBox.classList.add('selected');
                
                // Update session state
                sessionState.selectedBox = imageBox; // Store the DOM element
                currentBoxId = imageBox.boxId;
                
                // Update box editor
                updateBoxEditor();
                updateBoxEditorValues(boxData); // Use the box object for editor values
            });

            // Add to overlay container (same as text boxes)
            const overlayContainer = document.getElementById('overlayContainer');
            if (!overlayContainer) {
                initEditor();
            }
            overlayContainer.appendChild(imageBox);

            // Add to session state (same structure as text boxes)
            const boxData = {
                id: imageBox.boxId,
                element: imageBox,
                type: 'image',
                boxType: 'image',
                csvColumn: selectedField,
                imageSource: 'csv',
                imageUrl: sampleImageUrl,
                x: boxX,
                y: boxY,
                width: 100,
                height: 100
            };
            
            sessionState.boxes.push(boxData);
            sessionState.selectedBox = imageBox; // Store the DOM element, not the box object
            currentBoxId = imageBox.boxId;
            
            // Update box editor
            updateBoxEditor();
            updateBoxEditorValues(boxData);

            // Enable drag and resize for this box
            enableDragResize(imageBox);
            
            // Add resize handles for visual feedback
            addResizeHandles(imageBox);

            updateEditorStatus('Image box created - drag it to position and edit properties');
            
            // Update download button state to enable downloads
            updateDownloadButtonState();
            
            // Update image box scaling to match current PDF viewer state
            updateImageBoxScaling();
            }
        }





        // Function to enable drag and resize for DOM elements (similar to MERGE-ONLINE)
        function enableDragResize(element) {
            // Make sure Interact.js is available
            if (typeof interact === 'undefined') {
                console.error('Interact.js not loaded');
                return;
            }

            // Enable dragging
            interact(element).draggable({
                listeners: {
                    start: function(event) {
                        event.target.classList.add('dragging');
                    },
                    move: function(event) {
                        const target = event.target;
                        const left = parseFloat(target.style.left) + event.dx;
                        const top = parseFloat(target.style.top) + event.dy;
                        
                        if (snapToGridEnabled) {
                            // Apply snap-to-grid when enabled
                            const snappedPosition = snapToGrid(left, top, target);
                            target.style.left = snappedPosition.x + 'px';
                            target.style.top = snappedPosition.y + 'px';
                        } else {
                            // Free movement when snap-to-grid is disabled
                            target.style.left = left + 'px';
                            target.style.top = top + 'px';
                        }
                    },
                    end: function(event) {
                        event.target.classList.remove('dragging');
                        clearSnapGuides();
                    }
                }
            });

            // Enable resizing
            interact(element).resizable({
                edges: { left: true, right: true, top: true, bottom: true },
                listeners: {
                    move: function(event) {
                        const target = event.target;
                        let width = parseFloat(target.style.width);
                        let height = parseFloat(target.style.height);
                        let left = parseFloat(target.style.left);
                        let top = parseFloat(target.style.top);

                        // Update width and height
                        width += event.deltaRect.width;
                        height += event.deltaRect.height;
                        
                        // Update position for left and top edges
                        left += event.deltaRect.left;
                        top += event.deltaRect.top;

                        if (snapToGridEnabled) {
                            // Apply snap-to-grid when enabled
                            const snappedPosition = snapToGrid(left, top, target);
                            target.style.width = width + 'px';
                            target.style.height = height + 'px';
                            target.style.left = snappedPosition.x + 'px';
                            target.style.top = snappedPosition.y + 'px';
                        } else {
                            // Apply changes with free positioning
                            target.style.width = width + 'px';
                            target.style.height = height + 'px';
                            target.style.left = left + 'px';
                            target.style.top = top + 'px';
                        }
                    
                    // Ensure images maintain aspect ratio after resize
                    if (target.classList.contains('draggable-image-box')) {
                        const img = target.querySelector('img');
                        if (img) {
                            img.style.objectFit = 'contain';
                            img.style.objectPosition = 'center';
                            img.style.aspectRatio = 'auto';
                            img.style.imageRendering = 'auto';
                        }
                    }
                    }
                }
            });
        }

        // Function to load static image
        function loadStaticImage(box, imageUrl) {
            console.log('loadStaticImage called with:', box, imageUrl);
            if (!imageUrl) return;
            
            // Use proxy to handle CORS
            const proxiedUrl = 'proxy_image.php?url=' + encodeURIComponent(imageUrl);
            console.log('Proxied URL:', proxiedUrl);
            
            // Create image element
            const img = document.createElement('img');
            img.crossOrigin = 'anonymous'; // Add CORS attribute
            img.src = proxiedUrl;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'contain';
            img.style.objectPosition = 'center';
            
            // Add error handling
            img.onerror = function() {
                console.error('Failed to load image:', imageUrl);
                console.error('Error details:', this.src);
                box.innerHTML = '<div style="color: red; text-align: center; padding: 10px; font-size: 12px;">Failed to load image<br>' + imageUrl + '</div>';
            };
            
            img.onload = function() {
                console.log('Image loaded successfully:', imageUrl);
            };
            
            // Clear existing content and add image
            box.innerHTML = '';
            box.appendChild(img);
            
            // Update box properties
            box.imageUrl = imageUrl;
        }

        // Function to update image box with CSV data
        function updateImageBoxWithCSVData(box) {
            console.log('updateImageBoxWithCSVData called with:', box);
            if (box.boxType !== 'image' || !box.csvColumn) {
                console.log('Box is not image type or no CSV column selected');
                return;
            }
            
            // Get current CSV row data
            const currentRow = sessionState.csvRows && sessionState.csvRows[currentPage * recordsPerPage + (box.boxIndex || 0)];
            if (!currentRow) {
                console.log('No current row data available');
                return;
            }
            
            const imageUrl = currentRow[box.csvColumn];
            console.log('Image URL from CSV:', imageUrl);
            if (!imageUrl) {
                console.log('No image URL found in CSV column');
                return;
            }
            
            // Use proxy to handle CORS
            const proxiedUrl = 'proxy_image.php?url=' + encodeURIComponent(imageUrl);
            console.log('Proxied URL for CSV image:', proxiedUrl);
            
            // Create image element
            const img = document.createElement('img');
            img.crossOrigin = 'anonymous'; // Add CORS attribute
            img.src = proxiedUrl;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'contain';
            img.style.objectPosition = 'center';
            
            // Add error handling
            img.onerror = function() {
                console.error('Failed to load CSV image:', imageUrl);
                console.error('Error details:', this.src);
                box.innerHTML = '<div style="color: red; text-align: center; padding: 10px; font-size: 12px;">Failed to load CSV image<br>' + imageUrl + '</div>';
            };
            
            img.onload = function() {
                console.log('CSV image loaded successfully:', imageUrl);
            };
            
            // Clear existing content and add image
            box.innerHTML = '';
            box.appendChild(img);
            
            // Update box properties
            box.imageUrl = imageUrl;
        }

        function duplicateObject() {
            if (!selectedEditorObject || !editorCanvas) return;

            const clone = fabric.util.object.clone(selectedEditorObject);
            clone.set({
                left: selectedEditorObject.left + 20,
                top: selectedEditorObject.top + 20
            });

            editorCanvas.add(clone);
            editorCanvas.setActiveObject(clone);
            updateEditorStatus('Object duplicated');
        }

        function toggleLock() {
            if (!selectedEditorObject) return;

            selectedEditorObject.selectable = !selectedEditorObject.selectable;
            selectedEditorObject.evented = !selectedEditorObject.evented;
            
            const lockBtn = document.getElementById('lockBtn');
            if (selectedEditorObject.selectable) {
                lockBtn.textContent = 'Lock';
                lockBtn.className = 'editor-btn editor-btn-warning';
            } else {
                lockBtn.textContent = 'Unlock';
                lockBtn.className = 'editor-btn editor-btn-success';
            }

            updateEditorStatus(selectedEditorObject.selectable ? 'Object unlocked' : 'Object locked');
        }

        function deleteObject() {
            if (!selectedEditorObject || !editorCanvas) return;

            editorCanvas.remove(selectedEditorObject);
            editorCanvas.discardActiveObject();
            updateEditorStatus('Object deleted');
        }

        function clearCanvas() {
            if (!editorCanvas) return;

            if (confirm('Are you sure you want to clear all objects?')) {
                editorCanvas.clear();
                updateEditorStatus('Canvas cleared');
            }
        }

        function onEditorObjectSelected(e) {
            selectedEditorObject = e.target;
            updateEditorSidebar();
            updateEditorButtonStates(true);
            updateEditorStatus('Object selected');
        }

        function onEditorObjectDeselected() {
            selectedEditorObject = null;
            document.getElementById('editorSidebar').classList.remove('active');
            updateEditorButtonStates(false);
            updateEditorStatus('No object selected');
        }

        function onEditorObjectModified(e) {
            updateEditorSidebar();
            updateEditorStatus('Object modified');
        }

        function onEditorObjectMoving(e) {
            if (gridSize > 0) {
                const obj = e.target;
                obj.set({
                    left: Math.round(obj.left / gridSize) * gridSize,
                    top: Math.round(obj.top / gridSize) * gridSize
                });
            }
        }

        function onEditorObjectScaling(e) {
            if (gridSize > 0) {
                const obj = e.target;
                obj.set({
                    width: Math.round(obj.width / gridSize) * gridSize,
                    height: Math.round(obj.height / gridSize) * gridSize
                });
            }
        }

        function updateEditorSidebar() {
            if (!selectedEditorObject) return;

            document.getElementById('editorSidebar').classList.add('active');

            // Get object metadata
            const meta = selectedEditorObject.meta || {};

            // Update form fields
            document.getElementById('bindField').value = meta.bind || '';
            document.getElementById('staticContent').value = meta.static || '';
            document.getElementById('posX').value = Math.round(selectedEditorObject.left);
            document.getElementById('posY').value = Math.round(selectedEditorObject.top);
            document.getElementById('width').value = Math.round(selectedEditorObject.width || selectedEditorObject.scaleX * 100);
            document.getElementById('height').value = Math.round(selectedEditorObject.height || selectedEditorObject.scaleY * 100);

            // Add event listeners for form changes
            document.getElementById('bindField').onchange = updateEditorObjectMeta;
            document.getElementById('staticContent').oninput = updateEditorObjectMeta;
            document.getElementById('posX').onchange = updateEditorObjectPosition;
            document.getElementById('posY').onchange = updateEditorObjectPosition;
            document.getElementById('width').onchange = updateEditorObjectSize;
            document.getElementById('height').onchange = updateEditorObjectSize;
        }

        function updateEditorObjectMeta() {
            if (!selectedEditorObject) return;

            selectedEditorObject.meta = {
                bind: document.getElementById('bindField').value,
                static: document.getElementById('staticContent').value
            };

            // Update text content if it's a text object
            if (selectedEditorObject.type === 'text' && document.getElementById('staticContent').value) {
                selectedEditorObject.set('text', document.getElementById('staticContent').value);
            }

            editorCanvas.renderAll();
        }

        function updateEditorObjectPosition() {
            if (!selectedEditorObject) return;

            selectedEditorObject.set({
                left: parseInt(document.getElementById('posX').value),
                top: parseInt(document.getElementById('posY').value)
            });

            editorCanvas.renderAll();
        }

        function updateEditorObjectSize() {
            if (!selectedEditorObject) return;

            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);

            if (selectedEditorObject.type === 'text') {
                selectedEditorObject.set('fontSize', Math.min(width, height) / 2);
            } else {
                selectedEditorObject.set({
                    width: width,
                    height: height
                });
            }

            editorCanvas.renderAll();
        }

        function updateEditorButtonStates(enabled) {
            document.getElementById('duplicateBtn').disabled = !enabled;
            document.getElementById('lockBtn').disabled = !enabled;
            document.getElementById('deleteBtn').disabled = !enabled;
        }

        // Helper function to get box object from selected DOM element
        function getSelectedBoxObject() {
            if (!sessionState.selectedBox) return null;
            
            // If selectedBox is already a box object, return it
            if (sessionState.selectedBox.boxId && sessionState.selectedBox.boxType) {
                return sessionState.selectedBox;
            }
            
            // If selectedBox is a DOM element, find the corresponding box object
            if (sessionState.selectedBox.classList) {
                return sessionState.boxes.find(box => box.element === sessionState.selectedBox);
            }
            
            return null;
        }

        // Auto-cleanup function to delete temporary files on page refresh
        function cleanupTemporaryFiles() {
            console.log('Cleaning up temporary files...');
            
            // Clean up uploads folder
            fetch('cleanup_files.php', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    action: 'cleanup',
                    folders: ['uploads', 'layouts', 'runtime']
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Temporary files cleaned up successfully');
                } else {
                    console.log('Cleanup completed with warnings:', data.message);
                }
            })
            .catch(error => {
                console.log('Cleanup error (non-critical):', error);
            });
        }

        // Run cleanup on page load/refresh
        window.addEventListener('load', cleanupTemporaryFiles);
        
        // Also run cleanup before page unload (additional safety)
        window.addEventListener('beforeunload', cleanupTemporaryFiles);

        // Enhanced Box Management Functions
        function updateBoxEditor() {
            const deleteBoxBtn = document.getElementById('deleteBoxBtn');
            if (sessionState.selectedBox) {
                // Enable delete button when a box is selected
                if (deleteBoxBtn) {
                    deleteBoxBtn.disabled = false;
                }
            } else {
                // Disable delete button when no box is selected
                if (deleteBoxBtn) {
                    deleteBoxBtn.disabled = true;
                }
            }
            
            // Update the create records button state
            updateCreateRecordsButtonState();
        }

        function updateBoxEditorValues(box) {
            if (!box) return;

            // Update CSV column dropdown
            const columnSelect = document.getElementById('boxColumnSelect');
            if (columnSelect) {
            columnSelect.innerHTML = '<option value="">Select CSV column...</option>';
                
                console.log('Updating CSV column dropdown. csvData:', csvData);
            
            if (csvData && csvData.length > 0) {
                const columns = Object.keys(csvData[0]);
                    console.log('CSV columns found:', columns);
                columns.forEach(column => {
                    const option = document.createElement('option');
                    option.value = column;
                    option.textContent = column;
                    option.selected = column === box.csvColumn;
                    columnSelect.appendChild(option);
                });
                } else {
                    console.log('No CSV data available for column dropdown');
                }
            }

            // Add event listeners
            addBoxEditorEventListeners(box);
        }

        function addBoxEditorEventListeners(box) {
            // CSV Column change
            const columnSelect = document.getElementById('boxColumnSelect');
            if (columnSelect) {
                columnSelect.onchange = function() {
                box.csvColumn = this.value;
                    if (box.boxType === 'text') {
                updateTextBoxContent(box);
                    } else if (box.boxType === 'image' && box.imageSource === 'csv') {
                        updateImageBoxWithCSVData(box);
                    }
                updateEditorStatus(`Box bound to CSV column: ${this.value || 'None'}`);
                updateCreateRecordsButtonState();
                };
            }
        }

        function duplicateSelectedBox() {
            if (!sessionState.selectedBox) return;

            const original = sessionState.selectedBox;
            const originalBoxObject = getSelectedBoxObject();
            
            if (original.style) {
                // DOM element - create a new DOM element
                const clone = original.cloneNode(true);
                clone.boxId = ++boxCounter;
                clone.boxType = originalBoxObject ? originalBoxObject.boxType : 'text';
                clone.csvColumn = originalBoxObject ? originalBoxObject.csvColumn : '';
                clone.imageSource = originalBoxObject ? originalBoxObject.imageSource : '';
                clone.imageUrl = originalBoxObject ? originalBoxObject.imageUrl : '';
                
                // Offset the clone
                const originalLeft = parseFloat(original.style.left) || 0;
                const originalTop = parseFloat(original.style.top) || 0;
                clone.style.left = (originalLeft + 20) + 'px';
                clone.style.top = (originalTop + 20) + 'px';
                

                
                // Add click handler for selection
                clone.addEventListener('click', function(e) {
                    e.stopPropagation();
                    // Remove selection from all boxes
                    document.querySelectorAll('.draggable-image-box, .draggable-text-box').forEach(box => {
                        box.classList.remove('selected');
                    });
                    clone.classList.add('selected');
                    sessionState.selectedBox = clone;
                    currentBoxId = clone.boxId;
                    updateBoxEditor();
                    updateBoxEditorValues(clone);
                });
                
                // Add to PDF viewer and enable drag/resize
                const pdfViewer = document.getElementById('pdfViewer');
                pdfViewer.appendChild(clone);
                enableDragResize(clone);
                
                // Create a proper box object for the clone
                const cloneBoxObject = {
                    boxId: clone.boxId,
                    boxType: clone.boxType,
                    csvColumn: clone.csvColumn,
                    imageSource: clone.imageSource,
                    imageUrl: clone.imageUrl,
                    element: clone
                };
                
                sessionState.boxes.push(cloneBoxObject);
                sessionState.selectedBox = clone;
                currentBoxId = clone.boxId;
                updateBoxEditorValues(cloneBoxObject);
            } else {
                // Fabric.js object
                if (!editorCanvas) return;
            const clone = fabric.util.object.clone(original);
            
            // Offset the clone
            clone.set({
                left: original.left + 20,
                top: original.top + 20,
                boxId: ++boxCounter
            });

            // Copy custom properties
            clone.boxType = original.boxType;
            clone.csvColumn = original.csvColumn;
            clone.staticText = original.staticText;
            clone.bold = original.bold;
            clone.italic = original.italic;
            clone.underline = original.underline;
            clone.imageSource = original.imageSource;
            clone.imageUrl = original.imageUrl;

            editorCanvas.add(clone);
            sessionState.boxes.push(clone);
            
            // Select the new clone
            sessionState.selectedBox = clone;
            currentBoxId = clone.boxId;
            updateBoxEditorValues(clone);
            }
            
            updateEditorStatus('Box duplicated');
            
            // Update download button state after duplication
            updateDownloadButtonState();
        }

        // Simple delete function based on MERGE-ONLINE approach
        function deleteSelectedBox() {
            if (!sessionState.selectedBox) return;

            const selectedItem = sessionState.selectedBox;
            
            console.log('=== DELETE DEBUG ===');
            console.log('Selected item:', selectedItem);
            console.log('Selected item type:', typeof selectedItem);
            console.log('Selected item properties:', Object.keys(selectedItem));
            console.log('sessionState.boxes:', sessionState.boxes);
            console.log('Boxes length:', sessionState.boxes.length);
            
            // Determine if selectedItem is a box object or DOM element
            let boxObject = null;
            let domElement = null;
            
            if (selectedItem.element && selectedItem.boxId) {
                // It's a box object with an element property
                boxObject = selectedItem;
                domElement = selectedItem.element;
                console.log('Found box object with element property');
            } else if (selectedItem.classList && (selectedItem.classList.contains('draggable-text-box') || selectedItem.classList.contains('draggable-image-box'))) {
                // It's a DOM element, find the corresponding box object
                domElement = selectedItem;
                boxObject = sessionState.boxes.find(box => box.element === selectedItem);
                console.log('Found DOM element, looking for box object:', boxObject);
            } else {
                // It's a box object stored directly
                boxObject = selectedItem;
                domElement = selectedItem.element || null;
                console.log('Found box object stored directly');
            }
            
            if (boxObject) {
                console.log('Box object found, removing...');
                
                // Remove from DOM if we have a DOM element
                if (domElement && domElement.remove) {
                    domElement.remove();
                    console.log('DOM element removed');
                } else {
                    console.log('No DOM element to remove or remove method not available');
                }
                
                // Remove from session state using ID (like MERGE-ONLINE)
                if (boxObject.boxId) {
                    sessionState.boxes = sessionState.boxes.filter(box => box.boxId !== boxObject.boxId);
                } else if (boxObject.id) {
                    sessionState.boxes = sessionState.boxes.filter(box => box.id !== boxObject.id);
                } else {
                    // Remove by direct reference if no ID
                    sessionState.boxes = sessionState.boxes.filter(box => box !== boxObject);
                }
                console.log('Box removed from sessionState.boxes');
            
            // Clear selection and remove selected class from all boxes
            document.querySelectorAll('.draggable-text-box.selected, .draggable-image-box.selected').forEach(box => {
                box.classList.remove('selected');
            });
            sessionState.selectedBox = null;
            
            // Hide box editor
            updateBoxEditor();
            
            updateEditorStatus('Box deleted');
            
            // Update download button state after deletion
            updateDownloadButtonState();
            
            // Update box scaling after deletion
            updateImageBoxScaling();
            updateTextBoxScaling();
            } else {
                console.error('Box not found in sessionState.boxes');
                console.log('Available boxes:', sessionState.boxes);
                updateEditorStatus('Error: Box not found');
            }
        }





        // Keyboard shortcuts for box management
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Delete key to delete selected box
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (sessionState.selectedBox) {
                        e.preventDefault();
                        deleteSelectedBox();
                    }
                }
                
                // Escape key to deselect
                if (e.key === 'Escape') {
                    if (sessionState.selectedBox) {
                        e.preventDefault();
                        document.querySelectorAll('.draggable-text-box.selected, .draggable-image-box.selected').forEach(box => {
                            box.classList.remove('selected');
                        });
                        sessionState.selectedBox = null;
                        updateBoxEditor();
                    }
                }
            });

            // Right-click context menu for boxes
            document.addEventListener('contextmenu', function(e) {
                const target = e.target;
                if (target.classList.contains('draggable-text-box') || target.classList.contains('draggable-image-box')) {
                    e.preventDefault();
                    
                    // Select the box if not already selected
                    if (!target.classList.contains('selected')) {
                        document.querySelectorAll('.draggable-text-box, .draggable-image-box').forEach(box => {
                            box.classList.remove('selected');
                        });
                        target.classList.add('selected');
                        
                        // Update session state
                        const boxObject = sessionState.boxes.find(b => b.element === target);
                        if (boxObject) {
                            sessionState.selectedBox = target; // Store the DOM element for consistency
                            updateBoxEditor();
                            updateBoxEditorValues(boxObject);
                        }
                    }
                    
                    // Show context menu
                    showBoxContextMenu(e.clientX, e.clientY, target);
                }
            });
        }

        // Context menu for boxes
        function showBoxContextMenu(x, y, boxElement) {
            // Remove existing context menu
            const existingMenu = document.getElementById('boxContextMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // Create context menu
            const contextMenu = document.createElement('div');
            contextMenu.id = 'boxContextMenu';
            contextMenu.style.cssText = `
                position: fixed;
                top: ${y}px;
                left: ${x}px;
                background: white;
                border: 1px solid #ccc;
                border-radius: 4px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                z-index: 1000;
                min-width: 150px;
                font-size: 14px;
            `;
            
            // Delete option
            const deleteOption = document.createElement('div');
            deleteOption.style.cssText = `
                padding: 8px 12px;
                cursor: pointer;
                border-bottom: 1px solid #eee;
                display: flex;
                align-items: center;
                gap: 8px;
            `;
            deleteOption.innerHTML = '🗑️ Delete Box';
            deleteOption.addEventListener('click', function() {
                deleteBox(boxElement);
                contextMenu.remove();
            });
            deleteOption.addEventListener('mouseenter', function() {
                this.style.background = '#f8f9fa';
            });
            deleteOption.addEventListener('mouseleave', function() {
                this.style.background = 'white';
            });
            
            // Duplicate option
            const duplicateOption = document.createElement('div');
            duplicateOption.style.cssText = `
                padding: 8px 12px;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 8px;
            `;
            duplicateOption.innerHTML = '📋 Duplicate Box';
            duplicateOption.addEventListener('click', function() {
                duplicateSelectedBox();
                contextMenu.remove();
            });
            duplicateOption.addEventListener('mouseenter', function() {
                this.style.background = '#f8f9fa';
            });
            duplicateOption.addEventListener('mouseleave', function() {
                this.style.background = 'white';
            });
            
            contextMenu.appendChild(deleteOption);
            contextMenu.appendChild(duplicateOption);
            document.body.appendChild(contextMenu);
            
            // Close context menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu() {
                    contextMenu.remove();
                    document.removeEventListener('click', closeMenu);
                });
            }, 100);
        }

        // Simple drag functionality for text boxes
        function makeDraggable(element) {
            let isDragging = false;
            let isResizing = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;
            let initialWidth;
            let initialHeight;
            let resizeHandle = '';

            // Add resize handles
            addResizeHandles(element);

            // Use mousedown on the element itself
            element.addEventListener('mousedown', dragStart);
            
            // Use document-level events for better drag handling
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            function dragStart(e) {
                // Prevent event from bubbling to PDF viewer
                e.stopPropagation();
                
                // Check if clicking on resize handle
                if (e.target.classList.contains('resize-handle')) {
                    isResizing = true;
                    isDragging = false;
                    resizeHandle = e.target.dataset.handle;
                    initialWidth = element.offsetWidth;
                    initialHeight = element.offsetHeight;
                    initialX = e.clientX;
                    initialY = e.clientY;
                    element.style.cursor = 'nwse-resize';
                    element.classList.add('resizing');
                    return;
                }

                // Normal dragging
                if (e.target === element) {
                    isDragging = true;
                    isResizing = false;
                    
                    // Get current position (accounting for any existing transform)
                    const currentLeft = parseInt(element.style.left) || 0;
                    const currentTop = parseInt(element.style.top) || 0;
                    
                    // Reset any existing transform
                    element.style.transform = 'translate(0px, 0px)';
                    
                    // Initialize drag tracking
                    initialX = e.clientX - currentLeft;
                    initialY = e.clientY - currentTop;
                    xOffset = currentLeft;
                    yOffset = currentTop;
                    
                    element.style.cursor = 'grabbing';
                    element.style.zIndex = '30';
                }
            }

            function drag(e) {
                if (isResizing) {
                    e.preventDefault();
                    e.stopPropagation();
                    const deltaX = e.clientX - initialX;
                    const deltaY = e.clientY - initialY;
                    
                    // Get the PDF viewer container for boundary constraints
                    const pdfViewer = document.getElementById('pdfViewer');
                    const viewerRect = pdfViewer.getBoundingClientRect();
                    const elementRect = element.getBoundingClientRect();
                    
                    // Calculate new dimensions and positions with constraints
                    let newWidth = initialWidth;
                    let newHeight = initialHeight;
                    let newLeft = parseInt(element.style.left) || 0;
                    let newTop = parseInt(element.style.top) || 0;
                    
                    // Handle right edge resize
                    if (resizeHandle.includes('e')) {
                        newWidth = Math.max(20, initialWidth + deltaX);
                        // Constrain to viewer width
                        const maxWidth = viewerRect.width - newLeft;
                        newWidth = Math.min(newWidth, maxWidth);
                    }
                    
                    // Handle left edge resize
                    if (resizeHandle.includes('w')) {
                        const proposedWidth = Math.max(20, initialWidth - deltaX);
                        const proposedLeft = newLeft + (initialWidth - proposedWidth);
                        
                        // Constrain to viewer boundaries
                        if (proposedLeft >= 0 && proposedLeft + proposedWidth <= viewerRect.width) {
                            newWidth = proposedWidth;
                            newLeft = proposedLeft;
                        }
                    }
                    
                    // Handle bottom edge resize
                    if (resizeHandle.includes('s')) {
                        newHeight = Math.max(15, initialHeight + deltaY);
                        // Constrain to viewer height
                        const maxHeight = viewerRect.height - newTop;
                        newHeight = Math.min(newHeight, maxHeight);
                    }
                    
                    // Handle top edge resize
                    if (resizeHandle.includes('n')) {
                        const proposedHeight = Math.max(15, initialHeight - deltaY);
                        const proposedTop = newTop + (initialHeight - proposedHeight);
                        
                        // Constrain to viewer boundaries
                        if (proposedTop >= 0 && proposedTop + proposedHeight <= viewerRect.height) {
                            newHeight = proposedHeight;
                            newTop = proposedTop;
                        }
                    }
                    
                    // Apply the constrained values
                    element.style.width = newWidth + 'px';
                    element.style.height = newHeight + 'px';
                    element.style.left = newLeft + 'px';
                    element.style.top = newTop + 'px';
                    
                    // Update font size based on box size
                    updateTextSize(element);
                } else if (isDragging) {
                    e.preventDefault();
                    e.stopPropagation();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;

                    // Get the PDF viewer container for boundary constraints
                    const pdfViewer = document.getElementById('pdfViewer');
                    const viewerRect = pdfViewer.getBoundingClientRect();
                    const elementRect = element.getBoundingClientRect();
                    
                    // Constrain dragging within viewer boundaries
                    const maxX = viewerRect.width - elementRect.width;
                    const maxY = viewerRect.height - elementRect.height;
                    
                    currentX = Math.max(0, Math.min(currentX, maxX));
                    currentY = Math.max(0, Math.min(currentY, maxY));
                    
                    xOffset = currentX;
                    yOffset = currentY;

                    // Apply constrained position directly
                    element.style.left = currentX + 'px';
                    element.style.top = currentY + 'px';
                }
            }

            function dragEnd(e) {
                // Prevent event from bubbling to PDF viewer
                e.stopPropagation();
                
                if (isResizing) {
                    isResizing = false;
                    element.style.cursor = 'move';
                    element.style.zIndex = '20';
                    resizeHandle = '';
                    element.classList.remove('resizing');
                    
                    // Update the box data in session state
                    if (sessionState.selectedBox && sessionState.selectedBox.element === element) {
                        sessionState.selectedBox.width = parseInt(element.style.width);
                        sessionState.selectedBox.height = parseInt(element.style.height);
                        sessionState.selectedBox.x = parseInt(element.style.left);
                        sessionState.selectedBox.y = parseInt(element.style.top);
                    }
                    
                } else if (isDragging) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                    element.style.cursor = 'move';
                    element.style.zIndex = '20';
                    clearSnapGuides();
                    
                    // Update the box data in session state
                    if (sessionState.selectedBox && sessionState.selectedBox.element === element) {
                        sessionState.selectedBox.x = parseInt(element.style.left);
                        sessionState.selectedBox.y = parseInt(element.style.top);
                    }
                }
            }
        }

        function addResizeHandles(element) {
            const handles = [
                { position: 'nw', cursor: 'nw-resize' },
                { position: 'n', cursor: 'n-resize' },
                { position: 'ne', cursor: 'ne-resize' },
                { position: 'e', cursor: 'e-resize' },
                { position: 'se', cursor: 'se-resize' },
                { position: 's', cursor: 's-resize' },
                { position: 'sw', cursor: 'sw-resize' },
                { position: 'w', cursor: 'w-resize' }
            ];

            handles.forEach(handle => {
                const handleElement = document.createElement('div');
                handleElement.className = 'resize-handle';
                handleElement.dataset.handle = handle.position;
                handleElement.style.cssText = `
                    position: absolute;
                    width: 12px;
                    height: 12px;
                    background: #ff6b35;
                    border: 2px solid white;
                    border-radius: 2px;
                    cursor: ${handle.cursor};
                    pointer-events: auto;
                    z-index: 25;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                `;

                // Position the handle
                switch (handle.position) {
                    case 'nw': handleElement.style.top = '-6px'; handleElement.style.left = '-6px'; break;
                    case 'n': handleElement.style.top = '-6px'; handleElement.style.left = '50%'; handleElement.style.transform = 'translateX(-50%)'; break;
                    case 'ne': handleElement.style.top = '-6px'; handleElement.style.right = '-6px'; break;
                    case 'e': handleElement.style.top = '50%'; handleElement.style.right = '-6px'; handleElement.style.transform = 'translateY(-50%)'; break;
                    case 'se': handleElement.style.bottom = '-6px'; handleElement.style.right = '-6px'; break;
                    case 's': handleElement.style.bottom = '-6px'; handleElement.style.left = '50%'; handleElement.style.transform = 'translateX(-50%)'; break;
                    case 'sw': handleElement.style.bottom = '-6px'; handleElement.style.left = '-6px'; break;
                    case 'w': handleElement.style.top = '50%'; handleElement.style.left = '-6px'; handleElement.style.transform = 'translateY(-50%)'; break;
                }

                element.appendChild(handleElement);
            });
        }

        // Snap-to-Grid System
        const GRID_SIZE = 50; // Grid size in pixels (increased from 20 for looser grid)
        const SNAP_THRESHOLD = 25; // Distance to snap in pixels (increased from 10 for gentler snapping)
        let snapToGridEnabled = false; // Toggle for snap-to-grid feature - DISABLED for free movement

        function toggleSnapToGrid() {
            snapToGridEnabled = document.getElementById('snapToGridToggle').checked;
            console.log('Snap-to-grid:', snapToGridEnabled ? 'ENABLED' : 'DISABLED');
        }

        function snapToGrid(x, y, element) {
            if (!snapToGridEnabled) {
                return { x: x, y: y };
            }
            
            const pdfViewer = document.getElementById('pdfViewer');
            const viewerRect = pdfViewer.getBoundingClientRect();
            
            // Get all other boxes for alignment guides
            const allBoxes = document.querySelectorAll('.draggable-text-box, .draggable-image-box');
            const otherBoxes = Array.from(allBoxes).filter(box => box !== element);
            
            let snappedX = x;
            let snappedY = y;
            
            // Snap to grid
            const gridX = Math.round(x / GRID_SIZE) * GRID_SIZE;
            const gridY = Math.round(y / GRID_SIZE) * GRID_SIZE;
            
            if (Math.abs(x - gridX) < SNAP_THRESHOLD) {
                snappedX = gridX;
            }
            if (Math.abs(y - gridY) < SNAP_THRESHOLD) {
                snappedY = gridY;
            }
            
            // Snap to other boxes (alignment guides)
            otherBoxes.forEach(box => {
                const boxRect = box.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();
                
                // Vertical alignment (left, center, right)
                const leftAlign = Math.abs((boxRect.left - viewerRect.left) - (elementRect.left - viewerRect.left + x));
                const centerAlign = Math.abs((boxRect.left + boxRect.width/2 - viewerRect.left) - (elementRect.left + elementRect.width/2 - viewerRect.left + x));
                const rightAlign = Math.abs((boxRect.right - viewerRect.left) - (elementRect.right - viewerRect.left + x));
                
                // Horizontal alignment (top, middle, bottom)
                const topAlign = Math.abs((boxRect.top - viewerRect.top) - (elementRect.top - viewerRect.top + y));
                const middleAlign = Math.abs((boxRect.top + boxRect.height/2 - viewerRect.top) - (elementRect.top + elementRect.height/2 - viewerRect.top + y));
                const bottomAlign = Math.abs((boxRect.bottom - viewerRect.top) - (elementRect.bottom - viewerRect.top + y));
                
                // Apply snapping with visual guides
                if (leftAlign < SNAP_THRESHOLD) {
                    snappedX = (boxRect.left - viewerRect.left) - (elementRect.left - viewerRect.left);
                    showSnapGuide('vertical', boxRect.left - viewerRect.left);
                } else if (centerAlign < SNAP_THRESHOLD) {
                    snappedX = (boxRect.left + boxRect.width/2 - viewerRect.left) - (elementRect.left + elementRect.width/2 - viewerRect.left);
                    showSnapGuide('vertical', boxRect.left + boxRect.width/2 - viewerRect.left);
                } else if (rightAlign < SNAP_THRESHOLD) {
                    snappedX = (boxRect.right - viewerRect.left) - (elementRect.right - viewerRect.left);
                    showSnapGuide('vertical', boxRect.right - viewerRect.left);
                }
                
                if (topAlign < SNAP_THRESHOLD) {
                    snappedY = (boxRect.top - viewerRect.top) - (elementRect.top - viewerRect.top);
                    showSnapGuide('horizontal', boxRect.top - viewerRect.top);
                } else if (middleAlign < SNAP_THRESHOLD) {
                    snappedY = (boxRect.top + boxRect.height/2 - viewerRect.top) - (elementRect.top + elementRect.height/2 - viewerRect.top);
                    showSnapGuide('horizontal', boxRect.top + boxRect.height/2 - viewerRect.top);
                } else if (bottomAlign < SNAP_THRESHOLD) {
                    snappedY = (boxRect.bottom - viewerRect.top) - (elementRect.bottom - viewerRect.top);
                    showSnapGuide('horizontal', boxRect.bottom - viewerRect.top);
                }
            });
            
            return { x: snappedX, y: snappedY };
        }

        function showSnapGuide(type, position) {
            // Remove existing guides
            clearSnapGuides();
            
            const guide = document.createElement('div');
            guide.className = `snap-guide ${type}`;
            guide.style.position = 'absolute';
            
            if (type === 'vertical') {
                guide.style.left = position + 'px';
                guide.style.top = '0';
                guide.style.height = '100%';
            } else {
                guide.style.top = position + 'px';
                guide.style.left = '0';
                guide.style.width = '100%';
            }
            
            document.getElementById('pdfViewer').appendChild(guide);
            
            // Remove guide after a short delay
            setTimeout(() => {
                if (guide.parentNode) {
                    guide.parentNode.removeChild(guide);
                }
            }, 500);
        }

        function clearSnapGuides() {
            const guides = document.querySelectorAll('.snap-guide');
            guides.forEach(guide => guide.remove());
        }

        function updateTextSize(element) {
            if (element.classList.contains('draggable-text-box')) {
                const width = element.offsetWidth;
                const height = element.offsetHeight;
                
                // Only adjust padding to maintain text centering, don't resize font
                const padding = Math.max(5, Math.min(width, height) / 10);
                element.style.padding = padding + 'px';
            }
        }

        // PDF Dragging and Zooming Functionality

        function initPDFDragging() {
            pdfViewer = document.getElementById('pdfViewer');
            pdfContent = document.getElementById('pdfContent');
            
            if (!pdfViewer || !pdfContent) return;

            // Mouse events for dragging
            pdfViewer.addEventListener('mousedown', startDragging);
            pdfViewer.addEventListener('mousemove', drag);
            pdfViewer.addEventListener('mouseup', stopDragging);
            pdfViewer.addEventListener('mouseleave', stopDragging);
            
            // Add click handler to deselect text boxes when clicking on empty space
            pdfViewer.addEventListener('click', function(e) {
                // Only deselect if we're clicking on the viewer itself (not on a text box)
                if (e.target === pdfViewer || e.target.id === 'viewer' || e.target.id === 'pdfContent') {
                    document.querySelectorAll('.draggable-text-box').forEach(box => {
                        box.classList.remove('selected');
                    });
                    sessionState.selectedBox = null;
                    updateBoxEditor();
                }
            });
            
            // Touch events for mobile
            pdfViewer.addEventListener('touchstart', startDraggingTouch);
            pdfViewer.addEventListener('touchmove', dragTouch);
            pdfViewer.addEventListener('touchend', stopDragging);
            
            // Wheel event for zooming
            pdfViewer.addEventListener('wheel', handleWheel);
            
            // Prevent context menu
            pdfViewer.addEventListener('contextmenu', e => e.preventDefault());
        }

        function startDragging(e) {
            // Don't start dragging if clicking on controls, if we're in editor mode, or if PDF is locked
            if (e.target.closest('.pdf-controls') || isEditorMode || pdfLocked) return;
            
            isDragging = true;
            lastMousePos = { x: e.clientX, y: e.clientY };
            pdfViewer.classList.add('dragging');
            e.preventDefault();
        }

        function startDraggingTouch(e) {
            if (e.target.closest('.pdf-controls') || isEditorMode || pdfLocked) return;
            
            isDragging = true;
            lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            pdfViewer.classList.add('dragging');
            e.preventDefault();
        }

        function drag(e) {
            if (!isDragging) return;
            
            const currentPos = { x: e.clientX, y: e.clientY };
            const deltaX = currentPos.x - lastMousePos.x;
            const deltaY = currentPos.y - lastMousePos.y;
            
            currentTransform.x += deltaX;
            currentTransform.y += deltaY;
            
            updatePDFTransform();
            lastMousePos = currentPos;
            e.preventDefault();
        }

        function dragTouch(e) {
            if (!isDragging) return;
            
            const currentPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            const deltaX = currentPos.x - lastMousePos.x;
            const deltaY = currentPos.y - lastMousePos.y;
            
            currentTransform.x += deltaX;
            currentTransform.y += deltaY;
            
            updatePDFTransform();
            lastMousePos = currentPos;
            e.preventDefault();
        }

        function stopDragging() {
            isDragging = false;
            pdfViewer.classList.remove('dragging');
        }

        function handleWheel(e) {
            if (isEditorMode || pdfLocked) return; // Don't zoom when editing or if PDF is locked
            
            e.preventDefault();
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(5, currentTransform.scale * zoomFactor));
            
            // Zoom towards mouse position
            const rect = pdfContent.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const scaleChange = newScale / currentTransform.scale;
            currentTransform.x = mouseX - (mouseX - currentTransform.x) * scaleChange;
            currentTransform.y = mouseY - (mouseY - currentTransform.y) * scaleChange;
            currentTransform.scale = newScale;
            
            updatePDFTransform();
        }

        function updatePDFTransform() {
            if (!pdfContent) return;
            
            pdfContent.style.transform = `translate(${currentTransform.x}px, ${currentTransform.y}px) scale(${currentTransform.scale})`;
            
            // Update zoom display
            const zoomDisplay = document.getElementById('zoomDisplay');
            if (zoomDisplay) {
                zoomDisplay.textContent = Math.round(currentTransform.scale * 100) + '%';
            }
            
            // Update editor canvas if it exists
            if (editorCanvas) {
                editorCanvas.setZoom(currentTransform.scale);
                editorCanvas.renderAll();
            }
            
            // Update image box scaling to match PDF viewer
            updateImageBoxScaling();
            
            // Update text box scaling to match PDF viewer
            updateTextBoxScaling();
            
            // Update PDF area outline to match transform
            updatePdfAreaOutline();
        }
        
        // Function to update image box scaling to match PDF viewer zoom
        function updateImageBoxScaling() {
            const imageBoxes = document.querySelectorAll('.draggable-image-box');
            imageBoxes.forEach(box => {
                // Get the box's original position and size from data attributes or stored values
                const originalLeft = parseFloat(box.getAttribute('data-original-left') || box.style.left);
                const originalTop = parseFloat(box.getAttribute('data-original-top') || box.style.top);
                const originalWidth = parseFloat(box.getAttribute('data-original-width') || box.style.width);
                const originalHeight = parseFloat(box.getAttribute('data-original-height') || box.style.height);
                
                // Store original values if not already stored
                if (!box.hasAttribute('data-original-left')) {
                    box.setAttribute('data-original-left', box.style.left);
                    box.setAttribute('data-original-top', box.style.top);
                    box.setAttribute('data-original-width', box.style.width);
                    box.setAttribute('data-original-height', box.style.height);
                }
                
                // Calculate new position and size based on zoom
                const newLeft = originalLeft * currentTransform.scale;
                const newTop = originalTop * currentTransform.scale;
                const newWidth = originalWidth * currentTransform.scale;
                const newHeight = originalHeight * currentTransform.scale;
                
                // Apply the transform with proper positioning
                box.style.transform = `translate(${newLeft - originalLeft}px, ${newTop - originalTop}px) scale(${currentTransform.scale})`;
                
                // Add smooth transition for zoom changes
                box.style.transition = 'transform 0.2s ease-out';
            });
        }
        
        // Enhanced function to update text box scaling to match PDF viewer zoom
        function updateTextBoxScaling() {
            const textBoxes = document.querySelectorAll('.draggable-text-box');
            textBoxes.forEach(box => {
                // Get the box's original position and size from data attributes or stored values
                const originalLeft = parseFloat(box.getAttribute('data-original-left') || box.style.left);
                const originalTop = parseFloat(box.getAttribute('data-original-top') || box.style.top);
                const originalWidth = parseFloat(box.getAttribute('data-original-width') || box.style.width);
                const originalHeight = parseFloat(box.getAttribute('data-original-height') || box.style.height);
                
                // Store original values if not already stored
                if (!box.hasAttribute('data-original-left')) {
                    box.setAttribute('data-original-left', box.style.left);
                    box.setAttribute('data-original-top', box.style.top);
                    box.setAttribute('data-original-width', box.style.width);
                    box.setAttribute('data-original-height', box.style.height);
                }
                
                // Calculate new position and size based on zoom
                const newLeft = originalLeft * currentTransform.scale;
                const newTop = originalTop * currentTransform.scale;
                const newWidth = originalWidth * currentTransform.scale;
                const newHeight = originalHeight * currentTransform.scale;
                
                // Apply the transform with proper positioning
                box.style.transform = `translate(${newLeft - originalLeft}px, ${newTop - originalTop}px) scale(${currentTransform.scale})`;
                
                // Add smooth transition for zoom changes
                box.style.transition = 'transform 0.2s ease-out';
            });
        }
        
        // Enhanced zoom functionality with mouse wheel support
        function setupMouseWheelZoom() {
            const pdfViewer = document.getElementById('pdfViewer');
            if (!pdfViewer) return;
            
            pdfViewer.addEventListener('wheel', function(e) {
                // Only zoom if Ctrl key is pressed (standard zoom behavior)
                if (e.ctrlKey) {
                    e.preventDefault();
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newScale = Math.max(0.1, Math.min(5, currentTransform.scale * zoomFactor));
                    
                    // Calculate zoom center (mouse position)
                    const rect = pdfViewer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Update transform with zoom centered on mouse
                    currentTransform.scale = newScale;
                    updatePDFTransform();
                    updateOutlineOnZoom();
                }
            });
        }
        
        // Function to pre-load all images for html2canvas capture with progress bar
        async function preloadAllImages() {
            const imageBoxes = document.querySelectorAll('.draggable-image-box img');
            
            if (imageBoxes.length === 0) {
                console.log('No images to preload');
                return;
            }

            // Show progress overlay
            const overlay = document.getElementById('imageLoadingOverlay');
            const progressBar = document.getElementById('imageProgressBar');
            const progressText = document.getElementById('imageProgressText');
            const subtitle = document.getElementById('imageLoadingSubtitle');
            
            overlay.classList.add('active');
            subtitle.textContent = `Loading ${imageBoxes.length} image${imageBoxes.length > 1 ? 's' : ''}...`;
            
            let loadedCount = 0;
            const totalImages = imageBoxes.length;
            
            const imagePromises = Array.from(imageBoxes).map((img, index) => {
                return new Promise((resolve, reject) => {
                    if (img.complete && img.naturalWidth > 0) {
                        // Image already loaded
                        loadedCount++;
                        updateProgress(loadedCount, totalImages, progressBar, progressText);
                        resolve();
                    } else {
                        img.onload = () => {
                            loadedCount++;
                            updateProgress(loadedCount, totalImages, progressBar, progressText);
                            resolve();
                        };
                        img.onerror = () => {
                            // Continue even if some images fail
                            loadedCount++;
                            updateProgress(loadedCount, totalImages, progressBar, progressText);
                            resolve();
                        };
                        // Force reload if needed
                        if (img.src) {
                            img.src = img.src;
                        }
                    }
                });
            });
            
            // Wait for all images to load (with timeout)
            await Promise.allSettled(imagePromises);
            
            // Additional wait to ensure images are fully rendered
            subtitle.textContent = 'Finalizing image preparation...';
            await new Promise(resolve => setTimeout(resolve, 100)); // Reduced from 200ms
            
            // Hide progress overlay
            overlay.classList.remove('active');
            
            console.log(`All ${totalImages} images pre-loaded for capture`);
        }

        // Helper function to update progress bar
        function updateProgress(loaded, total, progressBar, progressText) {
            const percentage = Math.round((loaded / total) * 100);
            progressBar.style.width = percentage + '%';
            progressText.textContent = `${percentage}% (${loaded}/${total})`;
        }
        
        // Function to style image boxes for html2canvas capture - matching MERGE-ONLINE behavior
        function styleImageBoxForCapture(img) {
            if (img) {
                // Use natural image dimensions for download (like MERGE-ONLINE)
                img.style.width = img.naturalWidth + 'px';
                img.style.height = img.naturalHeight + 'px';
                img.style.maxWidth = 'none';
                img.style.maxHeight = 'none';
                img.style.objectFit = 'none';
                img.style.display = 'block';
                // Force image to be visible and loaded
                img.style.opacity = '1';
                img.style.visibility = 'visible';
                // Ensure cross-origin is set for html2canvas
                img.crossOrigin = 'anonymous';
                // Remove any transform that might affect capture
                img.style.transform = 'none';
                // Ensure image is fully loaded and rendered
                img.style.imageRendering = 'auto';
                img.style.imageRendering = 'crisp-edges';
            }
        }
        
        // Function to hide UI elements for html2canvas capture
        function hideUIElementsForCapture(clonedViewer) {
            // Remove resize handles
            const resizeHandles = clonedViewer.querySelectorAll('.resize-handle');
            resizeHandles.forEach(handle => {
                handle.style.display = 'none';
            });
            
            // Hide any other UI elements that shouldn't be captured
            const uiElements = clonedViewer.querySelectorAll('.resize-handle, .pdf-controls');
            uiElements.forEach(element => {
                element.style.display = 'none';
            });
        }

        function togglePDFLock() {
            pdfLocked = !pdfLocked;
            
            // Update cursor style
            if (pdfViewer) {
                pdfViewer.style.cursor = pdfLocked ? 'default' : 'grab';
            }
            
            // Update lock status display
            updatePDFLockStatus();
        }

        function updatePDFLockStatus() {
            // Create or update lock status indicator
            let lockIndicator = document.getElementById('pdfLockIndicator');
            if (!lockIndicator) {
                lockIndicator = document.createElement('div');
                lockIndicator.id = 'pdfLockIndicator';
                lockIndicator.style.cssText = `
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    background: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 4px 8px;
                    border-radius: 3px;
                    font-size: 10px;
                    z-index: 100;
                `;
                document.querySelector('.pdf-viewer').appendChild(lockIndicator);
            }
            
            lockIndicator.textContent = pdfLocked ? 'PDF Locked' : 'PDF Unlocked';
            lockIndicator.style.background = pdfLocked ? 'rgba(220, 53, 69, 0.8)' : 'rgba(40, 167, 69, 0.8)';
            lockIndicator.style.display = 'none'; // Hide lock indicator by default
            
            // Update lock button
            const lockBtn = document.getElementById('pdfLockBtn');
            if (lockBtn) {
                lockBtn.textContent = pdfLocked ? '🔒' : '🔓';
                lockBtn.title = pdfLocked ? 'Unlock PDF' : 'Lock PDF';
            }
        }

        function resetView() {
            currentTransform = { x: 0, y: 0, scale: 1 };
            updatePDFTransform();
            
            // Reset all boxes to their original positions and remove zoom transforms
            resetAllBoxesToOriginal();
        }
        
        // Function to reset all boxes to their original positions and sizes
        function resetAllBoxesToOriginal() {
            const allBoxes = document.querySelectorAll('.draggable-text-box, .draggable-image-box');
            allBoxes.forEach(box => {
                // Remove any existing transforms
                box.style.transform = '';
                box.style.transition = 'none';
                
                // Restore original positions and sizes if they were stored
                if (box.hasAttribute('data-original-left')) {
                    box.style.left = box.getAttribute('data-original-left');
                    box.style.top = box.getAttribute('data-original-top');
                    box.style.width = box.getAttribute('data-original-width');
                    box.style.height = box.getAttribute('data-original-height');
                }
            });
        }

        function zoomIn() {
            const newScale = Math.min(5, currentTransform.scale * 1.2);
            currentTransform.scale = newScale;
            updatePDFTransform();
            updateOutlineOnZoom();
        }

        function zoomOut() {
            const newScale = Math.max(0.1, currentTransform.scale / 1.2);
            currentTransform.scale = newScale;
            updatePDFTransform();
            updateOutlineOnZoom();
        }

        function updateEditorStatus(message) {
            // Create status element if it doesn't exist
            let statusElement = document.getElementById('editorStatus');
            if (!statusElement) {
                statusElement = document.createElement('div');
                statusElement.id = 'editorStatus';
                statusElement.className = 'editor-status';
                document.querySelector('.viewer-container').appendChild(statusElement);
            }
            statusElement.textContent = message;
        }

        function saveLayout() {
            if (!editorCanvas) return;

            const layout = {
                page: {
                    size: 'A4',
                    orient: 'portrait'
                },
                objects: []
            };

            // Collect all objects
            editorCanvas.getObjects().forEach(obj => {
                const objectData = {
                    type: obj.type,
                    left: Math.round(obj.left),
                    top: Math.round(obj.top),
                    width: Math.round(obj.width || obj.scaleX * 100),
                    height: Math.round(obj.height || obj.scaleY * 100),
                    meta: obj.meta || {}
                };

                // Add type-specific properties
                if (obj.type === 'text') {
                    objectData.text = obj.text;
                    objectData.fontSize = obj.fontSize;
                    objectData.fontFamily = obj.fontFamily;
                    objectData.fill = obj.fill;
                } else if (obj.type === 'group') {
                    objectData.groupType = 'imagePlaceholder';
                }

                layout.objects.push(objectData);
            });

            // Create and download JSON file
            const jsonString = JSON.stringify(layout, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `layout-A4-portrait-${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            
            updateEditorStatus('Layout saved as JSON');
        }

        // Generate Sample PDF function
        async function generateSamplePDF() {
            try {
                // Create a new PDF document
                const pdfDoc = await PDFLib.PDFDocument.create();
                
                // Add a page
                const page = pdfDoc.addPage([595, 842]); // A4 size
                
                // Get the current ISO timestamp
                const timestamp = new Date().toISOString();
                
                // Add text to the page
                page.drawText(`Generated at ${timestamp}`, {
                    x: 50,
                    y: 750,
                    size: 20,
                    color: PDFLib.rgb(0, 0, 0)
                });
                
                // Add some sample content
                page.drawText('This is a sample PDF generated by PDF-lib', {
                    x: 50,
                    y: 700,
                    size: 14,
                    color: PDFLib.rgb(0.2, 0.2, 0.2)
                });
                
                page.drawText('You can use this as a template for testing', {
                    x: 50,
                    y: 670,
                    size: 12,
                    color: PDFLib.rgb(0.4, 0.4, 0.4)
                });
                
                // Save the PDF as bytes
                const pdfBytes = await pdfDoc.save();
                
                // Create a blob and download link
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                
                // Create and trigger download
                const link = document.createElement('a');
                link.href = url;
                link.download = `sample-${Date.now()}.pdf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the URL
                URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error generating sample PDF:', error);
                alert('Error generating sample PDF: ' + error.message);
            }
        }

        // Download PDFs function - Hybrid High Quality (Single Record Mode Only)
        async function downloadPdfs() {
            try {
                console.log(`=== HYBRID HIGH QUALITY PDF GENERATION (SINGLE RECORD MODE) ===`);
                
                // Step 1: Validate inputs
                console.log('Step 1: Validating inputs...');
                if (!sessionState.templatePdfBytes) {
                    throw new Error('No PDF template loaded');
                }
                if (!sessionState.csvRows || sessionState.csvRows.length === 0) {
                    throw new Error('No CSV data loaded');
                }
                if (!sessionState.boxes || sessionState.boxes.length === 0) {
                    throw new Error('No boxes configured');
                }
                
                // Check if we have at least some boxes with CSV data
                const hasTextBoxes = sessionState.boxes.some(box => box.type === 'text' && box.csvColumn);
                const hasImageBoxes = sessionState.boxes.some(box => box.boxType === 'image' && box.csvColumn);
                
                if (!hasTextBoxes && !hasImageBoxes) {
                    throw new Error('No boxes with CSV data configured. Please add text boxes or image boxes with CSV field bindings.');
                }
                
                console.log(`✓ Inputs valid: ${sessionState.csvRows.length} CSV rows, ${sessionState.boxes.length} total boxes (${hasTextBoxes ? 'text' : ''}${hasTextBoxes && hasImageBoxes ? ' + ' : ''}${hasImageBoxes ? 'image' : ''})`);

                const downloadBtn = document.getElementById('downloadPdfsBtn');
                downloadBtn.disabled = true;
                downloadBtn.textContent = `Generating Single Record PDFs...`;

                // Step 2: Load JSZip
                console.log('Step 2: Loading JSZip...');
                const JSZipScript = document.getElementById('jszip-cdn');
                if (!window.JSZip && !JSZipScript) {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                    script.id = 'jszip-cdn';
                    document.body.appendChild(script);
                    await new Promise(res => { script.onload = res; });
                } else if (!window.JSZip && JSZipScript) {
                    await new Promise(res => { JSZipScript.onload = res; });
                }
                console.log('✓ JSZip loaded');

                const zip = new JSZip();
                const totalRecords = sessionState.csvRows.length;
                
                // Create unified progress bar for entire process
                const progressOverlay = document.createElement('div');
                progressOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 9999;
                `;
                
                const progressContent = document.createElement('div');
                progressContent.style.cssText = `
                    background: white;
                    border-radius: 8px;
                    padding: 30px;
                    text-align: center;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                    max-width: 400px;
                    width: 90%;
                `;
                
                const progressTitle = document.createElement('div');
                progressTitle.style.cssText = `
                    font-size: 18px;
                    font-weight: 600;
                    color: #333;
                    margin-bottom: 20px;
                `;
                progressTitle.textContent = `Generating Single Record PDFs`;
                
                const progressSubtitle = document.createElement('div');
                progressSubtitle.style.cssText = `
                    font-size: 14px;
                    color: #666;
                    margin-bottom: 25px;
                `;
                progressSubtitle.textContent = `Processing ${totalRecords} records...`;
                
                const progressContainer = document.createElement('div');
                progressContainer.style.cssText = `
                    background: #f0f0f0;
                    border-radius: 20px;
                    height: 8px;
                    margin-bottom: 15px;
                    overflow: hidden;
                `;
                
                const progressBar = document.createElement('div');
                progressBar.style.cssText = `
                    background: linear-gradient(90deg, #007bff, #0056b3);
                    height: 100%;
                    width: 0%;
                    transition: width 0.3s ease;
                    border-radius: 20px;
                `;
                
                const progressText = document.createElement('div');
                progressText.style.cssText = `
                    font-size: 12px;
                    color: #666;
                    margin-bottom: 10px;
                `;
                progressText.textContent = '0%';
                
                const progressDetails = document.createElement('div');
                progressDetails.style.cssText = `
                    font-size: 11px;
                    color: #999;
                `;
                progressDetails.textContent = `0 of ${totalRecords} records processed`;
                
                // Assemble progress bar
                progressContainer.appendChild(progressBar);
                progressContent.appendChild(progressTitle);
                progressContent.appendChild(progressSubtitle);
                progressContent.appendChild(progressContainer);
                progressContent.appendChild(progressText);
                progressContent.appendChild(progressDetails);
                progressOverlay.appendChild(progressContent);
                document.body.appendChild(progressOverlay);
                
                // Progress tracking function
                let processedRecords = 0;
                const updateProgress = (step = 1, stepDescription = '') => {
                    processedRecords += step;
                    const percentage = Math.round((processedRecords / totalRecords) * 100);
                    progressBar.style.width = percentage + '%';
                    progressText.textContent = `${percentage}%`;
                    progressDetails.textContent = `${processedRecords} of ${totalRecords} records processed${stepDescription ? ` - ${stepDescription}` : ''}`;
                };

                try {
                    // SINGLE RECORD MODE: One PDF per record
                    console.log('=== SINGLE RECORD MODE ===');
                        
                        for (let recordIndex = 0; recordIndex < totalRecords; recordIndex++) {
                            console.log(`\n--- Processing Record ${recordIndex + 1}/${totalRecords} ---`);
                            
                            const row = sessionState.csvRows[recordIndex];
                            console.log(`Processing record: ${JSON.stringify(row)}`);

                            // Step 3a: Load the template PDF (crisp vector background)
                            console.log('Step 3a: Loading template PDF...');
                            const pdfDoc = await PDFLib.PDFDocument.load(sessionState.templatePdfBytes);
                            
                            // Get the first page
                            const pages = pdfDoc.getPages();
                            if (pages.length === 0) {
                                throw new Error('Template PDF has no pages');
                            }
                            
                            const page = pages[0];
                            
                            // Step 3b: Update UI to show current record data
                            console.log('Step 3b: Updating UI for overlay capture...');
                            
                            // Set current record for this PDF
                            currentRecord = recordIndex;
                            
                            // Update text boxes and image boxes with current record data (single record mode)
                            updateAllTextBoxesForSingleRecord(recordIndex);
                            
                            // Wait for UI to update and ensure images are loaded
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduced from 150ms
                            
                            // Pre-load all images to ensure they're ready for capture
                            progressSubtitle.textContent = 'Loading images...';
                            await preloadAllImages();
                            progressSubtitle.textContent = `Processing ${totalRecords} records...`;
                            
                            // Step 3c: Capture high-resolution overlay (text boxes and image boxes)
                            console.log('Step 3c: Capturing high-res overlays...');
                            const pdfViewer = document.getElementById('pdfViewer');
                            const canvas = document.getElementById('viewer');
                            
                            if (!pdfViewer || !canvas) {
                                throw new Error('PDF viewer not found');
                            }
                            
                            // Get PDF area dimensions
                            const canvasRect = canvas.getBoundingClientRect();
                            const viewerRect = pdfViewer.getBoundingClientRect();
                            const pdfAreaX = canvasRect.left - viewerRect.left;
                            const pdfAreaY = canvasRect.top - viewerRect.top;
                            const pdfAreaWidth = canvasRect.width;
                            const pdfAreaHeight = canvasRect.height;
                            
                            // Calculate optimized scale factor for overlays (balanced quality/speed)
                            let scale = 4; // Reduced from 8 for better performance
                            const img = canvas.querySelector('img');
                            if (img && img.naturalWidth && img.width) {
                                const originalScale = img.naturalWidth / img.width;
                                scale = Math.max(3, originalScale * 1.5); // Reduced multiplier for speed
                            }
                            scale = Math.max(2, Math.min(8, scale)); // Reduced range for faster processing
                            
                            // Capture only the overlay elements with transparency
                            const overlayCanvas = await html2canvas(pdfViewer, {
                                scale: scale,
                                useCORS: true,
                                allowTaint: true,
                                backgroundColor: null, // Transparent background
                                logging: false,
                                x: pdfAreaX,
                                y: pdfAreaY,
                                width: pdfAreaWidth,
                                height: pdfAreaHeight,
                                onclone: (clonedDoc) => {
                                    const clonedViewer = clonedDoc.getElementById('pdfViewer');
                                    if (clonedViewer) {
                                        // Hide the PDF background completely
                                        const pdfCanvas = clonedDoc.getElementById('viewer');
                                        if (pdfCanvas) {
                                            pdfCanvas.style.display = 'none';
                                        }
                                        
                                        // Hide UI elements
                                        const outline = clonedDoc.getElementById('pdfAreaOutline');
                                        if (outline) outline.style.display = 'none';
                                        
                                        const lockIndicator = clonedViewer.querySelector('.pdf-lock-indicator');
                                        if (lockIndicator) lockIndicator.style.display = 'none';
                                        
                                        // Keep only text boxes and image boxes with their styling
                                        const allBoxes = clonedViewer.querySelectorAll('.draggable-text-box, .draggable-image-box');
                                        allBoxes.forEach(box => {
                                            if (box.classList.contains('draggable-text-box')) {
                                                // Text box styling
                                                box.style.border = 'none';
                                                box.style.background = 'transparent';
                                                box.style.boxShadow = 'none';
                                                box.style.outline = 'none';
                                                // Keep font styling for quality
                                                box.style.fontFamily = box.style.fontFamily || 'Arial, sans-serif';
                                                box.style.fontSize = box.style.fontSize || '16px';
                                                box.style.fontWeight = box.style.fontWeight || 'normal';
                                                box.style.color = box.style.color || '#000000';
                                            } else if (box.classList.contains('draggable-image-box')) {
                                                // Image box styling
                                                box.style.border = 'none';
                                                box.style.background = 'transparent';
                                                box.style.boxShadow = 'none';
                                                box.style.outline = 'none';
                                                // Ensure images are visible and properly sized
                                                const img = box.querySelector('img');
                                                if (img) {
                                                    img.style.width = '100%';
                                                    img.style.height = '100%';
                                                    img.style.objectFit = 'contain';
                                                    img.style.display = 'block';
                                                }
                                            }
                                        });
                                        
                                        // Remove resize handles (use !important to override CSS)
                                        const resizeHandles = clonedViewer.querySelectorAll('.resize-handle');
                                        resizeHandles.forEach(handle => {
                                            handle.style.setProperty('display', 'none', 'important');
                                            handle.style.setProperty('opacity', '0', 'important');
                                        });
                                        
                                        // Hide "No Image" text in downloaded PDFs
                                        const imageBoxes = clonedViewer.querySelectorAll('.draggable-image-box');
                                        imageBoxes.forEach(box => {
                                            if (box.textContent === 'No Image') {
                                                box.textContent = '';
                                            }
                                        });
                                        
                                        // Make background transparent
                                        clonedViewer.style.background = 'transparent';
                                        
                                        // Hide PDF controls (top right corner buttons)
                                        const pdfControls = clonedViewer.querySelector('.pdf-controls');
                                        if (pdfControls) pdfControls.style.display = 'none';
                                        
                                        // Fix image stretching for all image boxes before capture
                                        const imageImgs = clonedViewer.querySelectorAll('.draggable-image-box img');
                                        imageImgs.forEach(img => {
                                            if (img.naturalWidth && img.naturalHeight) {
                                                const naturalWidth = img.naturalWidth;
                                                const naturalHeight = img.naturalHeight;
                                                const boxWidth = img.parentElement.offsetWidth;
                                                const boxHeight = img.parentElement.offsetHeight;
                                                
                                                const imageAspect = naturalWidth / naturalHeight;
                                                const boxAspect = boxWidth / boxHeight;
                                                
                                                if (imageAspect > boxAspect) {
                                                    img.style.width = '100%';
                                                    img.style.height = 'auto';
                                                } else {
                                                    img.style.width = 'auto';
                                                    img.style.height = '100%';
                                                }
                                                
                                                img.style.objectFit = 'none';
                                                img.style.objectPosition = 'center';
                                            }
                                        });
                                    }
                                }
                            });
                            

                            
                            // Step 3d: Convert overlay to PNG with transparency
                            console.log('Step 3d: Converting overlay to PNG...');
                            const overlayPngDataUrl = overlayCanvas.toDataURL('image/png', 1.0);
                            
                            // Step 3e: Embed overlay image into PDF
                            console.log('Step 3e: Embedding overlay into PDF...');
                            const overlayImage = await pdfDoc.embedPng(overlayPngDataUrl);
                            
                            // Get page dimensions
                            const { width: pageWidth, height: pageHeight } = page.getSize();
                            
                            // Add overlay image to page (full page coverage)
                            page.drawImage(overlayImage, {
                                x: 0,
                                y: 0,
                                width: pageWidth,
                                height: pageHeight,
                            });
                            
                            // Step 3f: Save the hybrid PDF
                            console.log('Step 3f: Saving hybrid PDF...');
                            const pdfBytes = await pdfDoc.save();
                            
                            // Step 3g: Add to zip with record-specific naming
                            const recordNumber = recordIndex + 1;
                            const fileName = `single_record_${recordNumber}_of_${totalRecords}.pdf`;
                            zip.file(fileName, pdfBytes);
                            
                            console.log(`✓ Single record ${recordNumber} added to zip: ${fileName}`);
                            
                            // Update progress
                            updateProgress(1, 'PDF generated');
                        }
                    
                    // Step 4: Download zip file
                    console.log('Step 4: Generating zip file...');
                    progressSubtitle.textContent = 'Creating zip file...';
                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    
                    // Create download link with single record naming
                    const url = URL.createObjectURL(zipBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `single_record_high_quality_pdfs_${totalRecords}_records.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    console.log(`✓ Single Record high-quality download complete!`);
                    
                } catch (error) {
                    console.error('Error during PDF generation:', error);
                    
                    // Remove progress overlay on error
                    if (progressOverlay && progressOverlay.parentNode) {
                        progressOverlay.parentNode.removeChild(progressOverlay);
                    }
                    
                    throw error;
                } finally {
                    // Restore original state
                    currentPage = 0;
                    updateAllTextBoxesWithCSVData();
                    
                    // Remove progress overlay
                    if (progressOverlay && progressOverlay.parentNode) {
                        progressOverlay.parentNode.removeChild(progressOverlay);
                    }
                }
                
            } catch (error) {
                console.error('Download failed:', error);
                alert('Error generating PDFs: ' + error.message);
                    
                    // Remove progress overlay on error
                    if (progressOverlay && progressOverlay.parentNode) {
                        progressOverlay.parentNode.removeChild(progressOverlay);
                    }
            } finally {
                    // Remove progress overlay
                    if (progressOverlay && progressOverlay.parentNode) {
                        progressOverlay.parentNode.removeChild(progressOverlay);
                    }
                    
                // Restore button state
                const downloadBtn = document.getElementById('downloadPdfsBtn');
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'Download PDFs';
            }
        }

        // Take Screenshot function
        async function takeScreenshot() {
            try {
                const pdfViewer = document.getElementById('pdfViewer');
                const canvas = document.getElementById('viewer');
                
                if (!pdfViewer || !canvas) {
                    alert('No PDF viewer found. Please upload a PDF first.');
                    return;
                }

                // Show loading state
                const screenshotBtn = document.getElementById('screenshotBtn');
                const originalText = screenshotBtn.textContent;
                screenshotBtn.textContent = '📸 Taking Screenshot...';
                screenshotBtn.disabled = true;

                // Get PDF area dimensions (same as download function)
                const canvasRect = canvas.getBoundingClientRect();
                const viewerRect = pdfViewer.getBoundingClientRect();
                const pdfAreaX = canvasRect.left - viewerRect.left;
                const pdfAreaY = canvasRect.top - viewerRect.top;
                const pdfAreaWidth = canvasRect.width;
                const pdfAreaHeight = canvasRect.height;

                // Calculate high-quality scale factor (same as download function)
                let scale = 6;
                const img = canvas.querySelector('img');
                if (img && img.naturalWidth && img.width) {
                    const originalScale = img.naturalWidth / img.width;
                    scale = Math.max(6, originalScale * 1.5);
                }
                scale = Math.max(4, Math.min(12, scale));

                // Use html2canvas to capture only the PDF area
                const capturedCanvas = await html2canvas(pdfViewer, {
                    scale: scale,
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: '#ffffff',
                    logging: false,
                    x: pdfAreaX,
                    y: pdfAreaY,
                    width: pdfAreaWidth,
                    height: pdfAreaHeight,
                    onclone: (clonedDoc) => {
                        const clonedViewer = clonedDoc.getElementById('pdfViewer');
                        if (clonedViewer) {
                            // Hide UI elements that shouldn't be in screenshot
                            const outline = clonedDoc.getElementById('pdfAreaOutline');
                            if (outline) outline.style.display = 'none';
                            
                            const lockIndicator = clonedViewer.querySelector('.pdf-lock-indicator');
                            if (lockIndicator) lockIndicator.style.display = 'none';
                            
                            // Hide PDF controls (top right corner buttons)
                            const pdfControls = clonedViewer.querySelector('.pdf-controls');
                            if (pdfControls) pdfControls.style.display = 'none';
                            
                            // Remove borders and backgrounds from text boxes for clean screenshot
                            const allBoxes = clonedViewer.querySelectorAll('.draggable-text-box');
                            allBoxes.forEach(box => {
                                box.style.border = 'none';
                                box.style.background = 'transparent';
                                box.style.boxShadow = 'none';
                                box.style.outline = 'none';
                            });
                            
                            // Remove resize handles
                            const resizeHandles = clonedViewer.querySelectorAll('.resize-handle');
                            resizeHandles.forEach(handle => {
                                handle.style.display = 'none';
                            });
                        }
                    }
                });

                // Convert canvas to blob
                capturedCanvas.toBlob((blob) => {
                    // Create download link
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `pdf-screenshot-${Date.now()}.png`;
                    
                    // Trigger download
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Clean up
                    URL.revokeObjectURL(url);
                    
                    // Restore button state
                    screenshotBtn.textContent = originalText;
                    screenshotBtn.disabled = false;
                    
                    console.log('Screenshot taken and downloaded successfully');
                }, 'image/png', 0.95);

            } catch (error) {
                console.error('Screenshot failed:', error);
                alert('Error taking screenshot: ' + error.message);
                
                // Restore button state on error
                const screenshotBtn = document.getElementById('screenshotBtn');
                screenshotBtn.textContent = '📸 TAKE SCREENSHOT';
                screenshotBtn.disabled = false;
            }
        }

        // Download Current PDF function
        async function downloadCurrentPdf() {
            try {
                if (!sessionState.templatePdfBytes) {
                    alert('Please upload a PDF template first');
                    return;
                }

                // Show loading state
                const downloadBtn = document.getElementById('screenshotBtn');
                const originalText = downloadBtn.textContent;
                downloadBtn.textContent = '📄 Generating PDF...';
                downloadBtn.disabled = true;

                // Step 1: Load the template PDF
                console.log('Step 1: Loading template PDF...');
                const pdfDoc = await PDFLib.PDFDocument.load(sessionState.templatePdfBytes);
                const page = pdfDoc.getPages()[0];

                // Step 2: Pre-load all images
                console.log('Step 2: Pre-loading images...');
                await preloadAllImages();

                // Step 3: Capture high-resolution overlay (text boxes and image boxes)
                console.log('Step 3: Capturing high-res overlays...');
                const pdfViewer = document.getElementById('pdfViewer');
                const canvas = document.getElementById('viewer');
                
                if (!pdfViewer || !canvas) {
                    throw new Error('PDF viewer not found');
                }

                // Wait for UI to update
                await new Promise(resolve => setTimeout(resolve, 100));

                // Get PDF area dimensions (same as multi-page function)
                const canvasRect = canvas.getBoundingClientRect();
                const viewerRect = pdfViewer.getBoundingClientRect();
                const pdfAreaX = canvasRect.left - viewerRect.left;
                const pdfAreaY = canvasRect.top - viewerRect.top;
                const pdfAreaWidth = canvasRect.width;
                const pdfAreaHeight = canvasRect.height;
                
                // Calculate optimized scale factor for overlays (same as multi-page function)
                let scale = 4;
                const img = canvas.querySelector('img');
                if (img && img.naturalWidth && img.width) {
                    const originalScale = img.naturalWidth / img.width;
                    scale = Math.max(3, originalScale * 1.5);
                }
                scale = Math.max(2, Math.min(8, scale));
                
                // Capture only the overlay elements with transparency (same as multi-page function)
                const overlayCanvas = await html2canvas(pdfViewer, {
                    scale: scale,
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: null,
                    logging: false,
                    x: pdfAreaX,
                    y: pdfAreaY,
                    width: pdfAreaWidth,
                    height: pdfAreaHeight,
                    onclone: (clonedDoc) => {
                        const clonedViewer = clonedDoc.getElementById('pdfViewer');
                        if (clonedViewer) {
                            // Hide the PDF background completely
                            const pdfCanvas = clonedDoc.getElementById('viewer');
                            if (pdfCanvas) {
                                pdfCanvas.style.display = 'none';
                            }
                            
                            // Hide UI elements
                            const outline = clonedDoc.getElementById('pdfAreaOutline');
                            if (outline) outline.style.display = 'none';
                            
                            const lockIndicator = clonedViewer.querySelector('.pdf-lock-indicator');
                            if (lockIndicator) lockIndicator.style.display = 'none';
                            
                            // Keep only text boxes and image boxes with their styling
                            const allBoxes = clonedViewer.querySelectorAll('.draggable-text-box, .draggable-image-box');
                            allBoxes.forEach(box => {
                                if (box.classList.contains('draggable-text-box')) {
                                    // Text box styling
                                    box.style.border = 'none';
                                    box.style.background = 'transparent';
                                    box.style.boxShadow = 'none';
                                    box.style.outline = 'none';
                                    // Keep font styling for quality
                                    box.style.fontFamily = box.style.fontFamily || 'Arial, sans-serif';
                                    box.style.fontSize = box.style.fontSize || '16px';
                                    box.style.fontWeight = box.style.fontWeight || 'normal';
                                    box.style.color = box.style.color || '#000000';
                                } else if (box.classList.contains('draggable-image-box')) {
                                    // Image box styling
                                    box.style.border = 'none';
                                    box.style.background = 'transparent';
                                    box.style.boxShadow = 'none';
                                    box.style.outline = 'none';
                                    // Ensure images are visible and properly sized
                                    const img = box.querySelector('img');
                                    if (img) {
                                        // Use natural dimensions to prevent stretching
                                        const naturalWidth = img.naturalWidth;
                                        const naturalHeight = img.naturalHeight;
                                        const boxWidth = box.offsetWidth;
                                        const boxHeight = box.offsetHeight;
                                        
                                        // Calculate aspect ratio and fit image properly
                                        const imageAspect = naturalWidth / naturalHeight;
                                        const boxAspect = boxWidth / boxHeight;
                                        
                                        if (imageAspect > boxAspect) {
                                            // Image is wider than box - fit to width
                                            img.style.width = '100%';
                                            img.style.height = 'auto';
                                        } else {
                                            // Image is taller than box - fit to height
                                            img.style.width = 'auto';
                                            img.style.height = '100%';
                                        }
                                        
                                        img.style.objectFit = 'none';
                                        img.style.objectPosition = 'center';
                                        img.style.display = 'block';
                                    }
                                    
                                    // Hide "No Image" text in downloaded PDFs
                                    if (box.textContent === 'No Image') {
                                        box.textContent = '';
                                    }
                                }
                            });
                            
                            // Remove resize handles (use !important to override CSS)
                            const resizeHandles = clonedViewer.querySelectorAll('.resize-handle');
                            resizeHandles.forEach(handle => {
                                handle.style.setProperty('display', 'none', 'important');
                                handle.style.setProperty('opacity', '0', 'important');
                            });
                            
                            // Hide "No Image" text in downloaded PDFs
                            const imageBoxes = clonedViewer.querySelectorAll('.draggable-image-box');
                            imageBoxes.forEach(box => {
                                if (box.textContent === 'No Image') {
                                    box.textContent = '';
                                }
                            });
                            
                            // Make background transparent
                            clonedViewer.style.background = 'transparent';
                            
                            // Hide PDF controls (top right corner buttons)
                            const pdfControls = clonedViewer.querySelector('.pdf-controls');
                            if (pdfControls) pdfControls.style.display = 'none';
                        }
                    }
                });

                // Step 4: Convert overlay to PNG with transparency
                console.log('Step 4: Converting overlay to PNG...');
                const overlayPngDataUrl = overlayCanvas.toDataURL('image/png', 1.0);

                // Step 5: Embed overlay image into PDF
                console.log('Step 5: Embedding overlay into PDF...');
                const overlayImage = await pdfDoc.embedPng(overlayPngDataUrl);

                // Get page dimensions
                const { width: pageWidth, height: pageHeight } = page.getSize();

                // Add overlay image to page (full page coverage)
                page.drawImage(overlayImage, {
                    x: 0,
                    y: 0,
                    width: pageWidth,
                    height: pageHeight,
                });

                // Step 6: Save and download
                console.log('Step 6: Saving and downloading...');
                const pdfBytes = await pdfDoc.save();
                
                // Create download link
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `current-pdf-${Date.now()}.pdf`;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up
                URL.revokeObjectURL(url);
                
                // Restore button state
                downloadBtn.textContent = originalText;
                downloadBtn.disabled = false;
                
                console.log('Current PDF downloaded successfully');
                
            } catch (error) {
                console.error('Download failed:', error);
                alert('Error downloading PDF: ' + error.message);
                
                // Restore button state on error
                const downloadBtn = document.getElementById('screenshotBtn');
                downloadBtn.textContent = '📄 Download Current PDF';
                downloadBtn.disabled = false;
            }
        }

        // Helper function to convert hex color to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Generate From Template function
        async function generateFromTemplate() {
            try {
                if (!sessionState.templatePdfBytes) {
                    alert('Please select a PDF template first');
                    return;
                }

                // Load the template PDF using the Uint8Array copy
                const pdfDoc = await PDFLib.PDFDocument.load(sessionState.templatePdfBytes);
                
                // Embed the Helvetica Bold font
                const helveticaBoldFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);
                
                // Get the first page
                const pages = pdfDoc.getPages();
                if (pages.length === 0) {
                    throw new Error('Template PDF has no pages');
                }
                
                const page = pages[0];
                
                // Get current timestamp for demo data
                const timestamp = new Date().toISOString();
                const dateStr = new Date().toLocaleDateString();
                
                // Add text overlay at fixed positions
                page.drawText('TICKET #12345', {
                    x: 100,
                    y: 700,
                    size: 16,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0, 0, 0)
                });
                
                page.drawText(`Date: ${dateStr}`, {
                    x: 100,
                    y: 650,
                    size: 12,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0.2, 0.2, 0.2)
                });
                
                page.drawText(`Generated: ${timestamp}`, {
                    x: 100,
                    y: 620,
                    size: 10,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0.4, 0.4, 0.4)
                });
                
                // Add some sample fields
                page.drawText('Customer: John Doe', {
                    x: 100,
                    y: 580,
                    size: 12,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0, 0, 0)
                });
                
                page.drawText('Amount: $99.99', {
                    x: 100,
                    y: 550,
                    size: 14,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0.8, 0, 0)
                });
                
                page.drawText('Status: PAID', {
                    x: 100,
                    y: 520,
                    size: 12,
                    font: helveticaBoldFont,
                    color: PDFLib.rgb(0, 0.6, 0)
                });
                
                // Save the modified PDF
                const pdfBytes = await pdfDoc.save();
                
                // Create a blob and download link
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                
                // Create and trigger download
                const link = document.createElement('a');
                link.href = url;
                link.download = `template-generated-${Date.now()}.pdf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the URL
                URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error generating from template:', error);
                alert('Error generating from template: ' + error.message);
            }
        }



        function parseCSVFile(file) {
            console.log('parseCSVFile function called with file:', file);
            console.log('Parsing CSV file:', file.name, file.size);
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    console.log('CSV parsing complete:', results);
                    if (results.errors.length > 0) {
                        console.error('CSV parsing errors:', results.errors);
                        alert('Error parsing CSV file. Please check the file format.');
                        return;
                    }

                    // Store CSV data in session state and global variable
                    sessionState.csv = file;
                    sessionState.csvRows = results.data;
                    csvData = results.data;
                    
                    // Add columns property to csvData for compatibility with MERGE-ONLINE
                    if (results.data && results.data.length > 0) {
                        csvData.columns = Object.keys(results.data[0]);
                        sessionState.csvColumns = Object.keys(results.data[0]); // Add this line
                        
                        // Debug: Check for malformed URLs in image columns
                        const imageColumns = Object.keys(results.data[0]).filter(col => 
                            col.toLowerCase().includes('image') || 
                            col.toLowerCase().includes('img') || 
                            col.toLowerCase().includes('photo') ||
                            col.toLowerCase().includes('url')
                        );
                        
                        if (imageColumns.length > 0) {
                            console.log('Found potential image columns:', imageColumns);
                            // Check first few rows for malformed URLs
                            for (let i = 0; i < Math.min(3, results.data.length); i++) {
                                imageColumns.forEach(col => {
                                    const url = results.data[i][col];
                                    if (url && url.includes('http')) {
                                        console.log(`Row ${i}, Column ${col}:`, url);
                                        if (url.includes('http') && url.split('http').length > 2) {
                                            console.warn(`⚠️ MALFORMED URL DETECTED in row ${i}, column ${col}:`, url);
                                        }
                                    }
                                });
                            }
                        }
                    }
                    
                    currentRecord = 0;
                    

                    

                    
                    // Display preview
                    displayCSVPreview(results.data);
                    
                    // Show record navigation
                    showRecordNavigation();
                    
                    // Update file label
                    document.getElementById('csvLabel').textContent = file.name;
                    
                    // Update box editor if a box is selected
                    if (sessionState.selectedBox) {
                        updateBoxEditorValues(sessionState.selectedBox);
                    }
                    
                    // Update all text boxes with CSV data
                    updateAllTextBoxesWithCSVData();
                    
                    // Update download button state
                    updateDownloadButtonState();
                    
                    // Update records info
                    updateRecordsInfo();
                    
                    // Initialize page navigation
                    updatePageNavigation();
                    
                    // Update create records button state
                    updateCreateRecordsButtonState();
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    alert('Error reading CSV file: ' + error.message);
                }
            });
        }

        function displayCSVPreview(data) {
            console.log('Displaying CSV preview with data:', data);
            if (!data || data.length === 0) {
                console.log('No CSV data to display');
                return;
            }

            // CSV preview section was removed, so we just log the data
            console.log('CSV loaded successfully:', data.length, 'rows');
            console.log('CSV columns:', Object.keys(data[0]));
            
            // Check for malformed URLs and provide user feedback
            const malformedUrls = findMalformedUrls(data);
            if (malformedUrls.length > 0) {
                console.warn('⚠️ MALFORMED URLs detected in CSV:', malformedUrls.length, 'issues found');
                showMalformedUrlWarning(malformedUrls);
            }
        }
        
        function findMalformedUrls(data) {
            const malformed = [];
            const imageColumns = Object.keys(data[0]).filter(col => 
                col.toLowerCase().includes('image') || 
                col.toLowerCase().includes('img') || 
                col.toLowerCase().includes('photo') ||
                col.toLowerCase().includes('url')
            );
            
            data.forEach((row, index) => {
                imageColumns.forEach(col => {
                    const url = row[col];
                    if (url && typeof url === 'string' && url.includes('http')) {
                        if (url.includes('http') && url.split('http').length > 2) {
                            malformed.push({
                                row: index + 1,
                                column: col,
                                url: url,
                                type: 'concatenated_urls'
                            });
                        } else if (url.includes('...') && url.includes(':')) {
                            malformed.push({
                                row: index + 1,
                                column: col,
                                url: url,
                                type: 'domain_concat'
                            });
                        }
                    }
                });
            });
            
            return malformed;
        }
        
        function showMalformedUrlWarning(malformedUrls) {
            const warningDiv = document.createElement('div');
            warningDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #fff3cd;
                border: 1px solid #ffeaa7;
                border-radius: 5px;
                padding: 15px;
                max-width: 400px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 10000;
                font-family: Arial, sans-serif;
            `;
            
            warningDiv.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <span style="font-size: 20px; margin-right: 10px;">⚠️</span>
                    <strong>CSV URL Issues Detected</strong>
                </div>
                <p style="margin: 0 0 10px 0; font-size: 14px;">
                    Found ${malformedUrls.length} malformed image URLs in your CSV file. 
                    The app will attempt to fix these automatically, but you may want to clean your CSV file.
                </p>
                <div style="font-size: 12px; color: #666; margin-bottom: 10px;">
                    <strong>Issues found:</strong><br>
                    ${malformedUrls.slice(0, 3).map(issue => 
                        `Row ${issue.row}, ${issue.column}: ${issue.url.substring(0, 50)}...`
                    ).join('<br>')}
                    ${malformedUrls.length > 3 ? `<br>... and ${malformedUrls.length - 3} more` : ''}
                </div>
                <button onclick="this.parentElement.remove()" style="
                    background: #007bff;
                    color: white;
                    border: none;
                    padding: 5px 15px;
                    border-radius: 3px;
                    cursor: pointer;
                    font-size: 12px;
                ">Dismiss</button>
            `;
            
            document.body.appendChild(warningDiv);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (warningDiv.parentElement) {
                    warningDiv.remove();
                }
            }, 10000);
        }

        function toggleCSVPreview() {
            // CSV preview functionality was removed
        }

        function resetSession() {
            // Cancel any ongoing PDF rendering operations
            if (window.currentRenderTask) {
                try {
                    window.currentRenderTask.cancel();
                    console.log('Cancelled render task during session reset');
                } catch (cancelError) {
                    console.log('Render task already completed or cancelled');
                }
                window.currentRenderTask = null;
            }
            
            // Clear session state
            sessionState = {
                templatePdf: null,
                templatePdfBytes: null,
                csv: null,
                csvRows: [],
                layout: null,
                boxes: [],
                selectedBox: null,
                // Preserve file metadata for change detection
                pdfMetadata: sessionState.pdfMetadata,
                csvMetadata: sessionState.csvMetadata,
                // Preserve live monitoring setting
                liveMonitoringEnabled: sessionState.liveMonitoringEnabled
            };
            
            // Reset box counter
            boxCounter = 0;
            currentBoxId = null;
            
            // Clear editor canvas
            if (editorCanvas) {
                editorCanvas.clear();
            }
            
            // Hide box editor
            updateBoxEditor();

            // Clear current variables
            currentPdf = null;
            currentFile = null;
            serverPdfUrl = null;
            
            // Clear PDF metadata when PDF is removed
            sessionState.pdfMetadata = null;

            // Reset UI
            const fileLabel = document.getElementById('fileLabel');
            const downloadLink = document.getElementById('downloadLink');
            const noPdf = document.getElementById('noPdf');
            const loadingPdf = document.getElementById('loadingPdf');
            const viewer = document.getElementById('viewer');
            
            if (fileLabel) fileLabel.textContent = 'Click to select PDF file';
            if (downloadLink) downloadLink.style.display = 'none';
            if (noPdf) {
                noPdf.style.display = 'block';
                noPdf.innerHTML = `
                <h3>No PDF selected</h3>
                <p>Choose a PDF file to start viewing</p>
            `;
            }
            if (loadingPdf) loadingPdf.style.display = 'none';
            if (viewer) viewer.style.display = 'none';

            // Clear file inputs
            const pdfFileInput = document.getElementById('pdfFile');
            const csvFileInput = document.getElementById('csvFile');
            const csvLabel = document.getElementById('csvLabel');
            
            if (pdfFileInput) pdfFileInput.value = '';
            if (csvFileInput) csvFileInput.value = '';
            if (csvLabel) csvLabel.textContent = 'Click to select CSV file';
            
            // Clear file metadata when files are removed
            sessionState.pdfMetadata = null;
            sessionState.csvMetadata = null;
            // csvPreview element was removed

            // Disable Generate From Template button
                            // generateFromTemplateBtn was removed
            
            // Update download button state
            updateDownloadButtonState();



            // Revoke any ObjectURLs if they exist
            if (serverPdfUrl && serverPdfUrl.startsWith('blob:')) {
                URL.revokeObjectURL(serverPdfUrl);
            }
        }

        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('collapsed');
        }

        // Font Management Functions
        function initializeFontHandling() {
            const fontUploadArea = document.getElementById('fontUploadArea');
            const fontUploadInput = document.getElementById('fontUploadInput');
            const addFontUrlBtn = document.getElementById('addFontUrlBtn');
            const fontUrlInput = document.getElementById('fontUrlInput');

            if (fontUploadArea && fontUploadInput) {
                fontUploadArea.addEventListener('click', () => fontUploadInput.click());
                fontUploadArea.addEventListener('dragover', e => {
                    e.preventDefault();
                    fontUploadArea.classList.add('dragover');
                });
                fontUploadArea.addEventListener('dragleave', e => {
                    e.preventDefault();
                    fontUploadArea.classList.remove('dragover');
                });
                fontUploadArea.addEventListener('drop', e => {
                    e.preventDefault();
                    fontUploadArea.classList.remove('dragover');
                    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                        handleFontUpload(e.dataTransfer.files[0]);
                    }
                });
                fontUploadInput.addEventListener('change', e => {
                    if (fontUploadInput.files && fontUploadInput.files[0]) {
                        handleFontUpload(fontUploadInput.files[0]);
                    }
                });
            }

            if (addFontUrlBtn && fontUrlInput) {
                addFontUrlBtn.addEventListener('click', handleGoogleFontUrl);
            }
            
            // Initialize font dropdowns
            updateFontDropdowns();
        }

        function handleFontUpload(file) {
            const status = document.getElementById('fontUploadStatus');
            
            if (!file.name.match(/\.(ttf|otf)$/i)) {
                status.textContent = 'Only .ttf and .otf files are allowed.';
                status.className = 'font-status error';
                return;
            }
            
            status.textContent = 'Processing font...';
            status.className = 'font-status';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const base64 = e.target.result.split(',')[1];
                    const fontName = file.name.replace(/\.(ttf|otf)$/i, '');
                    const fileExtension = file.name.match(/\.(ttf|otf)$/i)[1].toLowerCase();
                    const format = fileExtension === 'ttf' ? 'truetype' : 'opentype';
                    
                    // Remove existing font-face if it exists
                    const existingStyle = document.getElementById(`font-face-${fontName}`);
                    if (existingStyle) {
                        existingStyle.remove();
                    }
                    
                    // Create @font-face rule with data URL
                    const style = document.createElement('style');
                    style.id = `font-face-${fontName}`;
                    style.textContent = `
                        @font-face {
                            font-family: '${fontName}';
                            src: url(data:font/${fileExtension};base64,${base64}) format('${format}');
                            font-display: swap;
                        }
                    `;
                    document.head.appendChild(style);
                    
                    // Add to available fonts if not already present
                    if (!sessionState.availableFonts) {
                        sessionState.availableFonts = [];
                    }
                    if (!sessionState.availableFonts.includes(fontName)) {
                        sessionState.availableFonts.push(fontName);
                        updateFontDropdowns();
                    }
                    
                    // Set as default font for new text boxes
                    sessionState.defaultFontFamily = fontName;
                    
                    // Update existing text boxes that use the old default
                    sessionState.boxes.forEach(box => {
                        if (box.boxType === 'text' && (!box.fontFamily || box.fontFamily === 'Arial')) {
                            box.fontFamily = fontName;
                            if (box.element) {
                                box.element.style.fontFamily = `'${fontName}', Arial, sans-serif`;
                            }
                        }
                    });
                    
                    // Update the format all dropdown to show the new font
                    const formatAllFontFamily = document.getElementById('formatAllFontFamily');
                    if (formatAllFontFamily) {
                        formatAllFontFamily.value = fontName;
                    }
                    
                    // Update current text box if selected
                    if (sessionState.selectedBox && sessionState.selectedBox.boxType === 'text') {
                        sessionState.selectedBox.fontFamily = fontName;
                        updateTextBoxFont(sessionState.selectedBox);
                        // Update the dropdown to show the new font
                        const boxFontFamily = document.getElementById('boxFontFamily');
                        if (boxFontFamily) {
                            boxFontFamily.value = fontName;
                        }
                    }
                    
                    status.textContent = `Font "${fontName}" loaded successfully and applied to text boxes!`;
                    status.className = 'font-status success';
                    
                } catch (error) {
                    console.error('Error processing font:', error);
                    status.textContent = 'Error processing font file.';
                    status.className = 'font-status error';
                }
            };
            
            reader.onerror = function() {
                status.textContent = 'Error reading font file.';
                status.className = 'font-status error';
            };
            
            reader.readAsDataURL(file);
        }

        async function handleGoogleFontUrl() {
            const urlInput = document.getElementById('fontUrlInput');
            const status = document.getElementById('fontUrlStatus');
            const url = urlInput.value.trim();
            
            if (!url) {
                status.textContent = 'Please paste a Google Fonts URL.';
                status.className = 'font-status error';
                return;
            }
            
            if (url.includes('fonts.google.com/share')) {
                status.textContent = 'This is a share link. Please use the "Use on the web" link from Google Fonts.';
                status.className = 'font-status error';
                return;
            }
            
            status.textContent = 'Adding font...';
            status.className = 'font-status';
            
            if (url.startsWith('http') && url.includes('fonts.googleapis.com')) {
                let fontName = await getFontFamilyFromGoogleFontsUrl(url);
                if (!fontName) {
                    status.textContent = 'Could not determine font name. Please check the URL.';
                    status.className = 'font-status error';
                    return;
                }
                
                if (!document.querySelector(`link[href="${url}"]`)) {
                    const link = document.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = url;
                    document.head.appendChild(link);
                }
                
                if (!availableFonts.includes(fontName)) {
                    availableFonts.push(fontName);
                    updateFontDropdown();
                }
                
                // Update current text box if selected
                if (sessionState.selectedBox && sessionState.selectedBox.type === 'text') {
                    sessionState.selectedBox.fontFamily = fontName;
                    updateTextBoxFont(sessionState.selectedBox);
                    // Update the dropdown to show the new font
                    document.getElementById('boxFontFamily').value = fontName;
                }
                
                status.textContent = `Font "${fontName}" added successfully!`;
                status.className = 'font-status success';
                urlInput.value = '';
                
            } else {
                status.textContent = 'Please enter a valid Google Fonts URL.';
                status.className = 'font-status error';
            }
        }

        async function getFontFamilyFromGoogleFontsUrl(url) {
            try {
                const res = await fetch(url);
                const css = await res.text();
                const match = css.match(/font-family:\s*'([^']+)'/);
                if (match) {
                    return match[1];
                }
            } catch (e) {
                console.warn('Could not fetch Google Fonts CSS:', e);
            }
            
            // Fallback: try to parse from URL
            const urlMatch = url.match(/family=([^:&]+)/);
            if (urlMatch) {
                return decodeURIComponent(urlMatch[1]).replace(/\+/g, ' ').split(':')[0];
            }
            return '';
        }

        function updateFontDropdown() {
            const fontSelect = document.getElementById('boxFontFamily');
            if (!fontSelect) return;
            
            // Store current selection
            const currentValue = fontSelect.value;
            
            // Clear and rebuild options
            fontSelect.innerHTML = '';
            availableFonts.forEach(font => {
                const option = document.createElement('option');
                option.value = font;
                option.textContent = font;
                option.selected = font === currentValue;
                fontSelect.appendChild(option);
            });
        }

        function updateTextBoxFont(box) {
            if (!box || box.type !== 'text') return;
            
            const element = box.element;
            if (element) {
                element.style.fontFamily = `'${box.fontFamily}', Arial, sans-serif`;
                element.style.fontSize = (box.fontSize || 16) + 'px';
                element.style.color = box.color || '#000000';
                element.style.fontWeight = box.bold ? 'bold' : 'normal';
                element.style.fontStyle = box.italic ? 'italic' : 'normal';
                element.style.textDecoration = box.underline ? 'underline' : 'none';
                
                // Set text alignment and flex properties for consistent positioning
                element.style.textAlign = box.textAlign || 'center';
                element.style.justifyContent = box.textAlign === 'left' ? 'flex-start' : 
                                             box.textAlign === 'right' ? 'flex-end' : 'center';
                
                // Don't auto-resize - let user manually resize to reveal hidden text
                // This keeps text position consistent regardless of content length
            }
        }

        // CSV Data Binding Functions
        function showRecordNavigation() {
            // Record navigation was moved to the main interface
            // This function is kept for compatibility but does nothing
        }

        function updateRecordInfo() {
            // recordInfo element was removed with the CSV Data drawer
            // This function is kept for compatibility but does nothing
        }

        function updateAllTextBoxesWithCSVData() {
            sessionState.boxes.forEach(box => {
                if (box.type === 'text' && box.csvColumn) {
                    // Use current record for this text box
                    updateTextBoxWithCSVData(box);
                } else if (box.boxType === 'image' && box.csvColumn) {
                    // Handle image boxes
                    updateImageBoxWithCSVData(box);
                }
            });
        }

        function updateAllTextBoxesForSingleRecord(recordIndex) {
            sessionState.boxes.forEach(box => {
                if (box.type === 'text' && box.csvColumn) {
                    // In single record mode, all text boxes show the same record
                    updateTextBoxForSingleRecord(box, recordIndex);
                } else if (box.boxType === 'image' && box.csvColumn) {
                    // In single record mode, all image boxes show the same record
                    updateImageBoxForSingleRecord(box, recordIndex);
                }
            });
        }

        function updateTextBoxWithCSVData(box) {
            if (!box || !box.element || !csvData) return;
            
            // Calculate which record this text box should show based on its position
            const boxIndex = sessionState.boxes.indexOf(box);
            const recordIndex = currentPage * recordsPerPage + boxIndex;
            
            if (recordIndex >= csvData.length) {
                // No more records, show empty
                updateTextBoxContentSafely(box.element, '');
                return;
            }
            
            const row = csvData[recordIndex];
            const text = row[box.csvColumn] || '';
            
            // Update the text content while preserving resize handles
            updateTextBoxContentSafely(box.element, text);
            
            // Apply formatting
            updateTextBoxFont(box);
        }

        function updateTextBoxForSingleRecord(box, recordIndex) {
            if (!box || !box.element || !csvData) return;
            
            if (recordIndex >= csvData.length) {
                // No more records, show empty
                updateTextBoxContentSafely(box.element, '');
                return;
            }
            
            const row = csvData[recordIndex];
            const text = row[box.csvColumn] || '';
            
            // Update the text content while preserving resize handles
            updateTextBoxContentSafely(box.element, text);
            
            // Apply formatting
            updateTextBoxFont(box);
        }

        function updateImageBoxForSingleRecord(box, recordIndex) {
            if (!box || !box.element || !csvData) return;
            
            if (recordIndex >= csvData.length) {
                // No more records, show placeholder
                box.element.textContent = 'No Image';
                box.element.style.border = '2px dashed #ccc';
                box.element.style.background = 'transparent';
                return;
            }
            
            const row = csvData[recordIndex];
            const imageUrl = row[box.csvColumn] || '';
            
            // Load the new image using proxy to handle CORS
            if (imageUrl && imageUrl.trim() !== '') {
                console.log('Loading image for single record:', imageUrl);
                
                // Use proxy to handle CORS
                const proxiedUrl = 'proxy_image.php?url=' + encodeURIComponent(imageUrl);
                console.log('Proxied URL for single record image:', proxiedUrl);
                
                // Create image element
                const img = document.createElement('img');
                img.crossOrigin = 'anonymous';
                img.src = proxiedUrl;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                img.style.objectPosition = 'center';
                
                // Add error handling
                img.onerror = function() {
                    console.error('Failed to load image for single record:', imageUrl);
                    box.element.textContent = 'Load Failed';
                    box.element.style.color = '#ffc107';
                    box.element.style.fontWeight = 'bold';
                    box.element.style.fontSize = '12px';
                    box.element.style.border = '2px dashed #ffc107';
                    box.element.style.background = 'rgba(255, 193, 7, 0.1)';
                };
                
                img.onload = function() {
                    console.log('Image loaded successfully for single record:', imageUrl);
                };
                
                // Clear existing content and add image
                box.element.innerHTML = '';
                box.element.appendChild(img);
            } else {
                // Show placeholder if no image URL
                box.element.textContent = 'No Image';
                box.element.style.border = '2px dashed #ccc';
                box.element.style.background = 'transparent';
            }
        }
        
        function updateTextBoxWithMappedCSVData(box) {
            if (!box || !box.element || !csvData) return;
            
            const mappedRowIndex = textBoxMappings[box.id];
            if (mappedRowIndex === undefined || !csvData[mappedRowIndex]) return;
            
            const row = csvData[mappedRowIndex];
            const text = row[box.csvColumn] || '';
            
            // Update the text content while preserving resize handles
            updateTextBoxContentSafely(box.element, text);
            
            // Apply formatting
            updateTextBoxFont(box);
        }

        function updateTextBoxContent(box) {
            if (!box || !box.element) return;
            
            let text = '';
            
            if (box.csvColumn && csvData && csvData[currentRecord]) {
                // Use CSV data
                text = csvData[currentRecord][box.csvColumn] || '';
            } else {
                // Use static text
                text = box.staticText || 'Sample Text';
            }
            
            updateTextBoxContentSafely(box.element, text);
            updateTextBoxFont(box);
        }



        function updateTextBoxContentSafely(element, text) {
            if (!element) return;
            
            // Store resize handles
            const resizeHandles = Array.from(element.querySelectorAll('.resize-handle'));
            
            // Update text content
            element.textContent = text;
            
            // Restore resize handles
            resizeHandles.forEach(handle => {
                element.appendChild(handle);
            });
        }

        function autoResizeTextBox(box) {
            if (!box || !box.element) return;
            
            const element = box.element;
            const text = element.textContent;
            
            if (!text) return;
            
            // Create a temporary element to measure text dimensions
            const tempElement = document.createElement('div');
            tempElement.style.cssText = `
                position: absolute;
                visibility: hidden;
                white-space: nowrap;
                font-family: ${element.style.fontFamily || 'Arial, sans-serif'};
                font-size: ${element.style.fontSize || '16px'};
                font-weight: ${element.style.fontWeight || 'normal'};
                font-style: ${element.style.fontStyle || 'normal'};
                padding: ${element.style.padding || '5px'};
                box-sizing: border-box;
            `;
            tempElement.textContent = text;
            
            document.body.appendChild(tempElement);
            
            // Get the measured dimensions
            const textWidth = tempElement.offsetWidth;
            const textHeight = tempElement.offsetHeight;
            
            // Remove the temporary element
            document.body.removeChild(tempElement);
            
            // Calculate new box dimensions with some padding
            const padding = 10;
            const newWidth = Math.max(20, textWidth + padding * 2);
            const newHeight = Math.max(15, textHeight + padding * 2);
            
            // Update the box dimensions
            element.style.width = newWidth + 'px';
            element.style.height = newHeight + 'px';
            
            // Update the box data
            box.width = newWidth;
            box.height = newHeight;
            
            // Update the position inputs in the editor
            const widthInput = document.getElementById('boxWidth');
            const heightInput = document.getElementById('boxHeight');
            if (widthInput) widthInput.value = newWidth;
            if (heightInput) heightInput.value = newHeight;
        }
    </script>
</body>
</html>
